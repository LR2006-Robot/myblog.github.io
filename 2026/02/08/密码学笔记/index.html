
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>密码学笔记 | 密码学の小屋</title>
    <meta name="author" content="Dorange" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/myblog.github.io/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/myblog.github.io/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/myblog.github.io/js/lib/math.js"></script>


<script src="/myblog.github.io/js/lib/preview.js"></script>









<link rel="stylesheet" href="/myblog.github.io/css/main.css" />

<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/myblog.github.io/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/myblog.github.io/">
            <span>密码学の小屋</span>
        </a>
        
        <a href="/myblog.github.io/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/myblog.github.io/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/myblog.github.io/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/myblog.github.io/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/myblog.github.io/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;密码学の小屋</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/myblog.github.io/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/myblog.github.io/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/myblog.github.io/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/myblog.github.io/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/myblog.github.io/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>密码学笔记</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2026/2/8
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <!-- toc -->

<ul>
<li><a href="#%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81">古典密码</a><ul>
<li><a href="#%E5%8D%95%E8%A1%A8%E6%9B%BF%E6%8D%A2%E5%AF%86%E7%A0%81">单表替换密码</a><ul>
<li><a href="#caesar-cipher-%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81">Caesar Cipher 凯撒密码</a><ul>
<li><a href="#%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">凯撒加密代码实现</a></li>
<li><a href="#%E5%87%AF%E6%92%92%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">凯撒解密代码实现</a></li>
</ul>
</li>
<li><a href="#simple-substitution-cipher-%E7%AE%80%E5%8D%95%E6%9B%BF%E6%8D%A2%E5%AF%86%E7%A0%81">Simple Substitution Cipher 简单替换密码</a><ul>
<li><a href="#%E5%AD%97%E9%A2%91%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81">字频攻击代码</a></li>
</ul>
</li>
<li><a href="#atbash-cipher-%E5%9F%83%E7%89%B9%E5%B7%B4%E4%BB%80%E7%A0%81">Atbash Cipher 埃特巴什码</a></li>
<li><a href="#morse-cipher-%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81">Morse Cipher 摩斯密码</a></li>
<li><a href="#affine-cipher-%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81">Affine Cipher 仿射密码</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E8%A1%A8%E6%9B%BF%E6%8D%A2%E5%AF%86%E7%A0%81">多表替换密码</a><ul>
<li><a href="#%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81">维吉尼亚密码</a><ul>
<li><a href="#%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%87%86%E7%A1%AE%E5%8F%AA%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E5%8F%82%E8%80%83">维吉尼亚解密代码实现(不一定准确只可以大致参考)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%AF%86%E7%A0%81">其他类型密码</a><ul>
<li><a href="#rail-fence-cipher-%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81">Rail-Fence Cipher 栅栏密码</a></li>
<li><a href="#baconian-cipher-%E5%9F%B9%E6%A0%B9%E5%AF%86%E7%A0%81">Baconian Cipher 培根密码</a><ul>
<li><a href="#%E5%9F%B9%E6%A0%B9%E5%AF%86%E7%A0%81%E8%A1%A8">培根密码表</a></li>
<li><a href="#%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">栅栏加密代码实现</a></li>
<li><a href="#%E6%A0%85%E6%A0%8F%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">栅栏解密代码实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81">现代密码</a><ul>
<li><a href="#%E4%B8%8D%E5%90%8C%E5%88%86%E7%B1%BB">不同分类</a><ul>
<li><a href="#%E6%8C%89%E7%85%A7%E5%AF%86%E9%92%A5%E7%9A%84%E7%89%B9%E6%80%A7%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB">按照密钥的特性进行分类</a></li>
<li><a href="#%E6%8C%89%E7%85%A7%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB">按照功能分类</a></li>
<li><a href="#%E6%8C%89%E7%85%A7%E6%8A%97%E9%87%8F%E5%AD%90%E8%83%BD%E5%8A%9B">按照抗量子能力</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81">对称密码</a><ul>
<li><a href="#%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-rc4rivest-cipher-4-%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9%E5%AF%86%E7%A0%814">序列密码-RC4(Rivest Cipher 4 李维斯特密码4)</a><ul>
<li><a href="#s%E7%9B%92%E5%88%9D%E5%A7%8B%E5%8C%96ksa">S盒初始化(KSA)</a></li>
<li><a href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%B5%81%E7%94%9F%E6%88%90prga">伪随机流生成(PRGA)</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-rc4%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">序列密码-RC4加解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-otpone-time-pad-%E4%B8%80%E6%AC%A1%E4%B8%80%E5%AF%86">序列密码-OTP(One Time Pad 一次一密)</a><ul>
<li><a href="#otp%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">OTP加密代码实现</a></li>
<li><a href="#otp%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%80">OTP解密方式一</a></li>
<li><a href="#otp%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%8F%AF%E5%AE%9E%E7%8E%B0%E7%8E%87%E6%9E%81%E4%BD%8E">OTP解密方式二(可实现率极低)</a><ul>
<li><a href="#%E8%A7%A3%E5%AF%86%E5%8E%9F%E7%90%86%E4%B8%80">解密原理一</a></li>
<li><a href="#%E8%A7%A3%E5%AF%86%E5%8E%9F%E7%90%86%E4%BA%8C">解密原理二</a></li>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-lcglinear-congruential-generator-%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E7%94%9F%E6%88%90%E5%99%A8">序列密码-LCG(Linear Congruential Generator 线性同余生成器)</a><ul>
<li><a href="#%E8%A7%A3%E5%AF%86%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">解密前置知识</a><ul>
<li><a href="#%E5%90%8C%E4%BD%99%E8%BF%90%E7%AE%97%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8">同余运算简单性质</a></li>
<li><a href="#%E9%80%86%E7%9B%B8%E5%85%B3%E8%BF%90%E7%AE%97">逆相关运算</a></li>
</ul>
</li>
<li><a href="#lcg%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%80">LCG解密方式一</a></li>
<li><a href="#lcg%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%BA%8C">LCG解密方式二</a></li>
<li><a href="#lcg%E4%BE%8B%E9%A2%98">LCG例题</a><ul>
<li><a href="#lcg%E4%BE%8B%E9%A2%98%E9%A2%98%E7%9B%AE">LCG例题题目</a></li>
<li><a href="#lcg%E4%BE%8B%E9%A2%98%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81">LCG例题解题代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81-lfsrlinear-feedback-shift-register-%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8">序列密码-LFSR(Linear Feedback Shift Register 线性反馈移位寄存器)</a><ul>
<li><a href="#lfsr%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E5%87%BD%E6%95%B0">LFSR线性反馈函数</a></li>
<li><a href="#lfsr%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%80">LFSR解密方式一</a></li>
<li><a href="#lfsr%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%BA%8C">LFSR解密方式二</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-desdata-encryption-standard-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">分组密码-DES(Data Encryption Standard 数据加密标准)</a><ul>
<li><a href="#des%E5%8A%A0%E5%AF%86%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2%E5%92%8C%E6%9C%80%E7%BB%88%E7%BD%AE%E6%8D%A2">DES加密初始置换和最终置换</a><ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E7%BD%AE%E6%8D%A2initial-permutation%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">初始置换(Initial Permutation)代码实现</a></li>
</ul>
</li>
<li><a href="#des%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95">DES密钥扩展算法</a><ul>
<li><a href="#des%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">DES密钥扩展算法代码实现</a></li>
</ul>
</li>
<li><a href="#des%E5%8A%A0%E5%AF%86%E8%BD%AE%E5%87%BD%E6%95%B0feistel-function-%E8%B4%B9%E6%96%AF%E5%A6%A5%E5%87%BD%E6%95%B0">DES加密轮函数(Feistel Function 费斯妥函数)</a><ul>
<li><a href="#des%E5%8A%A0%E5%AF%86%E8%BD%AE%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">DES加密轮函数代码实现</a></li>
</ul>
</li>
<li><a href="#des%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B">DES加密过程</a><ul>
<li><a href="#des%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">DES加密代码实现</a></li>
</ul>
</li>
<li><a href="#des%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">DES加解密代码实现</a><ul>
<li><a href="#des%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F%E4%B8%80">DES解密方式一</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-aesadvanced-encryption-standard-%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">分组密码-AES(Advanced Encryption Standard 高级加密标准)</a><ul>
<li><a href="#aes%E7%AE%97%E6%B3%95%E5%B1%82%E5%8A%A0%E5%AF%86">AES算法层加密</a><ul>
<li><a href="#aes%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">AES加密算法框架代码实现</a></li>
<li><a href="#aes%E7%AE%97%E6%B3%95%E5%B1%82-%E6%89%A9%E6%95%A3%E5%B1%82">AES算法层-扩散层</a></li>
<li><a href="#aes%E7%AE%97%E6%B3%95%E5%B1%82-%E5%AF%86%E9%92%A5%E5%8A%A0%E6%B3%95%E5%B1%82">AES算法层-密钥加法层</a></li>
<li><a href="#aes%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95">AES密钥扩展算法</a></li>
</ul>
</li>
<li><a href="#aes%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">AES加解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F">分组密码-分组模式</a><ul>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-ecbelectronic-code-book-mode-%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E6%9C%AC%E6%A8%A1%E5%BC%8F">分组模式-ECB(Electronic Code Book mode 电子密码本模式)</a><ul>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-ecb%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">分组模式-ECB加解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-cbccipher-block-chaining-mode-%E5%AF%86%E7%A0%81%E5%88%86%E7%BB%84%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%BC%8F">分组模式-CBC(Cipher Block Chaining mode 密码分组链接模式)</a><ul>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-cbc%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">分组模式-CBC加解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-cfbcipher-feedback-mode-%E5%AF%86%E6%96%87%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F">分组模式-CFB(Cipher FeedBack mode 密文反馈模式)</a><ul>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-cfb%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">分组模式-CFB加解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-ctrcounter-mode-%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F">分组模式-CTR(CounTeR mode 计数器模式)</a><ul>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-ctr%E8%AE%A1%E6%95%B0%E5%99%A8%E6%9E%84%E9%80%A0">分组模式-CTR计数器构造</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F-ctr%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">分组模式-CTR加解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95a">分组模式相关利用手法A</a><ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%91%E9%87%8Fiv%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90">初始化向量IV代码生成</a></li>
<li><a href="#iv%E5%A4%8D%E7%94%A8">IV复用</a></li>
<li><a href="#iv%E5%A4%8D%E7%94%A8%E4%BE%8B%E9%A2%98">IV复用例题</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95b">分组模式相关利用手法B</a><ul>
<li><a href="#ecb%E6%A8%A1%E5%BC%8F%E5%89%AA%E8%B4%B4">ECB模式剪贴</a></li>
<li><a href="#cbc%E6%A8%A1%E5%BC%8F%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC">CBC模式字节翻转</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95c">分组模式相关利用手法C</a><ul>
<li><a href="#pkcs7%E5%A1%AB%E5%85%85">PKCS7填充</a></li>
<li><a href="#padding-oracle">Padding Oracle</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81">非对称密码</a><ul>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa">公钥密码-RSA</a><ul>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90">公钥密码-RSA密钥生成</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E5%8A%A0%E8%A7%A3%E5%AF%86">公钥密码-RSA加解密</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E6%A8%A1%E6%95%B0%E5%88%86%E8%A7%A3">公钥密码-RSA模数分解</a><ul>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E6%A8%A1%E6%95%B0%E5%88%86%E8%A7%A3%E6%96%B9%E5%BC%8F%E4%B8%80%E7%9B%B4%E6%8E%A5%E5%88%86%E8%A7%A3">公钥密码-RSA模数分解方式一(直接分解)</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E6%A8%A1%E6%95%B0%E5%88%86%E8%A7%A3%E6%96%B9%E5%BC%8F%E4%BA%8Cpq%E7%9B%B8%E8%BF%91">公钥密码-RSA模数分解方式二(p,q相近)</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E6%A8%A1%E6%95%B0%E5%88%86%E8%A7%A3%E6%96%B9%E5%BC%8F%E4%B8%89%E6%A8%A1%E4%B8%8D%E4%BA%92%E7%B4%A0">公钥密码-RSA模数分解方式三(模不互素)</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E6%A8%A1%E6%95%B0%E5%88%86%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%9B%9B%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB">公钥密码-RSA模数分解方式四(共模攻击)</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa%E6%8C%87%E6%95%B0%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95">公钥密码-RSA指数利用方法</a><ul>
<li><a href="#%E5%B0%8F%E5%85%AC%E9%92%A5e%E6%8C%87%E6%95%B0%E5%88%A9%E7%94%A8">小公钥e指数利用</a></li>
<li><a href="#%E5%B7%B2%E7%9F%A5e%E5%92%8Cd%E5%88%86%E8%A7%A3n">已知e和d分解n</a></li>
<li><a href="#wiener%E5%88%A9%E7%94%A8">Wiener利用</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa-lsb%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95">公钥密码-RSA-LSB利用方法</a><ul>
<li><a href="#%E6%9C%80%E4%BD%8E%E4%BD%8D%E9%A2%84%E8%A8%80%E6%9C%BA%E6%94%BB%E5%87%BBlsb-oracle-attack">最低位预言机攻击(LSB Oracle Attack)</a></li>
<li><a href="#rsa%E7%9A%84%E7%A7%AF%E6%80%A7%E4%B9%98%E6%B3%95%E5%90%8C%E6%80%81">RSA的积性(乘法同态)</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa-lsb%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">公钥密码-RSA-LSB解密代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-rsa-coppersmith%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95">公钥密码-RSA-Coppersmith利用方法</a><ul>
<li><a href="#coppersmith%E5%AE%9A%E7%90%86">Coppersmith定理</a></li>
<li><a href="#%E5%B7%B2%E7%9F%A5m%E9%AB%98%E4%BD%8D">已知m高位</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-dh%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2">公钥密码-DH密钥交换</a><ul>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-dh%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">公钥密码-DH密钥交换前置知识</a><ul>
<li><a href="#%E7%BE%A4%E5%9F%BA%E7%A1%80%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89">群基础基础定义</a></li>
<li><a href="#%E7%BE%A4%E7%9A%84%E7%89%B9%E6%80%A7">群的特性</a></li>
<li><a href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%9A%BE%E9%A2%98">离散对数难题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-dh%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE">公钥密码-DH密钥交换协议</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-dh%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">公钥密码-DH密钥交换中间人攻击</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-elgamal%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">公钥密码-ElGamal加密算法</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-dsa%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95">公钥密码-DSA数字签名算法</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-sha1%E7%AE%97%E6%B3%95secure-hash-algorithm-1-%E5%AE%89%E5%85%A8%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%951">哈希函数-SHA1算法(Secure Hash Algorithm 1 安全散列算法1)</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB">哈希函数长度扩展攻击</a></li>
</ul>
</li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-rsa%E7%AD%BE%E5%90%8D">公钥密码-数字签名-RSA签名</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-elgamal%E7%AD%BE%E5%90%8D">公钥密码-数字签名-ElGamal签名</a><ul>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-elgamal%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B">公钥密码-数字签名-ElGamal签名过程</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-elgamal%E9%AA%8C%E7%AD%BE%E8%BF%87%E7%A8%8B">公钥密码-数字签名-ElGamal验签过程</a></li>
<li><a href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-elgamal%E7%AD%BE%E5%90%8Dk%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB">公钥密码-数字签名-ElGamal签名k重用攻击</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="古典密码">古典密码</span></h2><p>常见的古典密码在计算机时代大部分可以通过计算机的算法完成爆破类似的解密</p>
<h3><span id="单表替换密码">单表替换密码</span></h3><h4><span id="caesar-cipher-凯撒密码">Caesar Cipher 凯撒密码</span></h4><p>对于26个字母进行数字映射(a–&gt;0)，然后对于明文映射后加上同一个密钥n，得到密文<br>破解同理转化为数字映射然后同时减去n即可</p>
<p>加密函数：<br>$E_k(x) ≡ (x + k) \ mod \ 26$<br>解密函数：<br>$D_k(x) ≡ (x - k) \ mod \ 26$</p>
<h5><span id="凯撒加密代码实现">凯撒加密代码实现</span></h5><pre><code class="language-python">def caesar_encrypt(plaintext, shift):
    &quot;&quot;&quot;
    凯撒密码加密函数
    :param plaintext: 明文(需要加密的字符串)
    :param shift: 移位量(整数，可正可负，正表示向后移，负表示向前移)
    :return: 密文(加密后的字符串)
    &quot;&quot;&quot;
    ciphertext = &quot;&quot;  # 存储最终的密文
    for char in plaintext:  # 遍历明文中的每个字符
        # 处理小写字母(a-z)
        if char.islower():
            # 1. 字母转数字：a→0, b→1, ..., z→25(ord(&#39;a&#39;)=97，减去97得到0-25)
            char_num = ord(char) - ord(&#39;a&#39;)
            # 2. 移位运算：(原数字 + 移位量) %26(循环移位)
            encrypted_num = (char_num + shift) % 26
            # 3. 数字转字母：0→a, 1→b, ..., 25→z(加上97还原为小写字母的ASCII码)
            encrypted_char = chr(encrypted_num + ord(&#39;a&#39;))
            ciphertext += encrypted_char
        # 处理大写字母(A-Z)
        elif char.isupper():
            # 同理：A→0, B→1, ..., Z→25(ord(&#39;A&#39;)=65，减去65得到0-25)
            char_num = ord(char) - ord(&#39;A&#39;)
            encrypted_num = (char_num + shift) % 26
            encrypted_char = chr(encrypted_num + ord(&#39;A&#39;))
            ciphertext += encrypted_char
        # 非字母字符(数字、空格、符号等)直接保留
        else:
            ciphertext += char
    return ciphertext

if __name__ == &quot;__main__&quot;:
    # 自定义明文和移位量
    plaintext = &quot;Hello, Caesar Cipher! 123&quot;  # 包含大小写、符号、数字
    shift = 3  # 经典凯撒密码移位量(可修改为任意整数，如5、-2等)
    # 调用加密函数
    ciphertext = caesar_encrypt(plaintext, shift)
    # 输出结果
    print(f&quot;明文：{plaintext}&quot;)
    print(f&quot;移位量：{shift}&quot;)
    print(f&quot;密文：{ciphertext}&quot;)
</code></pre>
<h5><span id="凯撒解密代码实现">凯撒解密代码实现</span></h5><pre><code class="language-python">def caesar_decrypt(ciphertext, shift):
    &quot;&quot;&quot;凯撒密码解密函数(独立实现)&quot;&quot;&quot;
    plaintext = &quot;&quot;
    for char in ciphertext:
        # 处理小写字母
        if char.islower():
            char_num = ord(char) - ord(&#39;a&#39;)  # 密文字母转数字(a→0)
            decrypted_num = (char_num - shift) % 26  # 解密核心：减移位量
            decrypted_char = chr(decrypted_num + ord(&#39;a&#39;))
            plaintext += decrypted_char

        # 处理大写字母
        elif char.isupper():
            char_num = ord(char) - ord(&#39;A&#39;)
            decrypted_num = (char_num - shift) % 26
            decrypted_char = chr(decrypted_num + ord(&#39;A&#39;))
            plaintext += decrypted_char

        # 非字母字符直接保留
        else:
            plaintext += char
    return plaintext

------------------- 测试 -------------------
if __name__ == &quot;__main__&quot;:
    ciphertext = input(&quot;请输入需要解密的密文：&quot;)
    shift = int(input(&quot;请输入加密时的移位量(整数)：&quot;))
    decrypted_text = caesar_decrypt(ciphertext, shift)
    print(f&quot;解密后的明文：{decrypted_text}&quot;)
</code></pre>
<h4><span id="simple-substitution-cipher-简单替换密码">Simple Substitution Cipher 简单替换密码</span></h4><p>对于26个字母进行一一替换，一般情况下可以用字频攻击破解大部分，后续人工微调</p>
<h5><span id="字频攻击代码">字频攻击代码</span></h5><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

 #定义字母表和密文
alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;
cipher_text = &quot;wb wi kjb mk rmit bmiq bj rashmwk rmvp yjeryrkb mkd wbi iwokwxwvmkvrmkd&quot;

 #统计密文中每个字母的频率
count = np.zeros(len(alphabet))
for char in cipher_text:
    if char in alphabet:
        index = alphabet.index(char)
        count[index] += 1

 #计算频率并排序
total = sum(count)
frequency = count / total
sorted_indices = np.argsort(-frequency)
sorted_alphabet = &#39;&#39;.join([alphabet[i] for i in sorted_indices])

 #英文字母标准频率(从高到低)
english_frequency_order = &#39;etaoinshrdlcumwfgypbvkjxqz&#39;

 #初步替换密文字符
translation_table = str.maketrans(sorted_alphabet, english_frequency_order)
decoded_text = cipher_text.translate(translation_table)

print(&quot;初步解密结果：&quot;, decoded_text)
</code></pre>
<h4><span id="atbash-cipher-埃特巴什码">Atbash Cipher 埃特巴什码</span></h4><p>加密方式是将字母表前后倒转进行替换，可以一般难以判别，使用字频攻击破解</p>
<h4><span id="morse-cipher-摩斯密码">Morse Cipher 摩斯密码</span></h4><p>主要由点(.)，横杠(-)，字符间停顿(一般用空格space)，单词间停顿(一般用&#x2F;)构成</p>
<h4><span id="affine-cipher-仿射密码">Affine Cipher 仿射密码</span></h4><p>对于26个字母进行数字映射(a–&gt;0)，然后经过一个单射函数处理，再转回字母加密<br>加密函数：<br>$E(x) ≡ (ax + b) \ mod \ 26$<br>解密函数：<br>$D(x) ≡ a^{-1} (x - b) \ mod \ 26$</p>
<h3><span id="多表替换密码">多表替换密码</span></h3><h4><span id="维吉尼亚密码">维吉尼亚密码</span></h4><p>首先拿到明文长度，然后将密钥长度扩展到明文长度，然后转化为数字映射，进行一一对应相加得到密文<br>解密时首先要得到key的长度，然后尝试得到key的具体内容才可以解密</p>
<h5><span id="维吉尼亚解密代码实现不一定准确只可以大致参考">维吉尼亚解密代码实现(不一定准确只可以大致参考)</span></h5><pre><code class="language-python">&#39;&#39;&#39;维吉尼亚破解&#39;&#39;&#39;
import numpy as np
import wordninja

def alpha(cipher): #预处理,去掉空格以及回车
    c = &#39;&#39;
    for i in range(len(cipher)):
        if(cipher[i].isalpha()):
            c += cipher[i]
    return c

def count_IC(cipher): #给定字符串计算其重合指数
    count = [0 for i in range(26)]
    L = len(cipher)
    IC = 0.0
    for i in range(len(cipher)):
        if(cipher[i].isupper()):
            count[ord(cipher[i])-ord(&#39;A&#39;)] += 1
        elif(cipher[i].islower()):
            count[ord(cipher[i])-ord(&#39;a&#39;)] += 1
    for i in range(26):
        IC += (count[i]*(count[i]-1))/(L*(L-1))
    return IC

def count_key_len(cipher,key_len): #对字符串按输入个数进行分组，计算每一组的IC值返回平均值
    N = [&#39;&#39; for i in range(key_len)]
    IC = [0 for i in range(key_len)]
    for i in range(len(cipher)):
        m = i % key_len
        N[m] += cipher[i]
    for i in range(key_len):
        IC[i] = count_IC(N[i])
    #print(IC)
    print(&quot;长度为%d时,平均重合指数为%.5f&quot; % (key_len,np.mean(IC)))
    return np.mean(IC)

def length(cipher): #遍历确定最有可能的密钥长度返回密钥长度
    key_len = 0
    mins = 100
    aver = 0.0
    for i in range(1,21): #假设密钥长度在1-20之间
        k = count_key_len(cipher,i)
        if(abs(k-0.065)&lt; mins):
            mins = abs(k-0.065)
            key_len = i
            aver = k
    print(&quot;密钥长度为%d,此时重合指数每组的平均值为%.5f&quot; % (key_len,aver))
    return key_len

def count_MIC(c1,c2,n): #n=k1-k2为偏移量,计算c1,c2互重合指数MIC
    count_1 = [0 for i in range(26)]
    count_2 = [0 for i in range(26)]
    L_1 = len(c1)
    L_2 = len(c2)
    MIC = 0
    for i in range(L_1):
        if(c1[i].isupper()):
            count_1[ord(c1[i])-ord(&#39;A&#39;)] += 1
        elif(c1[i].islower()):
            count_1[ord(c1[i])-ord(&#39;a&#39;)] += 1
    for i in range(L_2):
        if(c2[i].isupper()):
            count_2[(ord(c2[i])-ord(&#39;A&#39;)+n+26)% 26] += 1
        elif(c2[i].islower()):
            count_2[(ord(c2[i])-ord(&#39;a&#39;)+n+26)% 26] += 1
    for i in range(26):
        MIC += count_1[i]*count_2[i]/(L_1*L_2)
    return MIC

def count_n(c1,c2): #确定两个子串最优的相对偏移量n=k1-k2
    n = 0
    mins = 100
    k = [0.0 for i in range(26)]
    for i in range(26):
        k[i] = count_MIC(c1,c2,i)
        #print(i,k[i])  
        if(abs(k[i]-0.065)&lt;mins):
            mins = abs(k[i]-0.065)
            n = i
    return n

def  group_k(cipher,key_len):#完成分组操作并计算每一组与第一组的最优相对偏移量并返回
    N = [&#39;&#39; for i in range(key_len)]
    MIC = [0 for i in range(key_len)]
    s = [0 for i in range(key_len)]
    for i in range(len(cipher)): #对密文进行分组
        m = i % key_len
        N[m] += cipher[i]
    for i in range(1,key_len):  #计算与第一组之间的相对偏移量
        s[i] = count_n(N[0],N[i])  # s[i] = k1-k(i+1)
        MIC[i] = count_MIC(N[0],N[i],s[i])  # MIC[i] = MIC(1,i+1)
        print(&quot;第1组和第%d组之间偏移为%d时，互重合指数为%.5f&quot; % (i+1,s[i],MIC[i]))
    return s

def miyao(key_len,s,k):  #k为第一个子串的移位，输出密钥并返回密钥所有字母的下标
    mi = [&#39;&#39; for i in range(key_len)]
    for i in range(key_len):
        s[i] = -s[i]+k   #k2=k1-n
        mi[i] = chr((s[i]+26) % 26 + ord(&#39;a&#39;))
    print(&quot;第一个偏移量为%d,密钥为%s时&quot; % (k,mi))
    return s

def the_end(cipher,key_len,s):#输入密文密钥返回明文结果
    plain =&#39;&#39;
    i = 0
    while( i &lt; len(cipher)):
        for j in range(key_len):
            if(cipher[i].isupper()):
                plain += chr((ord(cipher[i])-ord(&#39;A&#39;)-s[j]+26) % 26 + ord(&#39;A&#39;))
            else:
                plain += chr((ord(cipher[i])-ord(&#39;a&#39;)-s[j]+26) % 26 + ord(&#39;a&#39;))
            i+=1
            if(i == len(cipher)):
                break
    # print(plain)
    return plain

if __name__ == &quot;__main__&quot;:
    fp = open(&quot;&quot;,&quot;r&quot;) #在这里填入密文文件路径
    cipher = &#39;&#39;
    for i in fp.readlines():
        cipher = cipher + i
    fp.close()
    cipher = alpha(cipher)
    key_len = length(cipher)
    s = group_k(cipher,key_len)
    m = s.copy()
    for k in range(26):
        s = m.copy()
        s = miyao(key_len,s,k)
        plain = the_end(cipher,key_len,s)
        print(plain[0:20]) #输出部分明文确定偏移量k1
    print(&quot;参考输出，请输入第一个子串的偏移量:&quot;,end=&#39;&#39;)
    k = int(input())
    m = miyao(key_len,m,k)
    plain = the_end(cipher,key_len,m)

    &#39;&#39;&#39;对英文文本进行分词&#39;&#39;&#39;
    word = wordninja.split(plain)
    plain = &#39;&#39;
    for i in range(len(word)):
        plain += word[i]
        plain += &#39; &#39;
    print(&quot;明文为\n&quot;+plain)
</code></pre>
<h3><span id="其他类型密码">其他类型密码</span></h3><h4><span id="rail-fence-cipher-栅栏密码">Rail-Fence Cipher 栅栏密码</span></h4><p>将明文分n栏(分为n组)，然后明文按顺序依次进入各栏，形成类W的形状，最后进行各栏的拼接得到密文。<br>解密直接进行爆破即可</p>
<h4><span id="baconian-cipher-培根密码">Baconian Cipher 培根密码</span></h4><p>一种替换密码，每个明文字母由五个字符序列替换，一般使用AB，也可用其他</p>
<h5><span id="培根密码表">培根密码表</span></h5><p>A aaaaa B aaaab<br>C aaaba D aaabb<br>E aabaa F aabab<br>G aabba H aabbb<br>I abaaa J abaab<br>K ababa L ababb<br>M abbaa N abbab<br>O abbba P abbbb<br>Q baaaa R baaab<br>S baaba T baabb<br>U babaa V babab<br>W babba X babbb<br>Y bbaaa Z bbaab</p>
<h5><span id="栅栏加密代码实现">栅栏加密代码实现</span></h5><pre><code class="language-python">def fence_password_encode():
    # 获取用户输入(添加输入合法性校验)
    while True:
        plaintext = input(&#39;请输入需要加密的明文：&#39;).strip()
        if not plaintext:
            print(&quot;错误：明文不能为空，请重新输入！&quot;)
            continue
        break

    while True:
        try:
            fence_count = int(input(&#39;请输入栅栏数(密钥)：&#39;).strip())
            if fence_count &lt;= 0:
                print(&quot;错误：栅栏数必须是正整数，请重新输入！&quot;)
                continue
            break
        except ValueError:
            print(&quot;错误：请输入有效的整数作为栅栏数！&quot;)
    
    ciphertext = &quot;&quot;
    plaintext_len = len(plaintext)  # 提前计算长度，避免重复调用
    
    # 遍历每个栅栏(按栏索引循环)
    for fence_idx in range(fence_count):
        # 遍历当前栅栏的每个位置(步长为栅栏数)
        for char_idx in range(fence_idx, plaintext_len, fence_count):
            ciphertext += plaintext[char_idx]
    
    print(f&quot;\n加密完成！密文为：{ciphertext}&quot;)
    return ciphertext

if __name__ == &#39;__main__&#39;:
    fence_password_encode()
</code></pre>
<h5><span id="栅栏解密代码实现">栅栏解密代码实现</span></h5><pre><code class="language-python">import sys

def fence_password_brute_force():
    # 校验命令行参数
    if len(sys.argv) &lt; 2:
        print(&quot;-----------------------------------------------&quot;)
        print(&quot; &quot;)
        print(f&quot;Usage: python {sys.argv[0]} &lt;fence_encrypted_string&gt;&quot;)
        print(&quot;Example: python fence_Passwd_burst.py &#39;hloolelwrd&#39;&quot;)
        print(&quot; &quot;)
        print(&quot;说明：自动爆破2到密文长度-1之间的所有可能栅栏数&quot;)
        print(&quot;-----------------------------------------------&quot;)
        return

    # 获取密文并处理
    ciphertext = sys.argv[1].strip()
    ciphertext_len = len(ciphertext)

    # 校验密文有效性
    if ciphertext_len &lt; 2:
        print(&quot;错误：密文长度不能小于2，请输入有效的密文！&quot;)
        return

    # 生成所有可能的栅栏数(原逻辑：仅保留能整除密文长度的；补充：增加非整除情况，更全面)
    # 原逻辑保留：step 能整除密文长度(避免部分情况漏解)
    possible_steps = [
        step for step in range(2, ciphertext_len)
        if ciphertext_len % step == 0
    ]

    # 补充：添加不能整除的常见栅栏数(部分场景下栅栏数无需整除长度，原代码逻辑较局限)
    # 避免因密文长度非栅栏数倍数导致漏解，保留前N个常见值(平衡效率与全面性)
    additional_steps = [
        step for step in range(2, ciphertext_len)
        if ciphertext_len % step != 0
    ][:5]  # 最多补充5个，避免输出过多冗余
    possible_steps += additional_steps
    possible_steps = list(sorted(set(possible_steps)))  # 去重并排序

    # 无可能栅栏数的异常处理
    if not possible_steps:
        print(&quot;未找到可能的栅栏数，无法爆破！&quot;)
        return

    # 遍历所有可能的栅栏数进行解密
    print(f&quot;\n开始爆破(共{len(possible_steps)}种可能栅栏数)：&quot;)
    print(&quot;-&quot; * 50)
    for step in possible_steps:
        plaintext = &quot;&quot;
        # 按栅栏数拆分并重组(核心解密逻辑)
        for i in range(step):
            # 从索引i开始，步长为step，提取当前栅栏的所有字符
            plaintext += ciphertext[i::step]
        print(f&quot;栅栏数 {step:2d} | 解密结果：{plaintext}&quot;)
    print(&quot;-&quot; * 50)
    print(&quot;爆破完成！请根据语义判断正确结果～&quot;)

if __name__ == &#39;__main__&#39;:
    fence_password_brute_force()
</code></pre>
<h2><span id="现代密码">现代密码</span></h2><h3><span id="不同分类">不同分类</span></h3><h4><span id="按照密钥的特性进行分类">按照密钥的特性进行分类</span></h4><p>对称密码(AES，RC4)         速度快，密钥分发难<br>非对称密码(RSA，ECC)       密钥分发易，速度慢<br>混合密码(HTTPS)            结合两者优势，主流</p>
<h4><span id="按照功能分类">按照功能分类</span></h4><p>数据加密(AES，RSA)         保机密性<br>数字签名(ECDSA，EdDSA)     保完整+认证+不可否认<br>密钥交换(ECDH，TLS，ECDHE) 安全协商对称密钥<br>消息认证(HMAC，CMAC)       保完整+认证(无不可否认)</p>
<h4><span id="按照抗量子能力">按照抗量子能力</span></h4><p>传统密码(RSA，ECC)         抗经典，不抗量子<br>后量子密码(Kyber，Di)      抗量子，未来核心</p>
<h3><span id="对称密码">对称密码</span></h3><p>对称密码可以分为两大类：序列密码(流密码)和分组密码(块密码)<br>序列密码：生成与明文长度相同的密钥流(由密钥生成器产生)，逐位(或逐字节)加密，将明文与密钥流逐位异或<br>分组密码：将明文分成固定长度的组，每组独立加密，用同一密钥对每组明文加密，密钥长度固定</p>
<p>现代密码学设计密码算法一般遵循两个原则：<br>混淆：模糊明文和密文的关系，尝试用替换的方式实现<br>扩散：将明文中一位的影响扩散到多个密文，尝试用置换的方式实现<br>现代密码学中通常使用多轮运算，每一轮中会有若干层混淆变换和扩散变换</p>
<h4><span id="序列密码-rc4rivest-cipher-4-李维斯特密码4">序列密码-RC4(Rivest Cipher 4 李维斯特密码4)</span></h4><p>RC4 的核心分为两大阶段：S 盒初始化(KSA)和伪随机流生成(PRGA)</p>
<h5><span id="s盒初始化ksa">S盒初始化(KSA)</span></h5><p>首先S盒填充为0到255的连续字节<br>S[i] &#x3D; i<br>同时维护一个辅助数组k，将密钥key循环填充到k中<br>K[i] &#x3D; Key[i mod len(Key)]</p>
<pre><code class="language-python">j = 0
for i in range(256):
    j = (j + S[i] + K[i]) % 256
    # 计算交换索引j
    swap(S[i], S[j])
    # 交换S[i]和S[j]
</code></pre>
<h5><span id="伪随机流生成prga">伪随机流生成(PRGA)</span></h5><p>初始化索引：设两个初始索引i &#x3D; 0，j &#x3D; 0<br>逐字节生成密钥流：对每一个明文字节，执行：<br>i &#x3D; (i + 1) mod 256<br> #i递增1并取模256<br>j &#x3D; (j + S[i]) mod 256<br> #用S[i]更新j<br>swap(S[i], S[j])<br> #再次交换S盒元素，保证随机性<br>t &#x3D; (S[i] + S[j]) mod 256<br> #计算中间值t<br>Keystream_byte &#x3D; S[t]<br> #从S盒中取一个字节作为密钥流字节</p>
<p>将生成的Keystream_byte与明文（或密文）字节异或，得到密文（或明文）</p>
<h5><span id="序列密码-rc4加解密代码实现">序列密码-RC4加解密代码实现</span></h5><pre><code class="language-python">def rc4(key: bytes, data: bytes) -&gt; bytes:
    # 1. KSA：初始化S盒
    S = list(range(256))
    j = 0
    key_len = len(key)
    # 填充K数组并打乱S盒
    for i in range(256):
        j = (j + S[i] + key[i % key_len]) % 256
        S[i], S[j] = S[j], S[i]

    # 2. PRGA：生成密钥流并异或
    i = j = 0
    result = []
    for byte in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        t = (S[i] + S[j]) % 256
        keystream_byte = S[t]
        # 异或得到结果
        result.append(byte ^ keystream_byte)
    return bytes(result)

 #测试：加密和解密
key = b&quot;secret_key_123&quot;  # 密钥（ bytes类型）
plaintext = b&quot;Hello, RC4!&quot;  # 明文

ciphertext = rc4(key, plaintext)
decrypted_text = rc4(key, ciphertext)

print(&quot;密文（十六进制）:&quot;, ciphertext.hex())  # 输出密文（十六进制格式）
print(&quot;解密后明文:&quot;, decrypted_text.decode(&quot;utf-8&quot;))  # 输出：Hello, RC4!
</code></pre>
<h4><span id="序列密码-otpone-time-pad-一次一密">序列密码-OTP(One Time Pad 一次一密)</span></h4><p>将明文所有字符转化为八位二进制，然后随机生成和密文等长的密钥流，将明文和密钥流进行异或得到密文</p>
<h5><span id="otp加密代码实现">OTP加密代码实现</span></h5><pre><code class="language-python">import os

def otp_encrypt(plaintext: bytes, key: bytes) -&gt; bytes:
    &quot;&quot;&quot;
    使用一次一密(OTP)加密明文。
    :param plaintext: 明文数据(字节序列)
    :param key: 密钥(字节序列)
    :return: 密文(字节序列)
    &quot;&quot;&quot;
    if len(plaintext) != len(key):
        raise ValueError(&quot;密钥长度必须与明文长度相同&quot;)
    return bytes([p ^ k for p, k in zip(plaintext, key)])

def otp_decrypt(ciphertext: bytes, key: bytes) -&gt; bytes:
    &quot;&quot;&quot;
    使用一次一密(OTP)解密密文。
    :param ciphertext: 密文数据(字节序列)
    :param key: 密钥(字节序列)
    :return: 解密后的明文(字节序列)
    &quot;&quot;&quot;
    if len(ciphertext) != len(key):
        raise ValueError(&quot;密钥长度必须与密文长度相同&quot;)
    return bytes([c ^ k for c, k in zip(ciphertext, key)])

 #示例使用
plaintext = b&quot;Hello, OTP!&quot;
key = os.urandom(len(plaintext))  # 生成与明文等长的随机密钥

 #加密
ciphertext = otp_encrypt(plaintext, key)
print(&quot;密文:&quot;, ciphertext)

 #解密
decrypted_text = otp_decrypt(ciphertext, key)
print(&quot;解密后的明文:&quot;, decrypted_text)
</code></pre>
<h5><span id="otp解密方式一">OTP解密方式一</span></h5><p>得到完整的密钥流，不完整也无法进行解密</p>
<h5><span id="otp解密方式二可实现率极低">OTP解密方式二(可实现率极低)</span></h5><p>有多个加密后的密文(即同一个密钥流不断加密得到各阶段的密文)</p>
<h6><span id="解密原理一">解密原理一</span></h6><p>$c1 ⊕ c2 &#x3D; ( p1 ⊕ k) ⊕ ( p2 ⊕ k ) &#x3D; p1 ⊕ p2 ⊕ k ⊕ k &#x3D; p1 ⊕ p2$  (k的加密效果抵消)</p>
<h6><span id="解密原理二">解密原理二</span></h6><p>对于一个小写字母与space异或结果为大写字母，反之亦然</p>
<h6><span id="例题">例题</span></h6><pre><code class="language-python">c0=&quot;315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0&quot; c1=&quot;234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d&quot; c2=&quot;32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b&quot;
c3=&quot;32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197&quot; c4=&quot;3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade&quot; c5=&quot;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee71497&quot; c6=&quot;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148d&quot; c7=&quot;315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40ce0fff9e00fa1439f&quot; c8=&quot;271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a&quot; c9=&quot;466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138&quot;

#for each ciphertext
for current_index,ciphertext in enumerate (ciphers):

    counter = collections.Counter()
    # for each other ciphertext 
    for index,ciphertext2 in enumerate (ciphers):
        if current_index != index: # don&#39;t xor a ciphertext with itself
            for indexOfChar,char in enumerate(strxor(ciphertext.decode(&#39;hex&#39;),ciphertext2.decode(&#39;hex&#39;))): # XOR the two ciphertexts
                # if a chracter in the xored result is a alphabetic character, it means was probably a space character in one of the two plaintexts(we don&#39;t know which one)
                if char in string.printable and char.isalpha(): counter[indexOfChar] +=1
    knownSpaceIndexes = () 

    # loop through all positions where a space character was possible in the current_index ciphertext
    for ind,val in counter.items():
        # if a space character was found at least 7 times at this index out of the 9 possible XORS， then the space character was likely from the current_index ciphertext!
        if val &gt;=7: knownSpaceIndexes.append(ind)
        # print knownSpaceIndexes # Shows all the positions where we now know the key!

        # now xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!
        xor_with_spaces = strxor(ciphertext.decode(&#39;hex&#39;), &#39; &#39; * 150)
        for index in knownSpaceIndexes:
            # stoe the key&#39;s value at the correct position
            final_key[index] = xor_with_spaces[index].encode(&#39;hex&#39;)
            # record that we know the key at this position
            know_key_positions.add(index)
</code></pre>
<h4><span id="序列密码-lcglinear-congruential-generator-线性同余生成器">序列密码-LCG(Linear Congruential Generator 线性同余生成器)</span></h4><p>LCG生成伪随机数满足递推式： $X_{n+1} ≡ AX_n + B \ (mod \ M)$  其中A，B，M为常数且需要$X_0$作为种子<br>由此递推式生成伪随机数序列得到密钥流，再逐字节进行异或加密得到密文</p>
<h5><span id="解密前置知识">解密前置知识</span></h5><h6><span id="同余运算简单性质">同余运算简单性质</span></h6><p>$a \pm c ≡ b \pm c \ (mod \ m)$<br>$a \times c ≡ b \times c \ (mod \ m)$<br>$a ≡ b \ (mod \ m),b ≡ c \ (mod \ m) ➡ a ≡ c \ (mod \ m)$</p>
<h6><span id="逆相关运算">逆相关运算</span></h6><p>$a ÷ b ≡ c \ (mod \ m) ⬅➡ a \times b^{-1} ≡ c \ (mod \ m)$<br>$b \times b^{-1} ≡ 1 \ (mod \ m)$<br>注意：不是所有情况都存在逆，只有m与b互质是才存在逆</p>
<h5><span id="lcg解密方式一">LCG解密方式一</span></h5><p>在已知常数A，B，M的前提下，若能捕捉到LCG生成的一个输出，则可以恢复出状态，并通过递推式预测之后产生的所有随机数</p>
<p>$X_{n+1} ≡ A X_n + B \ (mod \ M)$ ➡ $X_n ≡ (X_{n+1} - B)A^{-1} \ (mod \ M)$</p>
<p>通过递推可以得到初始种子$X_0$以及后续所有组成密钥流</p>
<h5><span id="lcg解密方式二">LCG解密方式二</span></h5><p>在未知A，B，已知M的情况下，若能捕捉到LCG生成的连续两个输出，可以通过建立方程求解A，B得到递推公式</p>
<p>联立方程组：<br>$X_{n+1} ≡ A X_n + B \ (mod \ M)$<br>$X_{n+2} ≡ A X_{n+1} + B \ (mod \ M)$</p>
<p>解出A，B<br>$A ≡ ( X_{n+2} - X_{n+1} )( X_{n+1} - X_n )^{-1} \ (mod \ M)$<br>$B ≡ X_{n+1} - A X_n \ (mod \ M)$</p>
<p>后续递推密钥流即可</p>
<h5><span id="lcg例题">LCG例题</span></h5><h6><span id="lcg例题题目">LCG例题题目</span></h6><pre><code class="language-python">from hashlib import sha256
from Crypto.Util.number import *
import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
flag = b&#39;xxx&#39;
def step(x,y,p):
    return (5*y + 7)%p,(11*x + 13)%p

p = getPrime(64)
x,y = random.randint(0,p),random.randint(0,p)

key = sha256(str(x).encode() + str(y).encode()).digest()[:16]

cipher = AES.new(key, AES.MODE_ECB)
ct = cipher.encrypt(pad(flag,16))

ots = [x**2*y**2%p]
k = 10
for i in range(k):
    for j in range(10):
        x,y = step(x,y,p)
    ots.append(x**2*y**2%p)
print(&quot;ct =&quot;,ct.hex())
print(&quot;p =&quot;,p)
print(&quot;ots =&quot;,ots)

# ct = eedac212340c3113ebb6558e7af7dbfd19dff0c181739b530ca54e67fa043df95b5b75610684851ab1762d20b23e9144
# p = 13228731723182634049
# ots = [10200154875620369687, 2626668191649326298, 2105952975687620620, 8638496921433087800, 5115429832033867188, 9886601621590048254, 2775069525914511588, 9170921266976348023, 9949893827982171480, 7766938295111669653, 12353295988904502064]
</code></pre>
<h6><span id="lcg例题解题代码">LCG例题解题代码</span></h6><pre><code class="language-python">from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Util.number import inverse
import sympy as sp

p = 13228731723182634049
ots = [10200154875620369687, 2626668191649326298, 2105952975687620620,8638496921433087800, 5115429832033867188, 9886601621590048254,2775069525914511588, 9170921266976348023, 9949893827982171480,7766938295111669653, 12353295988904502064]
ct = bytes.fromhex(&quot;eedac212340c3113ebb6558e7af7dbfd19dff0c181739b530ca54e67fa043df95b5b75610684851ab1762d20b23e9144&quot;)

# 一步迭代的线性变换矩阵（含常数项）
# [x&#39;]   [0  5  7] [x]
# [y&#39;] = [11 0 13] [y]
# [1 ]   [0  0  1] [1]
M = [[0, 5, 7], [11, 0, 13], [0, 0, 1]]

def mat_mul(A, B, mod):
    return [[sum(A[i][k] * B[k][j] for k in range(3)) % mod for j in range(3)] for i in range(3)]

def mat_pow(M, e, mod):
    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    B = [row[:] for row in M]
    while e &gt; 0:
        if e &amp; 1:
            R = mat_mul(R, B, mod)
        B = mat_mul(B, B, mod)
        e //= 2
    return R

# 10 步合并成一次变换
M10 = mat_pow(M, 10, p)
(a1, b1, c1), (a2, b2, c2), _ = M10

def tonelli(n, p):
    if n == 0:
        return 0
    if pow(n, (p - 1) // 2, p) != 1:
        print(&quot;No square root exists&quot;)
        return None
    if p % 4 == 3:
        return pow(n, (p + 1) // 4, p)
    q = p - 1
    s = 0
    while q % 2 == 0:
        s += 1
        q //= 2
    z = 2
    while pow(z, (p - 1) // 2, p) != p - 1:
        z += 1
    c = pow(z, q, p)
    x = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    while t != 1:
        i = 1
        t2 = pow(t, 2, p)
        while t2 != 1:
            t2 = pow(t2, 2, p)
            i += 1
        b = pow(c, 1 &lt;&lt; (m - i - 1), p)
        x = (x * b) % p
        t = (t * b * b) % p
        c = (b * b) % p
        m = i
    return x

# 计算 ots[0] 和 ots[1] 的平方根
s0_root = tonelli(ots[0], p)
s1_root = tonelli(ots[1], p)

# 两个平方根分支
s0_candidates = {s0_root, (-s0_root) % p}
s1_candidates = {s1_root, (-s1_root) % p}

x = sp.Symbol(&#39;x&#39;)
solutions = []

# 由 s0, s1 构造四次方程，解出 x0
for s0 in s0_candidates:
    for s1 in s1_candidates:
        A1, B1, C1 = a1 % p, c1 % p, (b1 * s0) % p
        A2, B2, C2 = a2 % p, c2 % p, (b2 * s0) % p
        k4 = (A1 * A2) % p
        k3 = (A1 * B2 + A2 * B1) % p
        k2 = (A1 * C2 + A2 * C1 + B1 * B2 - s1) % p
        k1 = (B1 * C2 + B2 * C1) % p
        k0 = (C1 * C2) % p

        poly = sp.Poly(k4 * x**4 + k3 * x**3 + k2 * x**2 + k1 * x + k0, x, modulus=p)
        coeff, factors = sp.factor_list(poly, modulus=p)

        for f, _ in factors:
            if f.degree() == 1:
                a, b = f.all_coeffs()
                r = (-b * sp.invert(a, p)) % p
                solutions.append((s0, s1, int(r)))
            elif f.degree() == 2:
                a, b, c = f.all_coeffs()
                a, b, c = int(a), int(b), int(c)
                d = (b * b - 4 * a * c) % p
                r1 = tonelli(d, p)
                if r1 is not None:
                    inv2a = inverse(2 * a, p)
                    r = ((-b + r1) * inv2a) % p
                    solutions.append((s0, s1, int(r)))
                    r = ((-b - r1) * inv2a) % p
                    solutions.append((s0, s1, int(r)))


def step10(x, y):
    v = [x, y, 1]
    v2 = [
        (M10[i][0] * v[0] + M10[i][1] * v[1] + M10[i][2] * v[2]) % p
        for i in range(3)
    ]
    return int(v2[0]), int(v2[1])

# 验证所有候选并解密
valid = []
for s0, s1, x0 in solutions:
    if x0 % p == 0:
        continue
    y0 = (s0 * inverse(x0, p)) % p
    x, y = x0, y0
    ok = True
    if (x * x * y * y) % p != ots[0]:
        ok = False
    else:
        for idx in range(1, len(ots)):
            x, y = step10(x, y)
            if (x * x * y * y) % p != ots[idx]:
                ok = False
                break
    if ok:
        valid.append((x0, y0))

for x0, y0 in valid:
    key = sha256(str(x0).encode() + str(y0).encode()).digest()[:16]
    flag = AES.new(key, AES.MODE_ECB).decrypt(ct)
    try:
        print(unpad(flag, 16))
    except Exception:
        pass
</code></pre>
<h4><span id="序列密码-lfsrlinear-feedback-shift-register-线性反馈移位寄存器">序列密码-LFSR(Linear Feedback Shift Register 线性反馈移位寄存器)</span></h4><p>我们将LFSR中的寄存器个数称为LFSR的级数，一个n级的LFSR最多可存储 $2^n$ - 1 种状态<br>在n个寄存器中，依次有状态$S_1$，$S_2$,···，$S_n$，向右移位则$S_n$输出为密钥流的第一项<br>$S_1$空缺由线性反馈函数 $f(S_1, S_2, S_3, S_4)$ 的处理结果补上<br>以此类推不断进行得到密钥流 (一般情况下会有循环周期效果，周期数 k ≤ $2^n$ - 1)<br>由反馈函数决定循环周期</p>
<h5><span id="lfsr线性反馈函数">LFSR线性反馈函数</span></h5><p>函数由状态$s$以及推头$m$组成，构成函数<br>$f(s_{n+1}) &#x3D; (s_1 \times m_1)⊕(s_2 \times m_2)⊕···⊕(s_n \times m_n)$<br>推头可以简单理解为0和1组成，决定该位置状态是否参与函数的运算</p>
<h5><span id="lfsr解密方式一">LFSR解密方式一</span></h5><p>在已知 LFSR 反馈函数的前提下，如果已知连续 n 位明文和 n 位密文，则可以计算得出 n 位密钥，即为 LFSR 的一个状态<br>此时根据反馈函数，即可计算出 LFSR 的全部输出，即全部密钥密钥流，从而破解 LFSR</p>
<h5><span id="lfsr解密方式二">LFSR解密方式二</span></h5><p>在未知 LFSR 反馈函数前提下，若获取2n位的明文和密文，计算得出2n位的密钥$[k_1,k_2,···,k_{2n}]$<br>这2n位密钥中有LFSR的n+1种状态，分别为$[k_1,k_2,···,k_{n}]$，$[k_2,k_2,···,k_{n+1}]$，··· $[k_{n+1},k_{n+2},···,k_{2n}]$<br>这些状态之间存在着互相递推关系，例如$k_{n+1}$就是由$[k_1,k_2,···,k_{n}]$计算出来的<br>以此类推，$k_{n+i}$ 就是由 $[k_i,k_{i+1},···,k_{i+n-1}]$ 计算得出，从而得到n个线性方程，进行矩阵运算接口解出反馈函数</p>
<h4><span id="分组密码-desdata-encryption-standard-数据加密标准">分组密码-DES(Data Encryption Standard 数据加密标准)</span></h4><p>DES块长度为64位，密钥长度为64位(其中8位为校验位，实际有效56位)，明文64位分组加密得到64位密文<br>DES对明文进行16轮加密运算，每一轮都有一个相应的子密钥参与(子密钥由密钥扩展算法计算得出)<br>此外，开头和结尾分别有初始置换和最终置换的操作</p>
<h5><span id="des加密初始置换和最终置换">DES加密初始置换和最终置换</span></h5><p>就是简单根据置换表，把长度为64比特的block每一个位置进行变换</p>
<h6><span id="初始置换initial-permutation代码实现">初始置换(Initial Permutation)代码实现</span></h6><pre><code class="language-python">IP_table=
[
    58,50,42,34,26,18,10,2,
    60,52,44,36,28,20,12,4,
    62,54,46,38,30,22,14,6,
    64,56,48,40,32,24,16,8,
    57,49,41,33,25,17,9,1,
    59,51,43,35,27,19,11,3,
    61,53,45,37,29,21,13,5,
    63,55,47,39,31,23,15,7,
]

def IP(block):
    result=[]
    for i in range(len(IP_table)):
        result.append(block[IP_table[i]-1])
    return result

###### 最终置换(Final Permutation)代码实现

FP_table=
[
    40,8,48,16,56,24,64,32,
    39,7,47,15,55,23,63,31,
    38,6,46,14,54,22,62,30,
    37,5,45,13,53,21,61,29,
    36,4,44,12,52,20,60,28,
    35,3,43,11,51,19,59,27,
    34,2,42,10,50,18,58,26,
    33,1,41,9,49,17,57,25,
]

def FP(block):
    result = []
    for i in range(len(FP_table)):
        result.append(block[FP_table[i]-1])
    return result
</code></pre>
<h5><span id="des密钥扩展算法">DES密钥扩展算法</span></h5><p>通过PC-1置换去除64比特密钥中的校验位<br>将56比特的密钥分成28比特<br>连续16轮运算，每一轮分别先对左右两半循环移位，再经过PC-2置换生成一个48比特的子密钥<br>最终得到16组48比特的子密钥</p>
<h6><span id="des密钥扩展算法代码实现">DES密钥扩展算法代码实现</span></h6><pre><code class="language-python">subkey=[]
if len(bkey)== 64:
    #PC-1
    bkey = PC_1(bkey)
eliflen(bkey) = 56:
    raise ValueError(&quot;key must be 56-bit or 64-bit in length&quot;)
 #divide the block into two halves
Ci, Di = bkey[:28], bkey[28:]
for i in range(16):
    #Left Rotation
    Ci, Di = LR(Ci, Di, i)
    #PC-2
    subkey.append(PC_2(Ci + Di))
return subkey
</code></pre>
<h5><span id="des加密轮函数feistel-function-费斯妥函数">DES加密轮函数(Feistel Function 费斯妥函数)</span></h5><p>先通过Expansion将32比特输入扩展成48比特<br>再与48比特的子密钥混合作异或运算<br>然后48比特分别分为8组，每组6比特，经过S盒替换，输出8组4比特，即32比特<br>最后对这32比特依据一张固定的置换表进行移位置换P</p>
<h6><span id="des加密轮函数代码实现">DES加密轮函数代码实现</span></h6><pre><code class="language-python">def Feistel(HalfBlock, subkey):
    eHalfBlock = Expansion(HalfBlock)
    xHalfBlock = BlockXor(eHalfBlock, subkey)
    sHalfBlock = Substitution(xHalfBlock)
    return Permutation(sHalfBlock)
</code></pre>
<h5><span id="des加密过程">DES加密过程</span></h5><p>将分块后的明文(64位)先进行初始置换，再分为左右两块$L_0,R_0$(32位)<br>在每一轮中进行下列运算(总共进行16轮)：<br>$L_{i+1} &#x3D; R_i$<br>$R_{i+1} &#x3D; L_i ⊕ F(R_i,K_i)$ (F为轮函数)<br>将$R_{16},L_{16}$进行交换拼接，进行最后置换得到64位密文</p>
<h6><span id="des加密代码实现">DES加密代码实现</span></h6><pre><code class="language-python"> #Initial permutation
m = IP(m)
 #divide the block into two 32-bit halves
Li, Ri = m[:32], m[32:]
 #16 rounds
for i in range(16):
    Li, Ri = Ri, BlockXor(Li, Feistel(Ri, subkey[i]))
 #merge the two divided half block which is 32-bit into one 64-bit block
m = Ri + Li # There is a need to change order of the final two halves
 #Final permutation
m = FP(m)
</code></pre>
<h5><span id="des加解密代码实现">DES加解密代码实现</span></h5><pre><code class="language-python">from Crypto.Cipher import DES

key = &#39;&#39;
des = DES.new(key,DES.MODE_ECB)
plaintext = b&#39;&#39;

cipher = des.encrypt(plaintext)
des.decrypt(cipher)
</code></pre>
<h6><span id="des解密方式一">DES解密方式一</span></h6><p>在已知密文和16个子密钥的情况下，由于轮函数以及置换的可逆性，仅需要在轮函数作用时使用逆序的子密钥即可</p>
<h4><span id="分组密码-aesadvanced-encryption-standard-高级加密标准">分组密码-AES(Advanced Encryption Standard 高级加密标准)</span></h4><p>AES算法的块长度为128位，不同密钥长度分别有不同加密轮数<br>128位密钥对应10轮，192位密钥对应12轮，256位密钥对应14轮<br>AES每一轮直接对整个128位进行加密，使用算法层进行加密</p>
<h5><span id="aes算法层加密">AES算法层加密</span></h5><p>AES128位(16字节)首先按照从左向右，从上到下排成一个4\times4的矩阵<br>先对密钥k进行扩展得到子密钥用于密钥加法层处理，其中$k_0$先对明文进行密钥加法层处理，后续$k_n$进行第n轮密钥加法层处理<br>随后直到n-1轮都进行字节代换层➡扩散层(由Shift Rows层和Mix Column层构成)➡密钥加法层<br>最后一轮删去Mix Column层处理，其余不变，得到最后密文</p>
<h6><span id="aes加密算法框架代码实现">AES加密算法框架代码实现</span></h6><pre><code class="language-python">#start
r=0
k_sch=self.subkeys[0] + self.subkeys[1] + self.subkeys[2] + self.subkeys[3]

state = list(msg)
AES.add_round_key(state,k_sch)

 #round 1~rounds&#39;-1
for r in range(1,self.rounds):
    AES.sub_bytes(state)
    AES.shift_rows(state)
    AES.mix_columns(state)
    k_sch=self.subkeys[4*r] + self.subkeys[4*r+1] + self.subkeys[4*r+2] + self.subkeys[4*r+3]
    AES.add_round_key(state,k_sch)

 #the last round
r = self.rounds
AES.sub_bytes(state)
AES.shift_rows(state)
k_sch=self.subkeys[-4] + self.subkeys[-3] +self.siubkeys[-2] + self.subkeys[-1]
AES.add_round_key(state,k_sch)

 #convert &#39;list&#39;stateto&#39;bytes&#39;output
output=bytes(state)
return output

###### AES算法层-字节代换层

让输入的每一个字节，通过S盒代换(映射)到另外一个字节
此处的S盒是可以经过每种方式计算出来的，也可以直接使用计算好的进行代换

@staticmethod
def sub_bytes(s):
    for i in range(16):
        s[i] = AES.Sbox[s[i]]
</code></pre>
<h6><span id="aes算法层-扩散层">AES算法层-扩散层</span></h6><p>行移位层(Shift Rows层)<br>对于4\times4的矩阵，在做行移位时，第一行保持不变，第二行往左移动一格，第三行左移两格，第四行左移三格</p>
<p>行混淆层(Mix Column层)<br>将整个字节矩阵乘上一个列混淆矩阵(有限域上的矩阵运算)<br>相当于正常矩阵运算结果取模</p>
<pre><code class="language-python">@staticmethod
def shift_rows(s):
    s[i] = list(s[0::5] + s[4::5] + s[3:4:5] + s[8::5] + s[2:8:5] +s[12::5] + s[1:12:5])

@staticmethod
def mix_columns(s):
    def xtime(a):
        return((((a &lt;&lt; 1) ^ 0x1B) &amp; 0XFF) if (a &amp; 0x80) else (a &lt;&lt;1))

    for i in range(4):
        t=s[4*i] s[4*i+1] ^s[4*i+2]^s[4*i+3]
        u=s[4*i]
        s[4*i] ^=t xtime(s[4*i] ^ s[4*i+1])
        s[4*i+1] ^= t xtime(s[4*i+1] ^ s[4*i+2])
        s[4*i+2] ^= t xtime(s[4*i+2] ^ s[4*i+3])
        s[4*i+3] ~ t xtime(s[4*i+3] ^ u)
</code></pre>
<h6><span id="aes算法层-密钥加法层">AES算法层-密钥加法层</span></h6><p>输入16字节的明文和子密钥，对这两个输入逐字节异或，并将异或结果输出</p>
<pre><code class="language-python">@staticmethod
def add_round_key(s, k):
    for i in range(16):
        s[i] ^= k[i]
</code></pre>
<h6><span id="aes密钥扩展算法">AES密钥扩展算法</span></h6><p>以标准128位密钥，对应共有11组子密钥，反别在一开始盒每一轮(共十轮)中参与轮密钥加法层运算<br>子密钥的生成是以列为单位，一列4字节32比特构成一个字(word)，四个字拼接成一个子密钥</p>
<p>$k[0]$的生成<br>将密钥同样从左到右，从上到下排列为一个矩阵，第一列$k_1,k_2,k_3,k_4$为$w_0$<br>$w_0,w_1,w_2,w_3$拼接构成$k[0]$</p>
<p>$k[1],k[2]···k[n]$的生成<br>首先存在G函数接收$w_3$的结果，其输出与$w_0$进行异或得到$w_4$，然后$w_1$与$w_4$异或得到$w_5$<br>以此类推得到$w_4,w_5,w_6,w_7$拼接得到$k[1]$<br>$w_4,w_5,w_6,w_7$重复上述过程即可，以此类推拿到所有子密钥</p>
<p>G函数<br>将输入的w分成四块(每块1字节)$B_1,B_2,B_3,B_4$<br>将每个字节进行向循环左移一位<br>逐字节经过S盒进行代换<br>用第一个字节盒轮系数进行异或运算(实际上是四个字节整体与轮常量异或，但是常量后续三个字节都是0)</p>
<pre><code class="language-python">@staticmethod
defkey_expansion(k,r):
 #fips-197 Figure 11
    k = list(k) # in case k is bytes
    Nk = len(k) // 4
    subkeys=[k[i:i+4]foriinrange(0,4*Nk,4*Nk,4)]

    i = Nk
    while i &lt; 4*(r+1):
        t=subkeys[i-1]
    if i % Nk == 0:
        tt=AES.sub_word(AES.rot_word(t))
        t=[tt[0] ^AES.Rcon[i // Nk]] + tt[1:]
    elif Nk &gt; 6 and i % Nk == 4:
        t = AES.sub_word(t)
    subkeys.append(AES.word_xor(subkeys[i - Nk], t))
    i += 1
return subkeys
</code></pre>
<h5><span id="aes加解密代码实现">AES加解密代码实现</span></h5><pre><code class="language-python">from Crypto.Cipher import AES

key = b&quot;&quot;
aes = AES.new(key,mode=AES.MODE_ECB)
plaintext = b&quot;&quot;

ciphertext = aes.encrypt(plaintext)
aes.decrypt(ciphertext)

##### AES例题一

import time
import random
from Crypto.Cipher import AES
from Crypto.Util.number import *

random.seed(int(time.time())) #抽取当前时间的时间戳转化成int类型作为随机数生成的种子seed
key = long_to_bytes(random.getrandbits(128)) #用函数生成一个128位的整数并转化为字节形式得到一个16字节

aes=AES.new(key, mode=AES.MODE_ECB)
cipher= aes.encrypt(flag)
with open(&quot;cipher&quot;, &quot;wb&quot;) as f:
    f.write(cipher)
 #AES加密是难以爆破的，我们一般只可以取找key
 #由于random算法的固定，所以直接找到时间戳就可以拿到key
</code></pre>
<h4><span id="分组密码-分组模式">分组密码-分组模式</span></h4><p>分组密码算法只能加密固定长度的分组，当我们加密的明文长度超过块长度时，需要分组密码算法迭代以全部加密<br>而不同的分组密码算法分组就是分组密码的模式(mode)</p>
<p>常见的分组模式有如下几种:<br>ECB模式:Electronic Code Book mode(电子密码本模式)<br>CBC模式:Cipher Block Chaining mode(密码分组链接模式)<br>CFB模式:Cipher FeedBack mode(密文反馈模式)<br>OFB模式:Output FeedBack mode (输出反馈模式)<br>CTR模式:CounTeR mode (计数器模式)<br>GCM模式:Galois&#x2F;Counter Mode(伽罗瓦&#x2F;计数器模式)</p>
<p>分组密码迭代加密要求每一个明文分组都是块长度(8或16字节)<br>当分组到最后一组时，其长度不足块长度，就需要对其进行填充，将长度扩展为块长度</p>
<p>常见的填充方式有如下几种:<br>补零:在末尾补上0x00字节<br>… | DD DD DD DD DD DD DD DD DD DD DD DD 00 00 00 00 00 |<br>字节填充:先填充0x00字节,直至最后一字节填充值为填充长度<br>… | DD DD DD DD DD DD DD DD DD DD DD DD 00 00 00 00 04 |<br>PKCS7填充:若需填充N个字节,则每个填充字节值都是N<br>… | DD DD DD DD DD DD DD DD | DD DD DD 04 04 04 04 04 |</p>
<h5><span id="分组模式-ecbelectronic-code-book-mode-电子密码本模式">分组模式-ECB(Electronic Code Book mode 电子密码本模式)</span></h5><p>最简单的分组方式，直接将明文分成固定的块大小，每个块进行独立且相同的加密，明文和密文一一对应</p>
<h6><span id="分组模式-ecb加解密代码实现">分组模式-ECB加解密代码实现</span></h6><pre><code class="language-python">from Crypto.Cipher import AES

def aes_ecb_encrypt(pt, key):
    aes=AES.new(key, AES.MODE_ECB)
    ct = aes.encrypt(pt)
    return ct
def aes_ecb_decrypt(ct, key):
    aes=AES.new(key,AES.MODE_ECB)
    pt=aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式-cbccipher-block-chaining-mode-密码分组链接模式">分组模式-CBC(Cipher Block Chaining mode 密码分组链接模式)</span></h5><p>首先一样先对明文进行分块填充，然后使用初始化向量IV对第一个明文块进行异或操作，然后进行加密<br>第一个加密得到密文在与第二块明文进行异或，随后第二块去加密，以此类推</p>
<h6><span id="分组模式-cbc加解密代码实现">分组模式-CBC加解密代码实现</span></h6><pre><code class="language-python">def aes_cbc_encrypt(pt, key,iv):
    aes=AES.new(key,AES.MODE_CBC, iv=iv=iv=iv)
    ct = aes.encrypt(pt)
    return ct

def aes_cbc_decrypt(ct, key,iv):
    aes=AES.new(key,AES.MODE_CBC, iv=iv=iv=iv)
    pt = aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式-cfbcipher-feedback-mode-密文反馈模式">分组模式-CFB(Cipher FeedBack mode 密文反馈模式)</span></h5><p>首先一样先对明文进行分块填充，然后对IV进行加密得到中间结果，将这个结果与第一块明文进行异或得到第一块密文<br>第一块密文进行加密得到中间结果，中间结果再与第二块明文异或，得到第二块密文，以此类推</p>
<h6><span id="分组模式-cfb加解密代码实现">分组模式-CFB加解密代码实现</span></h6><pre><code class="language-python">def aes_cfb_encrypt(pt, key,iv):
    aes=AES.new(key,AES.MODE_CFB, iv=iv=iv=iv)
    ct = aes.encrypt(pt)
    return ct

def aes_cfb_decrypt(ct, key,iv):
    aes=AES.new(key,AES.MODE_CFB, iv=iv=iv=iv)
    pt = aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式-ctrcounter-mode-计数器模式">分组模式-CTR(CounTeR mode 计数器模式)</span></h5><p>首先一样先对明文进行分块填充，然后对一个逐次累加的计数器进行加密得到中间结果(密钥流的流密码)<br>将这个结果与块明文进行异或得到块密文</p>
<h6><span id="分组模式-ctr计数器构造">分组模式-CTR计数器构造</span></h6><p>CTR每一次解密时，都会生成一个nonce(仅用一次的数)来作为计数器的初始值<br>计数器格式：前面字节为固定的nonce，后面字节为分组序号，会逐次累加</p>
<h6><span id="分组模式-ctr加解密代码实现">分组模式-CTR加解密代码实现</span></h6><pre><code class="language-python">def aes_ctr_encrypt(pt,key, nonce):
    aes = AES.new(key, AES.MODE_CTR, nonce=nonce)
    ct = aes.encrypt(pt)
    return ct

def aes_ctr_decrypt(ct, key, nonce):
    aes = AES.new(key, AES.MODE_CTR, nonce=nonce)
    pt = aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式相关利用手法a">分组模式相关利用手法A</span></h5><p>初始化向量IV(initialization vector)是一个固定长度的输入值，一般会要求它是随机数或者拟随机数<br>ECB模式中，由于没有IV，导致密钥不变的情况下，相同的明文必然会加密生成相同的密文，会泄露明文部分信息</p>
<h6><span id="初始化向量iv代码生成">初始化向量IV代码生成</span></h6><pre><code class="language-python">#系统内置的密码学安全生成器
import os
iv = os.urandom(16)
</code></pre>
<h6><span id="iv复用">IV复用</span></h6><p>CTR模式中，IV&#x2F;nonce和计数器的组合是用于产生流密钥的关键<br>如果每一次加密的IV&#x2F;nonce都是一样的，导致生成的流密钥也是一样的<br>如果已知一段明密文，则可以通过明文和密文的异或恢复出密钥流，并用这个密钥流对其他密文解密，这就是IV复用</p>
<h6><span id="iv复用例题">IV复用例题</span></h6><pre><code class="language-python">import os
from Crypto.Cipher import AES

FLAG=b&quot;flag{test_flag_}&quot;
KEY=os.urandom(16)
NONCE = os.urandom(12)

def aes_ctr_encrypt(pt):
    aes = AES.new(KEY,AES.MODE_CTR, nonce=NONCE)
    ct=aes.encrypt(pt)
    return ct

def aes_ctr_decrypt(ct):
    aes = AES.new(KEY,AES.MODE_CTR, nonce=NONCE)
    pt=aes.decrypt(ct)
    return pt

print(f&quot;flag:{aes_ctr_encrypt(FLAG)}&quot;)
while True:
    user_input=bytes.fromhex(input(&quot;Input a hex string tto encrypt:&quot;))
    ct=aes_ctr_encrypt(user_input)
    print(f&quot;Your ciphertext:{ct}&quot;)
</code></pre>
<p>从题目中我们可以获取以下信息(其中$P_{flag}$和$K$均未知)<br>$P_{flag} ⊕ K &#x3D; C_{flag}$<br>我们可以任意选取一段明文$P_{user}$发送给服务端,并得到$C_{user}$满足<br>$P_{user}⊕ K &#x3D; C_{user}$<br>从中可以解出$K$<br>$K &#x3D; P_{user} ⊕ C_{user}$<br>从而可以求出$P_{flag}$<br>$P_{flag}&#x3D;K ⊕ C_{flag} &#x3D; P_{user} ⊕ C_{user} ⊕ C_{flag}$</p>
<h5><span id="分组模式相关利用手法b">分组模式相关利用手法B</span></h5><h6><span id="ecb模式剪贴">ECB模式剪贴</span></h6><p>某个网站的用户cookie如下:<br>coukte&#x3D;session:aa82ef0a;timedl&#x3D;1;admin&#x3D;0;guess_cookie_ma&#x3D;1;gueess_mp_ab&#x3D;1;guess_cookie_mb&#x3D;0;hell_pad&#x3D;233<br>采用128位的AES-ECB模式对cookie进行加密,所得的密文如下:<br>fa38dcf486e5098ad574c1cc5b06aa7dd6e125070668ffc10579d2dcb71a<br>3871a6ffd90507da87a355702ea8d329d01aced9355f1a946843e452f3299b<br>ae84ab736c4f6306a98cef4e0e294b4bd397d1aa696c56b5950fae5c7ce61f<br>e5fc2579<br>仅当”admin&#x3D;1”时,才能得到flag</p>
<p>由于ECB模式下密文和明文一一对应，所以可以进行特定的剪贴修改</p>
<pre><code class="language-python">plain = &quot;session:aa82ef0a;timedl=1;admin=0;guess_cookie_ma=1;gueess_mp_ab=1;guess_cookie_mb=0;hell_pad=233&quot;
for i in range(0,len(plain),16)
    print(i//16 + 1,plain[i:i+16])
</code></pre>
<p>输出结果：<br>1 session:aa82ef0a<br>2 ;timedl&#x3D;1;admin&#x3D;<br>3 0;guess_cookie_m<br>4 a&#x3D;1;guess_mp_ab&#x3D;<br>5 1;guess_cookie_m<br>6 b&#x3D;0;hell_pad&#x3D;233<br>可以看见第三行和第五行相似，第五行就是我们想要的第三行效果，进行剪贴</p>
<p>new_cipher &#x3D; <br>cipher_blocks[0] + <br>cipher_blocks[1] + <br>cipher_blocks[4] + \ 替换为第5组密文块<br>cipher_blocks[3] + <br>cipher_blocks[4] + <br>cipher_blocks[5]</p>
<h6><span id="cbc模式字节翻转">CBC模式字节翻转</span></h6><p>CBC模式的解密过程可以由如下关系式来表示(其中nb是块的数量):</p>
<p>$P_1&#x3D;Dec_k(C_1) ⊕ IV$<br>$P_i&#x3D;Dec_k(C_i) ⊕ C_{i-1}, 1&lt;i&lt;nb$</p>
<p>从中可以看出,若修改某个密文块$C_{i-1}$,<br>则会影响到解密出来的了不一个明文块$P_i$,即我们可以通过篡改密文来任意操纵明文</p>
<p>假设想要控制某个块的明文,可以通过修改前一块密文相应的字节来达到这个目的<br>若要修改第3个明文块第i个字节的数值,则可以对第2个密文块第i个字节异或上相应的数值<br>(但也会导致解密出来的第2块明文不可预测)</p>
<h5><span id="分组模式相关利用手法c">分组模式相关利用手法C</span></h5><h6><span id="pkcs7填充">PKCS7填充</span></h6><p>PKCS7是一种常用的填充方式,其具体的填充方式为:填充N个字节,且这N个填充字节的字节值均N</p>
<p>例如,当块大小为16时,对”aaaabbbcccc”进行填充<br>填充的结果为”aaaabbbcccc\x04\x04\x04\x04\x04”</p>
<p>注意:即使最后一个块的长度为16,PKCS7填充方式仍然会对其<br>进行填充,会在其后填充一块全为0x10的16字节块。</p>
<pre><code class="language-python">def pad(pt):
    pad_length = 16 - len(pt)%16
    pt += bytes([pad_length]) * pad_length
    return pt

def unpad(pt):
    pad_length = pt[-1]
    if not 1≤ pad_length ≤ 16:
        return None
    if pad(pt[:-pad_length]) != pt:
        return None
    return pt[:-pad_length]
</code></pre>
<h6><span id="padding-oracle">Padding Oracle</span></h6><p>服务端在进行AES-CBC解密的时候,会对解密的结果做解除填充(unpad)操作<br>如果解除填充时校验到填充格式不合法,则会直接报错,通常会返回对应的错误消息息”Padding Error!”</p>
<pre><code class="language-python">def decrypt(cipher):
    #AES-CBC解密
    decrypted_res = aes.decrypt(cipher)
    #解除填充
    plaintext = unpad(decrypted_res)
    if not plaintext:#填充格式错误,unpad函数返回None
        return &quot;Padding Error!&quot;
    #继续执行
    return &quot;OK&quot;
</code></pre>
<p>场景目标:对手获取到了一段密文,想要对其进行解密<br>利用思路:可以通过字节翻转的手法来修改解密后的明文,并将其发送给服务端<br>若修改后的明文符合填充格式,服务器返回OK,则对手可以从中获取到一些关于原始密文的一些信息</p>
<p>如何解密最后一个字节?<br>我们要利用……0x01这个合法的填充格式<br>假设g为最后一字节(共有256种可能性)<br>对上一个密文块的最后一字节异或上g^0x01<br>则解密后的最后一个明文块也会异或上g^0x01<br>若g正确,则最后一块格式为……0x01,服务器返回OK,否则服务器返回Padding Error</p>
<p>如何解密倒数第i个字节?<br>我们要利用……0x0i这个合法的填充格式<br>先通过已解出来倒数i-1个明文,通过字节翻转的方式将解密后的明文块后i-1修改为0x0i;<br>然后继续使用解密倒数第1个字节的方式,尝试256种可能的g,直至服务器返回OK,说明g即为倒数第i个字节</p>
<p>通过上述方法,可以解密出最后一个明文块的16个字节<br>解密完之后,即可将最后16字节的密文抛弃,继续对倒数第二块密文块进行解密<br>依此方法,可以对所有密文进行解密,恢复出整个明文信息</p>
<pre><code class="language-python">#padding_oracle recovers the last 16 plaintext bytesof the given ciphertext
def padding_oracle(cipher):
    plaintext=b&quot;&quot;
    for indexinrange(1,17):
        print f&quot;[*] index:{index}&quot;
        for byte in range(0,256):
            bytes_xor=b&quot;\x00&quot;*(16-index)+bytes [byte index]+xor plaintext,bytes([index]*(index-1))
            new_cipher = cipher[:-32] + xor cipher[-32:-16], bytes_xor + cipher -16:

            if oracle(new_cipher)== &quot;Padding Error!&quot;:
                print(f&quot;[{byte:&gt;3d}], Padding Error!&quot;)
            else:
                plaintext=bytes([byte])+plaintext
                print(f&quot;[{byte:&gt;3d}] OK&quot;)
                print(f&quot;plaintext:{plaintext}&quot;)
                break
return plaintext
</code></pre>
<h3><span id="非对称密码">非对称密码</span></h3><p>公钥密码一般都是基于一些数学难题设计的<br>如RSA算法就是基于大整数因数的分解问题<br>DH密钥交换算法是基于离散对数问题<br>ECC算法是基于椭圆曲线离散对数问题</p>
<h4><span id="公钥密码-rsa">公钥密码-RSA</span></h4><p>RSA算法的安全性取决于其底层的数学难题–大整数因数分解问题的难度<br>对于一些不安全&#x2F;位数比较小的素数,以当前的算法和算力很容容易将其分解<br>通常300bit以下的模数均可在较短时间内被分解,一些不安全的素数也会很快被特定算法所分解<br>RSA过程分为密钥生成、加密、解密三部分</p>
<h5><span id="公钥密码-rsa密钥生成">公钥密码-RSA密钥生成</span></h5><p>选两个大素数：随机选两个不同的大素数p和q<br>计算 n：n &#x3D; p \times q(n是公钥 &#x2F; 私钥的 “模数”，会公开)<br>计算欧拉函数 φ(n)：φ(n) &#x3D; (p-1) \times (q-1)(φ(n) 是小于 n 且与 n 互质的数的数量)<br>选公钥指数 e：选一个整数e，满足1 &lt; e &lt; φ(n)且e与φ(n)互质<br>算私钥指数 d：求d，满足(e \times d) mod φ(n) ≡ 1（即d是e在模φ(n)下的逆元<br>最终密钥：<br>公钥：(e, n)(公开给其他人)<br>私钥：(d, n)(自己保管，绝对保密)</p>
<h5><span id="公钥密码-rsa加解密">公钥密码-RSA加解密</span></h5><p>假设要加密的明文是M(需满足0 &lt; M &lt; n，若 M 太大则分段加密)<br>加密公式：密文C ≡ M ^ e (mod n)</p>
<p>用私钥解密密文C<br>解密公式：明文M ≡ C ^ d (mod n)</p>
<h5><span id="公钥密码-rsa模数分解">公钥密码-RSA模数分解</span></h5><h6><span id="公钥密码-rsa模数分解方式一直接分解">公钥密码-RSA模数分解方式一(直接分解)</span></h6><p>sagemath中直接使用函数 factor(n)即可</p>
<h6><span id="公钥密码-rsa模数分解方式二pq相近">公钥密码-RSA模数分解方式二(p,q相近)</span></h6><pre><code class="language-python">from Crypto.Util.number import getPrime, isPrime

def nextPrime(p):
    p = (p+2)|1
    while not isPrime(p):
        p += 2
    return p

def genkey(bits):
    p = getPrime(bits)
    q = nextPrime(p)
    e = 65537
    n = p*q
    return n

p = getPrime(512)
q = nextPrime(p)
</code></pre>
<p>一般来说，这样生成的两个p，q相差不过几百或者几千<br>有关系：$p^2&lt;n&lt;q^2$<br>则近似平方根必然落在pq之间且距离近，可以通过穷举的方式找到</p>
<h6><span id="公钥密码-rsa模数分解方式三模不互素">公钥密码-RSA模数分解方式三(模不互素)</span></h6><p>当两个模数共有一个素数时，有下面关系：<br>$n_1 &#x3D; p·q_1$<br>$n_2 &#x3D; p·q_2$<br>可以对两个模数求最大公约数gcd，这个数就是素因子p，从而分解两个模数</p>
<p>from Crypto.Util.number import GCD</p>
<p>p &#x3D; GCD(n1, n2)<br>q1 &#x3D; n1 &#x2F;&#x2F; p<br>q2 &#x3D; n2 &#x2F;&#x2F; p</p>
<h6><span id="公钥密码-rsa模数分解方式四共模攻击">公钥密码-RSA模数分解方式四(共模攻击)</span></h6><p>当n难以分解时，使用相同的模数、不同的私钥,加密同一明文消息时即存在”共模”，绕过分解n<br>$已知密文c_1,c_2，公钥e_1,e_2以及模数n$时<br>现在有下面关系：<br>$m ^ {e_1} ≡ c_1 \ (mod \ n)$<br>$m ^ {e_2} ≡ c_2 \ (mod \ n)$</p>
<p>扩展欧几里得算法计算：<br>$ax + by &#x3D; gcd(a,b)$</p>
<p>根据此算法计算出<br>$re_1 + se_2 &#x3D; 1$<br>从而有<br>$c_{1}^{r} c_{2}^{s} ≡ m^{re_1 + se_2} ≡ m^1 \ (mod \ n)$<br>使得右上角的指数变成1</p>
<pre><code class="language-python">from Crypto.Util.number import *
from math import gcd
import gmpy2 as gp

n = &#39;&#39;
e1 = &#39;&#39;
e2 = &#39;&#39;
c1 = &#39;&#39;
c2 = &#39;&#39;

g, r, s = gp.gcdext(e1,e2)
m = pow(m,r,n) * pow(m,s,n) % n
print(long_to_bytes(gp.iroot(m,g) [0]))
</code></pre>
<h5><span id="公钥密码-rsa指数利用方法">公钥密码-RSA指数利用方法</span></h5><h6><span id="小公钥e指数利用">小公钥e指数利用</span></h6><p>RSA通过模幂运算对明文加密,当指数逐渐增大时,模运算发挥作用将整数幂运算的结果截断至有限范围内<br>但是当指数太小时,模运算还未发挥作用,幂运算就已经结束<br>此时的加密结果并没有被截断,即是原本的幂运算,此时就不存在”加密”效果<br>$c ≡ m^e \ (mod \ n) ➡ c &#x3D; m^e$</p>
<p>当$m$较小时,即$m^e&lt;n$时,就会存在这种利用<br>另外,即使$m^e$稍比$n$大一点点,也可以通过穷举的方式对其尝试开根<br>$c ≡ m^e \ (mod \ n) ➡ c &#x3D; m^e - k·n$<br>可以从0开始穷举$k$,并对$k·n + c$尝试开$e$次方根,若可以开出来根,则说明成功解密<br>(对于正常的RSA加密,$k$一般很大,无法被穷举)</p>
<pre><code class="language-python">for k in range(0,100000000000):
    tmp=k*n+c
    root, ok = tmp.nth_root(e,truncate_mode=True)
    if ok:
        print(root)
        break
</code></pre>
<h6><span id="已知e和d分解n">已知e和d分解n</span></h6><p>RSA算法若能够知道加密指数e和解密指数d,则可以完成对n的的分解。<br>根据e和d的关系有<br>$e·d ≡ 1 \ (mod \ \phi(n))$<br>同样可以化为<br>$➡e·d &#x3D; 1 + k·\phi(n)$<br>其中$d &lt; \phi(n)$,因此必有$k&lt;e&#x3D;65537$,k可以穷举,从而可以得到中<br>$\phi(n)&#x3D;(p-1)·(q-1)$</p>
<p>得到$\phi(n)$后，根据n的表达式我们可以得到二元二次方程<br>$\phi(n)&#x3D;(p-1)·(q-1)$<br>$n &#x3D; p·q$<br>解出这个方程从而分解n</p>
<pre><code class="language-python">for k in range(1,e):
    if (e*d - 1) % k == 0: #k可以整除e·d-1
        phi=(e*d - 1) // k
        if pow(123,phi,n) == 1: #满足欧拉定理
            var(&#39;p q&#39;)
            print(solve([(p-1)*(q-1)== phi,p*q=n, p*q = n], [p,q]))
</code></pre>
<h6><span id="wiener利用">Wiener利用</span></h6><p>当d比较小($d&lt;\frac{1}{3}N^\frac{1}{4}$)时,可以使用Wiener利用来获取私钥d<br>特征:通常出题人为了要使得生成的私钥d比较小,通常会先生成一个比较小的d,<br>然后再去求e,从而使得e的取值范围位于(1,$\phi$)之间,会导致e看起来很大</p>
<p>从两条关系出发<br>$\phi(n) &#x3D; (p-1)·(q-1) &#x3D; n - (p + q) +1$<br>$e·d &#x3D; 1 + k·\phi(n)$<br>带入有<br>$e·d &#x3D; 1 + k·[ n - (p + q) +1]$<br>两边同时除以nd，得到<br>$\frac{e}{n} &#x3D; \frac{k}{d}(1 - \delta)$<br>式子左边均已知,右边均未知,右边和左边非常接近<br>这种情况可以使用连分数来将左边的比值展开,在连分数的展开式中,很大概率存在k和d<br>从而可以求出私钥d,进行解密</p>
<pre><code class="language-python">def recover(e, N):
    e = Integer(e)
    N = Integer(N)
    cf = continued_fraction(e / N).convergents()
    G.&lt;x&gt; = ZZ[&#39;x&#39;]

    for k_frac in cf[1:]:
        d0 = k_frac.denominator()
        k = k_frac.numerator()
        if k == 0 or d0 == 0:
            continue
        if (e * d0 - 1) % k != 0:
            continue
        phi = (e * d0 - 1) // k
        s = N - phi + 1
        f = x^2 - s*x + N
        discriminant = f.discriminant()
        if discriminant &lt;= 0 or not discriminant.is_square():
            continue
        roots = f.roots(multiplicities=False)
        roots = [Integer(root) for root in roots if root.is_integer()]
        if len(roots) == 2 and roots[0] * roots[1] == N:
            p, q = roots
            true_phi = (p - 1) * (q - 1)
            if (e * d0) % true_phi == 1:
                print(f&quot;[x] 恢复成功！&quot;)
                print(f&quot;d = {d0}&quot;)
                print(f&quot;d (十六进制) = {hex(d0)}&quot;)
                print(f&quot;p = {p}&quot;)
                print(f&quot;q = {q}&quot;)
                print(f&quot;phi(N) = {true_phi}&quot;)
                print(f&quot;验证：e*d mod phi(N) = {(e*d0) % true_phi}（应为1）&quot;)
                return d0  # 返回正确的d
    print(&quot;[-] 恢复失败&quot;)
    return None
</code></pre>
<h5><span id="公钥密码-rsa-lsb利用方法">公钥密码-RSA-LSB利用方法</span></h5><h6><span id="最低位预言机攻击lsb-oracle-attack">最低位预言机攻击(LSB Oracle Attack)</span></h6><p>假设现在有一个oracle(预言机),它会对一个给定的密文进行解密<br>但并不会直接返回解密结果,而是检验解密的明文的奇偶性<br>根据奇偶性返回相应的值,比如1表示奇数,0表示偶数,即最低位( LSB, least significant bit )<br>那么给定任意一个消息被加密后的密文,只需要$log_2(N)$次oracle询问,就可以解密出明文消息<br>(例如当N是1024位时,只需要大约1024次左右的oracle询问,就可以解密出明文)</p>
<pre><code class="language-python">cc = int(raw_input(&#39;Your encrypted message:&#39;).strip())
mm = k.decrypt(cc)
if mm &amp; 1 == 1:
    print &#39;The plain of your decrypted message is odd!&quot;
else:
    print &#39;The plain of your decrypted message is even!
</code></pre>
<h6><span id="rsa的积性乘法同态">RSA的积性(乘法同态)</span></h6><p>由RSA加密关系<br>$(P_1·P_2)^e &#x3D; P_{1}^e · P_{2}^e \ (mod \ n)$<br>可证明得到<br>$Enc(P_1,P_2) &#x3D; Enc(P_1) · Enc(P_2)$<br>利用这个性质，可以选择一个s，计算$c’ ≡ c·s^e \ (mod \ n)<br>将$c’$发送给服务器，服务器就会返回加密结果$m·s$的奇偶性<br>通过巧妙地继续选取s，就可以恢复出m</p>
<h6><span id="公钥密码-rsa-lsb解密代码实现">公钥密码-RSA-LSB解密代码实现</span></h6><pre><code class="language-python">L, H = 0, n
t = pow(2,e, e, n)
cc = c
for i in range(n.bit_length()):
    cc = (t * cc) % n
    if oracle(cc)== 0:
        H = (L + H) // 2
    else:
        L = (L + H) // 2
    print(L,H)
 #结果并不一定精确,需要再附近找一下正确的
for x in range(-1000,1000):
    if pow(x+m,e,n) == c:
        print(x+m)
</code></pre>
<h5><span id="公钥密码-rsa-coppersmith利用方法">公钥密码-RSA-Coppersmith利用方法</span></h5><h6><span id="coppersmith定理">Coppersmith定理</span></h6><p>假设N为一个未知分解情况的合数，并定义<br>$p(x) &#x3D; x^k + a_{k-1} x^{k-1} +···+ a_2 x^2 + a_1 x + a \ (mod \ N)$<br>为一个最高次数为k的整数系多项式</p>
<p>假设这个多项式存在一个根$x_0$，即<br>$p(x_0) &#x3D; 0 \ (mod \ N)$ 且满足$|x_0| &lt; N^\frac{1}{k}$<br>Coppersmith给出了一个算法可以很快求出这个小根</p>
<p>Coppersmith定理<br>令$p(x)$为一个最高次位数为k的首一多项式，N为一个未知分解情况的正合数,$\epsilon&gt;0$为一个极小的量<br>那么在多项式时间(算法复杂度较低)内,我们可以找到$p(x)$的整数解$x_0$,满足<br>$|x_0| &lt; \frac{1}{2}N^{(\frac{1}{k}-\epsilon)}$<br>(证明过于复杂,涉及到格构造、LLL算法等知识点)</p>
<h6><span id="已知m高位">已知m高位</span></h6><p>题目场景:假设模数n为1024bit,e&#x3D;3,现在已知m的高位m0,<br>只有低72位未知,未知量符合小根的条件(小于341bit)<br>设未知量为x,构造如下modn的多项式:<br>$f&#x3D; (m_0 + x)^3 - c \ (mod \ n)$<br>使用Coppersmith定理即可求解出x</p>
<pre><code class="language-python">K = Zmod(n)
P.&lt;x&gt; = PolynomialRing(K)

f = (m0 + x)^e - c
f.small_roots()
</code></pre>
<h4><span id="公钥密码-dh密钥交换">公钥密码-DH密钥交换</span></h4><h5><span id="公钥密码-dh密钥交换前置知识">公钥密码-DH密钥交换前置知识</span></h5><h6><span id="群基础基础定义">群基础基础定义</span></h6><p>集合简单来讲就是把一堆东西(元素)放在一起<br>群是一个集合,并且在这个集合上定义了一个运算(比如加法、乘法)<br>简而言之群，就是集合+运算</p>
<p>简单来说，群的作用就是描述对称性<br>系统从一个状态通过某种运算变换到另一个状态<br>如果这两个状态等价，则说系统对这一变换时对称的</p>
<p>群通过数学化的方式定义对称性<br>群只关心对称最本质，最抽象的性质，所以只关心操作，将操作放到集合里面</p>
<p>举例对一个正方体进行操作，有操作{保持不变，旋转90°，旋转180°，旋转270°}</p>
<p>类比加法<br>保持不变 ➡ 0<br>旋转90° ➡ r<br>旋转180° ➡ 2r<br>旋转270° ➡ 3r</p>
<p>类比乘法<br>保持不变 ➡ 0<br>旋转90° ➡ r<br>旋转180° ➡ r^2<br>旋转270° ➡ r^3</p>
<p>这里的加法乘法都是模运算，每四次运算就是一个周期<br>3r + r &#x3D; 0 (mod 4)<br>r^3 · r &#x3D; 0 (mod 4)<br>这样我们就得到了两个群<br>$(G,+) &#x3D; ({0,r,2r,3r},+)$<br>$(G,\times) &#x3D; ({0,r,r^2,r^3},\times)$</p>
<p>所以群就是一个集合G，加上一个运算“·”，满足以下四个条件:<br>封闭性：$对于所有a,b∈G，有a·b∈G$<br>结合性：$对于所有a,b,c∈G，有(a·b)·c&#x3D;a·(b·c)$<br>单位元：$存在一个e∈G，使得对于所有a∈G，有e·a&#x3D;a·e&#x3D;a$<br>逆元：$对于每个a∈G，存在一个b∈G，使得a·b&#x3D;b·a&#x3D;e，即b就是a的逆元，记作a^{-1}$</p>
<p>以$(G,+) &#x3D; ({0,r,2r,3r},+)$为例：<br>集合元素：所有保证对称的操作{0,r,2r,3r}<br>二元运算：加法“+”<br>封闭性：旋转组合的结果还是在集合里面<br>结合性：旋转的顺序不影响最终结果<br>单位元：保持不变0<br>逆元：每个操作都有一个对应的逆操作，比如r的逆操作是3r</p>
<p>模p乘法运算也可以组成一个群，定义为：<br>$(Z_p^*, \times) &#x3D; ({1,2,3,···，p-1}, \times)$<br>集合元素：所有小于p的正整数<br>二元运算：模p乘法<br>封闭性：两个小于p的数相乘模p结果还是小于p的数<br>结合性：乘法满足结合律<br>单位元：1<br>逆元：根据扩展欧几里得定理，对于每一个元素a，都存在整数x和y<br>使得$ax + py &#x3D; 1$，则x就是a的逆元</p>
<h6><span id="群的特性">群的特性</span></h6><p>群的阶数：群中所有元素的个数，记作|G|<br>元素的阶数：对于群G中的元素a，存在最小的正整数k，使$a^k &#x3D; e$，则称k为a的阶数，记作ord(a)</p>
<p>有些元素的阶数等于群的阶数，这样的元素称为生成元或者原根，一般记作g</p>
<p>对于乘法群$(Z_p^<em>, \times)$，其阶数为p-1<br>通过g的幂次运算，可以生成群中的所有元素<br>例如$(Z_{11}^</em>, \times)$的原根g&#x3D;2来说</p>
<table>
<thead>
<tr>
<th>(i)</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>(a^i)</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>5</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td>3</td>
<td>6</td>
<td>1</td>
</tr>
</tbody></table>
<p>对于加法群$(Z_n, +)$来说，生成元是所有和n互素的数<br>例如$(Z_{10}, +)$的生成元g&#x3D;3来说</p>
<table>
<thead>
<tr>
<th>(i)</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>(a^i)</td>
<td>0</td>
<td>3</td>
<td>6</td>
<td>9</td>
<td>2</td>
<td>5</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>7</td>
</tr>
</tbody></table>
<h6><span id="离散对数难题">离散对数难题</span></h6><p>在群$(Z_p^*, \times)$中，若有一个原根g，很容易算出所有元素<br>$a ≡ g^k \ (mod \ p)$<br>但是反过来，已知a和g，要算出k就非常困难<br>$k &#x3D; log_g a \ (mod \ p)$<br>这就是离散对数难题(DLP, Discrete Logarithm Problem)</p>
<p>在密码学的实际应用中，一般会选择大素数p(至少2048bit)和对应的原根g<br>现有的最好的通用型解决离散对数问题的算法，其算法的时间复杂度也非常高<br>Baby Step Giant Step算法的时间复杂度为$O(\sqrt{p})$<br>Pollard’s Rho算法的时间复杂度为$O(\sqrt{p}·log(p))$<br>Pohlig-Hellman算法的时间复杂度为$O(\sum_{i&#x3D;1}^{k} e_i (log p + \sqrt{p_i}))$<br>(其中$p_i^{e_i}$为p的质因数分解)<br>Index Calculus算法的时间复杂度为$L_p[1&#x2F;2, c] &#x3D; exp(c (log p)^{1&#x2F;2} (log log p)^{1&#x2F;2})$</p>
<p>SageMath中可以直接使用discrete_log函数来计算离散对数<br>默认调用Baby Step Giant Step算法和Pollard’s Rho算法<br>在数据量比较小的时候可以快速解决(100bit以下)</p>
<pre><code class="language-python">g = Mod(2, 37)
discrete_log(Mod(15, 37), g)
</code></pre>
<h5><span id="公钥密码-dh密钥交换协议">公钥密码-DH密钥交换协议</span></h5><p>首先通信双方先共享两个公共参数，模数p和生成元g<br>Alice本地随机生成一个私钥a，并计算$A ≡ g^a \ (mod \ p)$，将A发送给Bob<br>Bob收到A后，本地随机生成一个私钥b，并计算$B ≡ g^b \ (mod \ p)$，将B发送给Alice<br>同时Bob计算共享密钥$K ≡ A^b ≡ g^{ab} \ (mod \ p)$<br>Alice计算共享密钥$K ≡ B^a ≡ g^{ab} \ (mod \ p)$<br>最终Alice和Bob都得到了相同的共享密钥K<br>以这个key作为对称加密算法的密钥，进行后续的通信加密</p>
<h5><span id="公钥密码-dh密钥交换中间人攻击">公钥密码-DH密钥交换中间人攻击</span></h5><p>假设有一个攻击者Eve,她可以监听Alice和Bob之间的通信<br>当Alice发送A给Bob时,Eve截获了A,并生成自己的私钥c,计算$E ≡ g^c \ (mod \ p)$,将E发送给Bob<br>当Bob发送B给Alice时,Eve截获了B,并将E发送给Alice<br>此时Alice计算共享密钥$K_{AE} ≡ E^a ≡ g^{ac} \ (mod \ p)$<br>Eve计算共享密钥$K_{AE} ≡ A^c ≡ g^{ac} \ (mod \ p)$<br>Bob计算共享密钥$K_{BE} ≡ E^b ≡ g^{bc} \ (mod \ p)$<br>Eve计算共享密钥$K_{BE} ≡ B^c ≡ g^{bc} \ (mod \ p)$<br>最终Eve成功地和Alice、Bob分别建立了两个共享密钥，可以伪装进行通信<br>拿到双方的通信原始数据</p>
<h4><span id="公钥密码-elgamal加密算法">公钥密码-ElGamal加密算法</span></h4><p>ElGamal加密算法基于离散对数难题设计<br>首先通信双方先共享两个公共参数，模数p和生成元g<br>Alice本地随机生成一个私钥x，并计算$y ≡ g^x \ (mod \ p)$，将y作为公钥发送给Bob<br>Bob收到y后，选择一个随机数k(1 &lt; k &lt; p-2且k与p-1互素)<br>Bob计算临时公钥$C_1 ≡ g^k \ (mod \ p)$<br>Bob计算共享密钥$K ≡ y^k ≡ g^{xk} \ (mod \ p)$<br>对m进行处理使得$m &lt; p$(如果m过大，可以分段加密)<br>Bob使用共享密钥K对消息m进行加密，计算$C_2 ≡ m·K \ (mod \ p)$<br>Bob将密文对$(C_1, C_2)$发送给Alice<br>Alice收到密文对$(C_1, C_2)$后，计算共享密钥$K ≡ C_1^x ≡ g^{kx} \ (mod \ p)$<br>Alice使用共享密钥K对$C_2$进行解密，计算$m ≡ C_2 · K^{-1} \ (mod \ p)$</p>
<p>加密侧（B）：$K &#x3D; y_A^k &#x3D; (g^x)^k &#x3D; g^{xk}$  → $C_2 &#x3D; M \times K \mod p$<br>解密侧（A）：$K &#x3D; C_1^x &#x3D; (g^k)^x &#x3D; g^{xk}$  → $M &#x3D; C_2 \times K^{-1} \mod p$</p>
<h4><span id="公钥密码-dsa数字签名算法">公钥密码-DSA数字签名算法</span></h4><p>数字签名用于验证消息的完整性和真实性<br>数字签名一般是基于非对称密码加密算法实现的，非对称算法的解密运算即为签名，加密运算即位验签<br>假设Bob想要对一份文档m进行签名，Bob会使用他的私钥对文档进行签名运算，并得到签名sig<br>随后Bob将文档m和签名sig发送给Alice，Alice使用Bob的公钥对签名sig进行验签运算</p>
<p>数字签名的要点：<br>签名的消息m不一定要加密，可以明文的形式传输<br>只有签名者有私钥，能够对消息进行签名，任何其他人没有私钥无法签名<br>任何人都可以使用签名者的公钥对签名进行验证<br>消息完整性：如果消息在传输过程中被篡改，验签会失败<br>不可抵赖性：因为只有Bob有私钥，只有他能生成有效签名，所以Bob不能否认他签署过该消息</p>
<h5><span id="哈希函数">哈希函数</span></h5><p>在数字签名中，一般不会直接对消息m进行签名<br>而是先对消息m进行哈希运算，得到消息摘要H(m)<br>然后对消息摘要H(m)进行签名</p>
<p>哈希函数能够将任意长度的输入映射为固定长度的输出值(散列值或摘要)<br>特征：<br>接受任意长度输入：SHA1最高可接受2^64-1位的输入<br>固定长度输出：SHA1输出160位(20字节)的摘要<br>高效性：哈希函数计算时间短<br>单向性：已知哈希函数的输出$y &#x3D; H(m)$，很难反推出输入m<br>抗碰撞性：很难找到两个不同的输入m1和m2，使得$H(m1) &#x3D; H(m2)$<br>雪崩效应：输入的微小变化会导致输出的显著变化</p>
<p>常见的哈希函数：<br>MD2：输出128位摘要，设计用于8位处理器<br>MD5：输出128位摘要，已被证明存在碰撞漏洞，不推荐用于安全<br>SHA1：输出160位摘要，已被证明存在碰撞漏洞，不推荐用于安全<br>SHA256：输出256位摘要，当前被广泛使用，安全性较高<br>SHA512：输出512位摘要，安全性更高，但计算速度较慢<br>CRC32：输出32位摘要，主要用于数据完整性校验，不适合安全应用<br>Tiger：输出192位摘要，设计用于高安全性应用<br>Adler32：输出32位摘要，速度快，适用于数据完整性校验<br>RipeMD160：输出160位摘要，设计用于数字签名和加密应用</p>
<p>哈希函数除了数字签名，还有很多其他用途：<br>散列表：方便数据的查询，搜索，可以达到O(1)的时间复杂度<br>错误矫正：可以通过检查散列值，判断传输的信息是否在中途被篡改<br>区块链：可被用作工作量证明，使用散列值来链接区块</p>
<h6><span id="哈希函数-sha1算法secure-hash-algorithm-1-安全散列算法1">哈希函数-SHA1算法(Secure Hash Algorithm 1 安全散列算法1)</span></h6><p>SHA1算法的输入是几乎任意长度的消息(最大2^64bit)，输出是160位(20字节)的消息摘要<br>SHA1算法采用Merkle-Damgård结构，分块处理输入消息，每块512位(64字节)<br>SHA1算法的主要步骤：<br>填充消息：在消息末尾添加一个’1’位，然后添加足够的’0’位，使消息长度对512取模后等于448<br>添加长度：在消息末尾添加一个64位的整数l，l表示原始消息的长度<br>初始化哈希值：使用五个32位的常数IV作为初始哈希值<br>处理消息块：压缩函数将消息处理<br>输出摘要：将最终的哈希值连接起来，得到160位的消息摘要</p>
<p>压缩函数：<br>初始化链接状态为固定的初始值IV<br>将512位消息块扩散为80个字<br>每20个字会经过一个20轮的运算，每一轮都会更新链接状态<br>80轮运算后，链接状态经过变换输出，作为下一次压缩函数的输入</p>
<h6><span id="哈希函数长度扩展攻击">哈希函数长度扩展攻击</span></h6><p>在某些登录场景中，服务器会通过哈希函数来进行全校认证<br>合法用户应当知道$secret的具体值，从而可以计算出正确的散列值以此校验登录</p>
<pre><code class="language-php">&lt;?php
include &quot;secret.php&quot;; // secret.php中定义了$secret变量
@$username = (string)$_POST[&#39;username&#39;];
function enc($text){
    global $secret;
    return md5($secret . $text);
}
if(enc($username) === $_COOKIE[&#39;verify&#39;]){
    if(is_numeric(strpos($username, &quot;admin&quot;))){
        echo ($flag);
    } else {
        die(&quot;you are not admin!&quot;);
    }
}
else{kie(&quot;verify&quot;, enc($guest), time() + 60*60*24*7);
}
?&gt;
</code></pre>
<p>哈希长度扩展利用：当已知Hash(m)，但未知m，能够计算Hash(secret || m || padding || m’)<br>当我们初次登陆时，服务器会设置cookie为Hash(secret || “guest”)，并将摘要以cookie的形式发送给客户端<br>借助哈希长度扩展攻击，我们可以计算出Hash(secret || “guest” || padding || “admin”)<br>设置username为”guest” || padding || “admin”，其中带有admin字样，就可以登陆拿flag</p>
<h5><span id="公钥密码-数字签名-rsa签名">公钥密码-数字签名-RSA签名</span></h5><p>RSA加密算法不仅可以对数据进行加密，也可以用来数字签名<br>不同的是，签名使用私钥进行“加密”，验签使用公钥进行“解密”</p>
<h5><span id="公钥密码-数字签名-elgamal签名">公钥密码-数字签名-ElGamal签名</span></h5><p>p：一个大素数<br>g：p的一个原根(生成元)<br>x：签名者的私钥，随机选择，1 &lt; x &lt; p-2<br>y：签名者的公钥，计算$y ≡ g^x \ (mod \ p)$得到</p>
<h6><span id="公钥密码-数字签名-elgamal签名过程">公钥密码-数字签名-ElGamal签名过程</span></h6><p>随机生成一个整数k，满足1 &lt; k &lt; p-2且k与p-1互素<br>计算$r ≡ g^k \ (mod \ p)$<br>计算$s ≡ (H(m) - x*r) k^{-1} \ (mod \ p-1)$<br>签名结果为签名对$(r, s)$</p>
<h6><span id="公钥密码-数字签名-elgamal验签过程">公钥密码-数字签名-ElGamal验签过程</span></h6><p>计算$v &#x3D; y^r \times r^s \ (mod \ p)$<br>计算解密后的消息相关量$H(m)$<br>如果$v ≡ g^{H(m)} \ (mod \ p)$，则验签通过，否则验签失败</p>
<p>$v &#x3D; y^r * r^s (mod \ p)$<br>$  &#x3D; (g^x)^r * (g^k)^s (mod \ p)$<br>$  &#x3D; g^{xr} * g^{ks} (mod \ p)$<br>$  &#x3D; g^{xr + ks} (mod \ p)$<br>$  &#x3D; g^{H(m)} (mod \ p)$  # 根据签名计算公式可知$xr + ks ≡ H(m) \ mod \ (p)$</p>
<h6><span id="公钥密码-数字签名-elgamal签名k重用攻击">公钥密码-数字签名-ElGamal签名k重用攻击</span></h6><p>假设签名者在对两个不同的消息$H(m_1)$和$H(m_2)$进行签名时，不小心重用了同一个随机数k<br>得到签名对$(r, s_1)$和$(r, s_2)$<br>根据签名公式，有下面两条关系：<br>$s_1 ≡ (H(m_1) - x<em>r) k^{-1} \ (mod \ p-1)$<br>$s_2 ≡ (H(m_2) - x</em>r) k^{-1} \ (mod \ p-1)$<br>将上面两条关系式相减，得到：<br>$k ≡ (H(m_1) - H(m_2))(s_1 - s_2)^{-1} \ (mod \ p-1)$<br>恢复出k后，带入任意一条关系式，即可求出私钥x：<br>$x ≡ (H(m_1) - s_1*k) r^{-1} \ (mod \ p-1)$</p>
<pre><code class="language-python">from Crypto.Util.number import inverse

(p,g) = ( , )
(m1,r1,s1) = ( , , )
(m2,r2,s2) = ( , , )

k = (m1 - m2) * inverse(s1 - s2, p-1) % (p-1)
x = (m1 - s1 * k) * inverse(r1, p-1) % (p-1)
print(f&quot;私钥x: {x}&quot;)
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2026 密码学の小屋
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Dorange
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/myblog.github.io/js/main.js"></script>
    
    




    
</body>
</html>
