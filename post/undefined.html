<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>密码学笔记 | Alice and Bodの神秘小屋</title><meta name="keywords" content="密码学,CTF,安全"><meta name="author" content="Dorange"><meta name="copyright" content="Dorange"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="密码学笔记"><meta name="application-name" content="密码学笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="密码学笔记"><meta property="og:url" content="https://lr2006-robot.github.io/myblog.github.io/post/undefined.html"><meta property="og:site_name" content="Alice and Bodの神秘小屋"><meta property="og:description" content="古典密码常见的古典密码在计算机时代大部分可以通过计算机的算法完成爆破类似的解密 单表替换密码Caesar Cipher 凯撒密码对于26个字母进行数字映射(a–&amp;gt;0)，然后对于明文映射后加上同一个密钥n，得到密文破解同理转化为数字映射然后同时减去n即可 加密函数：$E_k(x) ≡ (x +"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Dorange"><meta property="article:tag" content="密码学,CTF,安全"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="古典密码常见的古典密码在计算机时代大部分可以通过计算机的算法完成爆破类似的解密 单表替换密码Caesar Cipher 凯撒密码对于26个字母进行数字映射(a–&amp;gt;0)，然后对于明文映射后加上同一个密钥n，得到密文破解同理转化为数字映射然后同时减去n即可 加密函数：$E_k(x) ≡ (x +"><link rel="shortcut icon" href="/myblog.github.io/favicon.ico"><link rel="canonical" href="https://lr2006-robot.github.io/myblog.github.io/post/undefined.html"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/myblog.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/myblog.github.io/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Dorange","link":"链接: ","source":"来源: Alice and Bodの神秘小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Alice and Bodの神秘小屋',
  title: '密码学笔记',
  postAI: '',
  pageFillDescription: '古典密码, 单表替换密码, Caesar Cipher 凯撒密码, 凯撒加密代码实现, 凯撒解密代码实现, Simple Substitution Cipher 简单替换密码, 字频攻击代码, Atbash Cipher 埃特巴什码, Morse Cipher 摩斯密码, Affine Cipher 仿射密码, 多表替换密码, 维吉尼亚密码, 维吉尼亚解密代码实现(不一定准确只可以大致参考), 其他类型密码, Rail-Fence Cipher 栅栏密码, Baconian Cipher 培根密码, 培根密码表, 栅栏加密代码实现, 栅栏解密代码实现, 现代密码, 不同分类, 按照密钥的特性进行分类, 按照功能分类, 按照抗量子能力, 对称密码, 序列密码-RC4(Rivest Cipher 4 李维斯特密码4), S盒初始化(KSA), 伪随机流生成(PRGA), 序列密码-RC4加解密代码实现, 序列密码-OTP(One Time Pad 一次一密), OTP加密代码实现, OTP解密方式一, OTP解密方式二(可实现率极低), 解密原理一, 解密原理二, 例题, 序列密码-LCG(Linear Congruential Generator 线性同余生成器), 解密前置知识, 同余运算简单性质, 逆相关运算, LCG解密方式一, LCG解密方式二, LCG例题, LCG例题题目, LCG例题解题代码, 序列密码-LFSR(Linear Feedback Shift Register 线性反馈移位寄存器), LFSR线性反馈函数, LFSR解密方式一, LFSR解密方式二, 分组密码-DES(Data Encryption Standard 数据加密标准), DES加密初始置换和最终置换, 初始置换(Initial Permutation)代码实现, DES密钥扩展算法, DES密钥扩展算法代码实现, DES加密轮函数(Feistel Function 费斯妥函数), DES加密轮函数代码实现, DES加密过程, DES加密代码实现, DES加解密代码实现, DES解密方式一, 分组密码-AES(Advanced Encryption Standard 高级加密标准), AES算法层加密, AES加密算法框架代码实现, AES算法层-扩散层, AES算法层-密钥加法层, AES密钥扩展算法, AES加解密代码实现, 分组密码-分组模式, 分组模式-ECB(Electronic Code Book mode 电子密码本模式), 分组模式-ECB加解密代码实现, 分组模式-CBC(Cipher Block Chaining mode 密码分组链接模式), 分组模式-CBC加解密代码实现, 分组模式-CFB(Cipher FeedBack mode 密文反馈模式), 分组模式-CFB加解密代码实现, 分组模式-CTR(CounTeR mode 计数器模式), 分组模式-CTR计数器构造, 分组模式-CTR加解密代码实现, 分组模式相关利用手法A, 初始化向量IV代码生成, IV复用, IV复用例题, 分组模式相关利用手法B, ECB模式剪贴, CBC模式字节翻转, 分组模式相关利用手法C, PKCS7填充, Padding Oracle, 非对称密码, 公钥密码-RSA, 公钥密码-RSA密钥生成, 公钥密码-RSA加解密, 公钥密码-RSA模数分解, 公钥密码-RSA模数分解方式一(直接分解), 公钥密码-RSA模数分解方式二(pq相近), 公钥密码-RSA模数分解方式三(模不互素), 公钥密码-RSA模数分解方式四(共模攻击), 公钥密码-RSA指数利用方法, 小公钥e指数利用, 已知e和d分解n, Wiener利用, 公钥密码-RSA-LSB利用方法, 最低位预言机攻击(LSB Oracle Attack), RSA的积性(乘法同态), 公钥密码-RSA-LSB解密代码实现, 公钥密码-RSA-Coppersmith利用方法, Coppersmith定理, 已知m高位, 公钥密码-DH密钥交换, 公钥密码-DH密钥交换前置知识, 群基础基础定义, 群的特性, 离散对数难题, 公钥密码-DH密钥交换协议, 公钥密码-DH密钥交换中间人攻击, 公钥密码-ElGamal加密算法, 公钥密码-DSA数字签名算法, 哈希函数, 哈希函数-SHA1算法(Secure Hash Algorithm 1 安全散列算法1), 哈希函数长度扩展攻击, 公钥密码-数字签名-RSA签名, 公钥密码-数字签名-ElGamal签名, 公钥密码-数字签名-ElGamal签名过程, 公钥密码-数字签名-ElGamal验签过程, 公钥密码-数字签名-ElGamal签名k重用攻击古典密码常见的古典密码在计算机时代大部分可以通过计算机的算法完成爆破类似的解密单表替换密码凯撒密码对于个字母进行数字映射然后对于明文映射后加上同一个密钥得到密文破解同理转化为数字映射然后同时减去即可加密函数解密函数凯撒加密代码实现凯撒密码加密函数明文需要加密的字符串移位量整数可正可负正表示向后移负表示向前移密文加密后的字符串存储最终的密文遍历明文中的每个字符处理小写字母字母转数字减去得到移位运算原数字移位量循环移位数字转字母加上还原为小写字母的码处理大写字母同理减去得到非字母字符数字空格符号等直接保留自定义明文和移位量包含大小写符号数字经典凯撒密码移位量可修改为任意整数如等调用加密函数输出结果明文移位量密文凯撒解密代码实现凯撒密码解密函数独立实现处理小写字母密文字母转数字解密核心减移位量处理大写字母非字母字符直接保留测试请输入需要解密的密文请输入加密时的移位量整数解密后的明文简单替换密码对于个字母进行一一替换一般情况下可以用字频攻击破解大部分后续人工微调字频攻击代码定义字母表和密文统计密文中每个字母的频率计算频率并排序英文字母标准频率从高到低初步替换密文字符初步解密结果埃特巴什码加密方式是将字母表前后倒转进行替换可以一般难以判别使用字频攻击破解摩斯密码主要由点横杠字符间停顿一般用空格单词间停顿一般用构成仿射密码对于个字母进行数字映射然后经过一个单射函数处理再转回字母加密加密函数解密函数多表替换密码维吉尼亚密码首先拿到明文长度然后将密钥长度扩展到明文长度然后转化为数字映射进行一一对应相加得到密文解密时首先要得到的长度然后尝试得到的具体内容才可以解密维吉尼亚解密代码实现不一定准确只可以大致参考维吉尼亚破解预处理去掉空格以及回车给定字符串计算其重合指数对字符串按输入个数进行分组计算每一组的值返回平均值长度为时平均重合指数为遍历确定最有可能的密钥长度返回密钥长度假设密钥长度在之间密钥长度为此时重合指数每组的平均值为为偏移量计算互重合指数确定两个子串最优的相对偏移量完成分组操作并计算每一组与第一组的最优相对偏移量并返回对密文进行分组计算与第一组之间的相对偏移量第组和第组之间偏移为时互重合指数为为第一个子串的移位输出密钥并返回密钥所有字母的下标第一个偏移量为密钥为时输入密文密钥返回明文结果在这里填入密文文件路径输出部分明文确定偏移量参考输出请输入第一个子串的偏移量对英文文本进行分词明文为其他类型密码栅栏密码将明文分栏分为组然后明文按顺序依次进入各栏形成类的形状最后进行各栏的拼接得到密文解密直接进行爆破即可培根密码一种替换密码每个明文字母由五个字符序列替换一般使用也可用其他培根密码表栅栏加密代码实现获取用户输入添加输入合法性校验请输入需要加密的明文错误明文不能为空请重新输入请输入栅栏数密钥错误栅栏数必须是正整数请重新输入错误请输入有效的整数作为栅栏数提前计算长度避免重复调用遍历每个栅栏按栏索引循环遍历当前栅栏的每个位置步长为栅栏数加密完成密文为栅栏解密代码实现校验命令行参数说明自动爆破到密文长度之间的所有可能栅栏数获取密文并处理校验密文有效性错误密文长度不能小于请输入有效的密文生成所有可能的栅栏数原逻辑仅保留能整除密文长度的补充增加非整除情况更全面原逻辑保留能整除密文长度避免部分情况漏解补充添加不能整除的常见栅栏数部分场景下栅栏数无需整除长度原代码逻辑较局限避免因密文长度非栅栏数倍数导致漏解保留前个常见值平衡效率与全面性最多补充个避免输出过多冗余去重并排序无可能栅栏数的异常处理未找到可能的栅栏数无法爆破遍历所有可能的栅栏数进行解密开始爆破共种可能栅栏数按栅栏数拆分并重组核心解密逻辑从索引开始步长为提取当前栅栏的所有字符栅栏数解密结果爆破完成请根据语义判断正确结果现代密码不同分类按照密钥的特性进行分类对称密码速度快密钥分发难非对称密码密钥分发易速度慢混合密码结合两者优势主流按照功能分类数据加密保机密性数字签名保完整认证不可否认密钥交换安全协商对称密钥消息认证保完整认证无不可否认按照抗量子能力传统密码抗经典不抗量子后量子密码抗量子未来核心对称密码对称密码可以分为两大类序列密码流密码和分组密码块密码序列密码生成与明文长度相同的密钥流由密钥生成器产生逐位或逐字节加密将明文与密钥流逐位异或分组密码将明文分成固定长度的组每组独立加密用同一密钥对每组明文加密密钥长度固定现代密码学设计密码算法一般遵循两个原则混淆模糊明文和密文的关系尝试用替换的方式实现扩散将明文中一位的影响扩散到多个密文尝试用置换的方式实现现代密码学中通常使用多轮运算每一轮中会有若干层混淆变换和扩散变换序列密码李维斯特密码的核心分为两大阶段盒初始化和伪随机流生成盒初始化首先盒填充为到的连续字节同时维护一个辅助数组将密钥循环填充到中计算交换索引交换和伪随机流生成初始化索引设两个初始索引逐字节生成密钥流对每一个明文字节执行递增并取模用更新再次交换盒元素保证随机性计算中间值从盒中取一个字节作为密钥流字节将生成的与明文或密文字节异或得到密文或明文序列密码加解密代码实现初始化盒填充数组并打乱盒生成密钥流并异或异或得到结果测试加密和解密密钥类型明文密文十六进制输出密文十六进制格式解密后明文输出序列密码一次一密将明文所有字符转化为八位二进制然后随机生成和密文等长的密钥流将明文和密钥流进行异或得到密文加密代码实现使用一次一密加密明文明文数据字节序列密钥字节序列密文字节序列密钥长度必须与明文长度相同使用一次一密解密密文密文数据字节序列密钥字节序列解密后的明文字节序列密钥长度必须与密文长度相同示例使用生成与明文等长的随机密钥加密密文解密解密后的明文解密方式一得到完整的密钥流不完整也无法进行解密解密方式二可实现率极低有多个加密后的密文即同一个密钥流不断加密得到各阶段的密文解密原理一的加密效果抵消解密原理二对于一个小写字母与异或结果为大写字母反之亦然例题序列密码线性同余生成器生成伪随机数满足递推式其中为常数且需要作为种子由此递推式生成伪随机数序列得到密钥流再逐字节进行异或加密得到密文解密前置知识同余运算简单性质逆相关运算注意不是所有情况都存在逆只有与互质是才存在逆解密方式一在已知常数的前提下若能捕捉到生成的一个输出则可以恢复出状态并通过递推式预测之后产生的所有随机数通过递推可以得到初始种子以及后续所有组成密钥流解密方式二在未知已知的情况下若能捕捉到生成的连续两个输出可以通过建立方程求解得到递推公式联立方程组解出后续递推密钥流即可例题例题题目例题解题代码一步迭代的线性变换矩阵含常数项步合并成一次变换计算和的平方根两个平方根分支由构造四次方程解出验证所有候选并解密序列密码线性反馈移位寄存器我们将中的寄存器个数称为的级数一个级的最多可存储种状态在个寄存器中依次有状态向右移位则输出为密钥流的第一项空缺由线性反馈函数的处理结果补上以此类推不断进行得到密钥流一般情况下会有循环周期效果周期数由反馈函数决定循环周期线性反馈函数函数由状态以及推头组成构成函数推头可以简单理解为和组成决定该位置状态是否参与函数的运算解密方式一在已知反馈函数的前提下如果已知连续位明文和位密文则可以计算得出位密钥即为的一个状态此时根据反馈函数即可计算出的全部输出即全部密钥密钥流从而破解解密方式二在未知反馈函数前提下若获取位的明文和密文计算得出位的密钥这位密钥中有的种状态分别为这些状态之间存在着互相递推关系例如就是由计算出来的以此类推就是由计算得出从而得到个线性方程进行矩阵运算接口解出反馈函数分组密码数据加密标准块长度为位密钥长度为位其中位为校验位实际有效位明文位分组加密得到位密文对明文进行轮加密运算每一轮都有一个相应的子密钥参与子密钥由密钥扩展算法计算得出此外开头和结尾分别有初始置换和最终置换的操作加密初始置换和最终置换就是简单根据置换表把长度为比特的每一个位置进行变换初始置换代码实现最终置换代码实现密钥扩展算法通过置换去除比特密钥中的校验位将比特的密钥分成比特连续轮运算每一轮分别先对左右两半循环移位再经过置换生成一个比特的子密钥最终得到组比特的子密钥密钥扩展算法代码实现加密轮函数费斯妥函数先通过将比特输入扩展成比特再与比特的子密钥混合作异或运算然后比特分别分为组每组比特经过盒替换输出组比特即比特最后对这比特依据一张固定的置换表进行移位置换加密轮函数代码实现加密过程将分块后的明文位先进行初始置换再分为左右两块位在每一轮中进行下列运算总共进行轮为轮函数将进行交换拼接进行最后置换得到位密文加密代码实现加解密代码实现解密方式一在已知密文和个子密钥的情况下由于轮函数以及置换的可逆性仅需要在轮函数作用时使用逆序的子密钥即可分组密码高级加密标准算法的块长度为位不同密钥长度分别有不同加密轮数位密钥对应轮位密钥对应轮位密钥对应轮每一轮直接对整个位进行加密使用算法层进行加密算法层加密位字节首先按照从左向右从上到下排成一个的矩阵先对密钥进行扩展得到子密钥用于密钥加法层处理其中先对明文进行密钥加法层处理后续进行第轮密钥加法层处理随后直到轮都进行字节代换层扩散层由层和层构成密钥加法层最后一轮删去层处理其余不变得到最后密文加密算法框架代码实现算法层字节代换层让输入的每一个字节通过盒代换映射到另外一个字节此处的盒是可以经过每种方式计算出来的也可以直接使用计算好的进行代换算法层扩散层行移位层层对于的矩阵在做行移位时第一行保持不变第二行往左移动一格第三行左移两格第四行左移三格行混淆层层将整个字节矩阵乘上一个列混淆矩阵有限域上的矩阵运算相当于正常矩阵运算结果取模算法层密钥加法层输入字节的明文和子密钥对这两个输入逐字节异或并将异或结果输出密钥扩展算法以标准位密钥对应共有组子密钥反别在一开始盒每一轮共十轮中参与轮密钥加法层运算子密钥的生成是以列为单位一列字节比特构成一个字四个字拼接成一个子密钥的生成将密钥同样从左到右从上到下排列为一个矩阵第一列为拼接构成的生成首先存在函数接收的结果其输出与进行异或得到然后与异或得到以此类推得到拼接得到重复上述过程即可以此类推拿到所有子密钥函数将输入的分成四块每块字节将每个字节进行向循环左移一位逐字节经过盒进行代换用第一个字节盒轮系数进行异或运算实际上是四个字节整体与轮常量异或但是常量后续三个字节都是加解密代码实现例题一抽取当前时间的时间戳转化成类型作为随机数生成的种子用函数生成一个位的整数并转化为字节形式得到一个字节加密是难以爆破的我们一般只可以取找由于算法的固定所以直接找到时间戳就可以拿到分组密码分组模式分组密码算法只能加密固定长度的分组当我们加密的明文长度超过块长度时需要分组密码算法迭代以全部加密而不同的分组密码算法分组就是分组密码的模式常见的分组模式有如下几种模式电子密码本模式模式密码分组链接模式模式密文反馈模式模式输出反馈模式模式计数器模式模式伽罗瓦计数器模式分组密码迭代加密要求每一个明文分组都是块长度或字节当分组到最后一组时其长度不足块长度就需要对其进行填充将长度扩展为块长度常见的填充方式有如下几种补零在末尾补上字节字节填充先填充字节直至最后一字节填充值为填充长度填充若需填充个字节则每个填充字节值都是分组模式电子密码本模式最简单的分组方式直接将明文分成固定的块大小每个块进行独立且相同的加密明文和密文一一对应分组模式加解密代码实现分组模式密码分组链接模式首先一样先对明文进行分块填充然后使用初始化向量对第一个明文块进行异或操作然后进行加密第一个加密得到密文在与第二块明文进行异或随后第二块去加密以此类推分组模式加解密代码实现分组模式密文反馈模式首先一样先对明文进行分块填充然后对进行加密得到中间结果将这个结果与第一块明文进行异或得到第一块密文第一块密文进行加密得到中间结果中间结果再与第二块明文异或得到第二块密文以此类推分组模式加解密代码实现分组模式计数器模式首先一样先对明文进行分块填充然后对一个逐次累加的计数器进行加密得到中间结果密钥流的流密码将这个结果与块明文进行异或得到块密文分组模式计数器构造每一次解密时都会生成一个仅用一次的数来作为计数器的初始值计数器格式前面字节为固定的后面字节为分组序号会逐次累加分组模式加解密代码实现分组模式相关利用手法初始化向量是一个固定长度的输入值一般会要求它是随机数或者拟随机数模式中由于没有导致密钥不变的情况下相同的明文必然会加密生成相同的密文会泄露明文部分信息初始化向量代码生成系统内置的密码学安全生成器复用模式中和计数器的组合是用于产生流密钥的关键如果每一次加密的都是一样的导致生成的流密钥也是一样的如果已知一段明密文则可以通过明文和密文的异或恢复出密钥流并用这个密钥流对其他密文解密这就是复用复用例题从题目中我们可以获取以下信息其中和均未知我们可以任意选取一段明文发送给服务端并得到满足从中可以解出从而可以求出分组模式相关利用手法模式剪贴某个网站的用户如下采用位的模式对进行加密所得的密文如下仅当时才能得到由于模式下密文和明文一一对应所以可以进行特定的剪贴修改输出结果可以看见第三行和第五行相似第五行就是我们想要的第三行效果进行剪贴替换为第组密文块模式字节翻转模式的解密过程可以由如下关系式来表示其中是块的数量从中可以看出若修改某个密文块则会影响到解密出来的了不一个明文块即我们可以通过篡改密文来任意操纵明文假设想要控制某个块的明文可以通过修改前一块密文相应的字节来达到这个目的若要修改第个明文块第个字节的数值则可以对第个密文块第个字节异或上相应的数值但也会导致解密出来的第块明文不可预测分组模式相关利用手法填充是一种常用的填充方式其具体的填充方式为填充个字节且这个填充字节的字节值均例如当块大小为时对进行填充填充的结果为注意即使最后一个块的长度为填充方式仍然会对其进行填充会在其后填充一块全为的字节块服务端在进行解密的时候会对解密的结果做解除填充操作如果解除填充时校验到填充格式不合法则会直接报错通常会返回对应的错误消息息解密解除填充填充格式错误函数返回继续执行场景目标对手获取到了一段密文想要对其进行解密利用思路可以通过字节翻转的手法来修改解密后的明文并将其发送给服务端若修改后的明文符合填充格式服务器返回则对手可以从中获取到一些关于原始密文的一些信息如何解密最后一个字节我们要利用这个合法的填充格式假设为最后一字节共有种可能性对上一个密文块的最后一字节异或上则解密后的最后一个明文块也会异或上若正确则最后一块格式为服务器返回否则服务器返回如何解密倒数第个字节我们要利用这个合法的填充格式先通过已解出来倒数个明文通过字节翻转的方式将解密后的明文块后修改为然后继续使用解密倒数第个字节的方式尝试种可能的直至服务器返回说明即为倒数第个字节通过上述方法可以解密出最后一个明文块的个字节解密完之后即可将最后字节的密文抛弃继续对倒数第二块密文块进行解密依此方法可以对所有密文进行解密恢复出整个明文信息非对称密码公钥密码一般都是基于一些数学难题设计的如算法就是基于大整数因数的分解问题密钥交换算法是基于离散对数问题算法是基于椭圆曲线离散对数问题公钥密码算法的安全性取决于其底层的数学难题大整数因数分解问题的难度对于一些不安全位数比较小的素数以当前的算法和算力很容容易将其分解通常以下的模数均可在较短时间内被分解一些不安全的素数也会很快被特定算法所分解过程分为密钥生成加密解密三部分公钥密码密钥生成选两个大素数随机选两个不同的大素数和计算是公钥私钥的模数会公开计算欧拉函数是小于且与互质的数的数量选公钥指数选一个整数满足且与互质算私钥指数求满足即是在模下的逆元最终密钥公钥公开给其他人私钥自己保管绝对保密公钥密码加解密假设要加密的明文是需满足若太大则分段加密加密公式密文用私钥解密密文解密公式明文公钥密码模数分解公钥密码模数分解方式一直接分解中直接使用函数即可公钥密码模数分解方式二相近一般来说这样生成的两个相差不过几百或者几千有关系则近似平方根必然落在之间且距离近可以通过穷举的方式找到公钥密码模数分解方式三模不互素当两个模数共有一个素数时有下面关系可以对两个模数求最大公约数这个数就是素因子从而分解两个模数公钥密码模数分解方式四共模攻击当难以分解时使用相同的模数不同的私钥加密同一明文消息时即存在共模绕过分解已知密文公钥以及模数时现在有下面关系扩展欧几里得算法计算根据此算法计算出从而有使得右上角的指数变成公钥密码指数利用方法小公钥指数利用通过模幂运算对明文加密当指数逐渐增大时模运算发挥作用将整数幂运算的结果截断至有限范围内但是当指数太小时模运算还未发挥作用幂运算就已经结束此时的加密结果并没有被截断即是原本的幂运算此时就不存在加密效果当较小时即时就会存在这种利用另外即使稍比大一点点也可以通过穷举的方式对其尝试开根可以从开始穷举并对尝试开次方根若可以开出来根则说明成功解密对于正常的加密一般很大无法被穷举已知和分解算法若能够知道加密指数和解密指数则可以完成对的的分解根据和的关系有同样可以化为其中因此必有可以穷举从而可以得到中得到后根据的表达式我们可以得到二元二次方程解出这个方程从而分解可以整除满足欧拉定理利用当比较小时可以使用利用来获取私钥特征通常出题人为了要使得生成的私钥比较小通常会先生成一个比较小的然后再去求从而使得的取值范围位于之间会导致看起来很大从两条关系出发带入有两边同时除以得到式子左边均已知右边均未知右边和左边非常接近这种情况可以使用连分数来将左边的比值展开在连分数的展开式中很大概率存在和从而可以求出私钥进行解密恢复成功十六进制验证应为返回正确的恢复失败公钥密码利用方法最低位预言机攻击假设现在有一个预言机它会对一个给定的密文进行解密但并不会直接返回解密结果而是检验解密的明文的奇偶性根据奇偶性返回相应的值比如表示奇数表示偶数即最低位那么给定任意一个消息被加密后的密文只需要次询问就可以解密出明文消息例如当是位时只需要大约次左右的询问就可以解密出明文的积性乘法同态由加密关系可证明得到利用这个性质可以选择一个计算将发送给服务器服务器就会返回加密结果的奇偶性通过巧妙地继续选取就可以恢复出公钥密码解密代码实现结果并不一定精确需要再附近找一下正确的公钥密码利用方法定理假设为一个未知分解情况的合数并定义为一个最高次数为的整数系多项式假设这个多项式存在一个根即且满足给出了一个算法可以很快求出这个小根定理令为一个最高次位数为的首一多项式为一个未知分解情况的正合数为一个极小的量那么在多项式时间算法复杂度较低内我们可以找到的整数解满足证明过于复杂涉及到格构造算法等知识点已知高位题目场景假设模数为现在已知的高位只有低位未知未知量符合小根的条件小于设未知量为构造如下的多项式使用定理即可求解出公钥密码密钥交换公钥密码密钥交换前置知识群基础基础定义集合简单来讲就是把一堆东西元素放在一起群是一个集合并且在这个集合上定义了一个运算比如加法乘法简而言之群就是集合运算简单来说群的作用就是描述对称性系统从一个状态通过某种运算变换到另一个状态如果这两个状态等价则说系统对这一变换时对称的群通过数学化的方式定义对称性群只关心对称最本质最抽象的性质所以只关心操作将操作放到集合里面举例对一个正方体进行操作有操作保持不变旋转旋转旋转类比加法保持不变旋转旋转旋转类比乘法保持不变旋转旋转旋转这里的加法乘法都是模运算每四次运算就是一个周期这样我们就得到了两个群所以群就是一个集合加上一个运算满足以下四个条件封闭性对于所有有结合性对于所有有单位元存在一个使得对于所有有逆元对于每个存在一个使得即就是的逆元记作以为例集合元素所有保证对称的操作二元运算加法封闭性旋转组合的结果还是在集合里面结合性旋转的顺序不影响最终结果单位元保持不变逆元每个操作都有一个对应的逆操作比如的逆操作是模乘法运算也可以组成一个群定义为集合元素所有小于的正整数二元运算模乘法封闭性两个小于的数相乘模结果还是小于的数结合性乘法满足结合律单位元逆元根据扩展欧几里得定理对于每一个元素都存在整数和使得则就是的逆元群的特性群的阶数群中所有元素的个数记作元素的阶数对于群中的元素存在最小的正整数使则称为的阶数记作有些元素的阶数等于群的阶数这样的元素称为生成元或者原根一般记作对于乘法群其阶数为通过的幂次运算可以生成群中的所有元素例如的原根来说对于加法群来说生成元是所有和互素的数例如的生成元来说离散对数难题在群中若有一个原根很容易算出所有元素但是反过来已知和要算出就非常困难这就是离散对数难题在密码学的实际应用中一般会选择大素数至少和对应的原根现有的最好的通用型解决离散对数问题的算法其算法的时间复杂度也非常高算法的时间复杂度为算法的时间复杂度为算法的时间复杂度为其中为的质因数分解算法的时间复杂度为中可以直接使用函数来计算离散对数默认调用算法和算法在数据量比较小的时候可以快速解决以下公钥密码密钥交换协议首先通信双方先共享两个公共参数模数和生成元本地随机生成一个私钥并计算将发送给收到后本地随机生成一个私钥并计算将发送给同时计算共享密钥计算共享密钥最终和都得到了相同的共享密钥以这个作为对称加密算法的密钥进行后续的通信加密公钥密码密钥交换中间人攻击假设有一个攻击者她可以监听和之间的通信当发送给时截获了并生成自己的私钥计算将发送给当发送给时截获了并将发送给此时计算共享密钥计算共享密钥计算共享密钥计算共享密钥最终成功地和分别建立了两个共享密钥可以伪装进行通信拿到双方的通信原始数据公钥密码加密算法加密算法基于离散对数难题设计首先通信双方先共享两个公共参数模数和生成元本地随机生成一个私钥并计算将作为公钥发送给收到后选择一个随机数且与互素计算临时公钥计算共享密钥对进行处理使得如果过大可以分段加密使用共享密钥对消息进行加密计算将密文对发送给收到密文对后计算共享密钥使用共享密钥对进行解密计算加密侧解密侧公钥密码数字签名算法数字签名用于验证消息的完整性和真实性数字签名一般是基于非对称密码加密算法实现的非对称算法的解密运算即为签名加密运算即位验签假设想要对一份文档进行签名会使用他的私钥对文档进行签名运算并得到签名随后将文档和签名发送给使用的公钥对签名进行验签运算数字签名的要点签名的消息不一定要加密可以明文的形式传输只有签名者有私钥能够对消息进行签名任何其他人没有私钥无法签名任何人都可以使用签名者的公钥对签名进行验证消息完整性如果消息在传输过程中被篡改验签会失败不可抵赖性因为只有有私钥只有他能生成有效签名所以不能否认他签署过该消息哈希函数在数字签名中一般不会直接对消息进行签名而是先对消息进行哈希运算得到消息摘要然后对消息摘要进行签名哈希函数能够将任意长度的输入映射为固定长度的输出值散列值或摘要特征接受任意长度输入最高可接受位的输入固定长度输出输出位字节的摘要高效性哈希函数计算时间短单向性已知哈希函数的输出很难反推出输入抗碰撞性很难找到两个不同的输入和使得雪崩效应输入的微小变化会导致输出的显著变化常见的哈希函数输出位摘要设计用于位处理器输出位摘要已被证明存在碰撞漏洞不推荐用于安全输出位摘要已被证明存在碰撞漏洞不推荐用于安全输出位摘要当前被广泛使用安全性较高输出位摘要安全性更高但计算速度较慢输出位摘要主要用于数据完整性校验不适合安全应用输出位摘要设计用于高安全性应用输出位摘要速度快适用于数据完整性校验输出位摘要设计用于数字签名和加密应用哈希函数除了数字签名还有很多其他用途散列表方便数据的查询搜索可以达到的时间复杂度错误矫正可以通过检查散列值判断传输的信息是否在中途被篡改区块链可被用作工作量证明使用散列值来链接区块哈希函数算法安全散列算法算法的输入是几乎任意长度的消息最大输出是位字节的消息摘要算法采用结构分块处理输入消息每块位字节算法的主要步骤填充消息在消息末尾添加一个位然后添加足够的位使消息长度对取模后等于添加长度在消息末尾添加一个位的整数表示原始消息的长度初始化哈希值使用五个位的常数作为初始哈希值处理消息块压缩函数将消息处理输出摘要将最终的哈希值连接起来得到位的消息摘要压缩函数初始化链接状态为固定的初始值将位消息块扩散为个字每个字会经过一个轮的运算每一轮都会更新链接状态轮运算后链接状态经过变换输出作为下一次压缩函数的输入哈希函数长度扩展攻击在某些登录场景中服务器会通过哈希函数来进行全校认证合法用户应当知道的具体值从而可以计算出正确的散列值以此校验登录中定义了变量哈希长度扩展利用当已知但未知能够计算当我们初次登陆时服务器会设置为并将摘要以的形式发送给客户端借助哈希长度扩展攻击我们可以计算出设置为其中带有字样就可以登陆拿公钥密码数字签名签名加密算法不仅可以对数据进行加密也可以用来数字签名不同的是签名使用私钥进行加密验签使用公钥进行解密公钥密码数字签名签名一个大素数的一个原根生成元签名者的私钥随机选择签名者的公钥计算得到公钥密码数字签名签名过程随机生成一个整数满足且与互素计算计算签名结果为签名对公钥密码数字签名验签过程计算计算解密后的消息相关量如果则验签通过否则验签失败根据签名计算公式可知公钥密码数字签名签名重用攻击假设签名者在对两个不同的消息和进行签名时不小心重用了同一个随机数得到签名对和根据签名公式有下面两条关系将上面两条关系式相减得到恢复出后带入任意一条关系式即可求出私钥私钥',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-08 17:35:07',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/myblog.github.io/atom.xml" title="Alice and Bodの神秘小屋" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/myblog.github.io/" accesskey="h"><div class="title">Alice and Bodの神秘小屋</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/myblog.github.io/archives/2026/02/"><span class="card-archive-list-date">二月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">密码学笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2026-02-08T02:00:00.000Z" title="发表于 2026-02-08 10:00:00">2026-02-08</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2026-02-08T09:35:07.067Z" title="更新于 2026-02-08 17:35:07">2026-02-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://lr2006-robot.github.io/myblog.github.io/post/undefined.html"><header><h1 id="CrawlerTitle" itemprop="name headline">密码学笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Dorange</span><time itemprop="dateCreated datePublished" datetime="2026-02-08T02:00:00.000Z" title="发表于 2026-02-08 10:00:00">2026-02-08</time><time itemprop="dateCreated datePublished" datetime="2026-02-08T09:35:07.067Z" title="更新于 2026-02-08 17:35:07">2026-02-08</time></header><h2><span id="古典密码">古典密码</span></h2><p>常见的古典密码在计算机时代大部分可以通过计算机的算法完成爆破类似的解密</p>
<h3><span id="单表替换密码">单表替换密码</span></h3><h4><span id="caesar-cipher-凯撒密码">Caesar Cipher 凯撒密码</span></h4><p>对于26个字母进行数字映射(a–&gt;0)，然后对于明文映射后加上同一个密钥n，得到密文<br>破解同理转化为数字映射然后同时减去n即可</p>
<p>加密函数：<br>$E_k(x) ≡ (x + k) \ mod \ 26$<br>解密函数：<br>$D_k(x) ≡ (x - k) \ mod \ 26$</p>
<h5><span id="凯撒加密代码实现">凯撒加密代码实现</span></h5><pre><code class="language-python">def caesar_encrypt(plaintext, shift):
    &quot;&quot;&quot;
    凯撒密码加密函数
    :param plaintext: 明文(需要加密的字符串)
    :param shift: 移位量(整数，可正可负，正表示向后移，负表示向前移)
    :return: 密文(加密后的字符串)
    &quot;&quot;&quot;
    ciphertext = &quot;&quot;  # 存储最终的密文
    for char in plaintext:  # 遍历明文中的每个字符
        # 处理小写字母(a-z)
        if char.islower():
            # 1. 字母转数字：a→0, b→1, ..., z→25(ord(&#39;a&#39;)=97，减去97得到0-25)
            char_num = ord(char) - ord(&#39;a&#39;)
            # 2. 移位运算：(原数字 + 移位量) %26(循环移位)
            encrypted_num = (char_num + shift) % 26
            # 3. 数字转字母：0→a, 1→b, ..., 25→z(加上97还原为小写字母的ASCII码)
            encrypted_char = chr(encrypted_num + ord(&#39;a&#39;))
            ciphertext += encrypted_char
        # 处理大写字母(A-Z)
        elif char.isupper():
            # 同理：A→0, B→1, ..., Z→25(ord(&#39;A&#39;)=65，减去65得到0-25)
            char_num = ord(char) - ord(&#39;A&#39;)
            encrypted_num = (char_num + shift) % 26
            encrypted_char = chr(encrypted_num + ord(&#39;A&#39;))
            ciphertext += encrypted_char
        # 非字母字符(数字、空格、符号等)直接保留
        else:
            ciphertext += char
    return ciphertext

if __name__ == &quot;__main__&quot;:
    # 自定义明文和移位量
    plaintext = &quot;Hello, Caesar Cipher! 123&quot;  # 包含大小写、符号、数字
    shift = 3  # 经典凯撒密码移位量(可修改为任意整数，如5、-2等)
    # 调用加密函数
    ciphertext = caesar_encrypt(plaintext, shift)
    # 输出结果
    print(f&quot;明文：{plaintext}&quot;)
    print(f&quot;移位量：{shift}&quot;)
    print(f&quot;密文：{ciphertext}&quot;)
</code></pre>
<h5><span id="凯撒解密代码实现">凯撒解密代码实现</span></h5><pre><code class="language-python">def caesar_decrypt(ciphertext, shift):
    &quot;&quot;&quot;凯撒密码解密函数(独立实现)&quot;&quot;&quot;
    plaintext = &quot;&quot;
    for char in ciphertext:
        # 处理小写字母
        if char.islower():
            char_num = ord(char) - ord(&#39;a&#39;)  # 密文字母转数字(a→0)
            decrypted_num = (char_num - shift) % 26  # 解密核心：减移位量
            decrypted_char = chr(decrypted_num + ord(&#39;a&#39;))
            plaintext += decrypted_char

        # 处理大写字母
        elif char.isupper():
            char_num = ord(char) - ord(&#39;A&#39;)
            decrypted_num = (char_num - shift) % 26
            decrypted_char = chr(decrypted_num + ord(&#39;A&#39;))
            plaintext += decrypted_char

        # 非字母字符直接保留
        else:
            plaintext += char
    return plaintext

------------------- 测试 -------------------
if __name__ == &quot;__main__&quot;:
    ciphertext = input(&quot;请输入需要解密的密文：&quot;)
    shift = int(input(&quot;请输入加密时的移位量(整数)：&quot;))
    decrypted_text = caesar_decrypt(ciphertext, shift)
    print(f&quot;解密后的明文：{decrypted_text}&quot;)
</code></pre>
<h4><span id="simple-substitution-cipher-简单替换密码">Simple Substitution Cipher 简单替换密码</span></h4><p>对于26个字母进行一一替换，一般情况下可以用字频攻击破解大部分，后续人工微调</p>
<h5><span id="字频攻击代码">字频攻击代码</span></h5><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

 #定义字母表和密文
alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;
cipher_text = &quot;wb wi kjb mk rmit bmiq bj rashmwk rmvp yjeryrkb mkd wbi iwokwxwvmkvrmkd&quot;

 #统计密文中每个字母的频率
count = np.zeros(len(alphabet))
for char in cipher_text:
    if char in alphabet:
        index = alphabet.index(char)
        count[index] += 1

 #计算频率并排序
total = sum(count)
frequency = count / total
sorted_indices = np.argsort(-frequency)
sorted_alphabet = &#39;&#39;.join([alphabet[i] for i in sorted_indices])

 #英文字母标准频率(从高到低)
english_frequency_order = &#39;etaoinshrdlcumwfgypbvkjxqz&#39;

 #初步替换密文字符
translation_table = str.maketrans(sorted_alphabet, english_frequency_order)
decoded_text = cipher_text.translate(translation_table)

print(&quot;初步解密结果：&quot;, decoded_text)
</code></pre>
<h4><span id="atbash-cipher-埃特巴什码">Atbash Cipher 埃特巴什码</span></h4><p>加密方式是将字母表前后倒转进行替换，可以一般难以判别，使用字频攻击破解</p>
<h4><span id="morse-cipher-摩斯密码">Morse Cipher 摩斯密码</span></h4><p>主要由点(.)，横杠(-)，字符间停顿(一般用空格space)，单词间停顿(一般用&#x2F;)构成</p>
<h4><span id="affine-cipher-仿射密码">Affine Cipher 仿射密码</span></h4><p>对于26个字母进行数字映射(a–&gt;0)，然后经过一个单射函数处理，再转回字母加密<br>加密函数：<br>$E(x) ≡ (ax + b) \ mod \ 26$<br>解密函数：<br>$D(x) ≡ a^{-1} (x - b) \ mod \ 26$</p>
<h3><span id="多表替换密码">多表替换密码</span></h3><h4><span id="维吉尼亚密码">维吉尼亚密码</span></h4><p>首先拿到明文长度，然后将密钥长度扩展到明文长度，然后转化为数字映射，进行一一对应相加得到密文<br>解密时首先要得到key的长度，然后尝试得到key的具体内容才可以解密</p>
<h5><span id="维吉尼亚解密代码实现不一定准确只可以大致参考">维吉尼亚解密代码实现(不一定准确只可以大致参考)</span></h5><pre><code class="language-python">&#39;&#39;&#39;维吉尼亚破解&#39;&#39;&#39;
import numpy as np
import wordninja

def alpha(cipher): #预处理,去掉空格以及回车
    c = &#39;&#39;
    for i in range(len(cipher)):
        if(cipher[i].isalpha()):
            c += cipher[i]
    return c

def count_IC(cipher): #给定字符串计算其重合指数
    count = [0 for i in range(26)]
    L = len(cipher)
    IC = 0.0
    for i in range(len(cipher)):
        if(cipher[i].isupper()):
            count[ord(cipher[i])-ord(&#39;A&#39;)] += 1
        elif(cipher[i].islower()):
            count[ord(cipher[i])-ord(&#39;a&#39;)] += 1
    for i in range(26):
        IC += (count[i]*(count[i]-1))/(L*(L-1))
    return IC

def count_key_len(cipher,key_len): #对字符串按输入个数进行分组，计算每一组的IC值返回平均值
    N = [&#39;&#39; for i in range(key_len)]
    IC = [0 for i in range(key_len)]
    for i in range(len(cipher)):
        m = i % key_len
        N[m] += cipher[i]
    for i in range(key_len):
        IC[i] = count_IC(N[i])
    #print(IC)
    print(&quot;长度为%d时,平均重合指数为%.5f&quot; % (key_len,np.mean(IC)))
    return np.mean(IC)

def length(cipher): #遍历确定最有可能的密钥长度返回密钥长度
    key_len = 0
    mins = 100
    aver = 0.0
    for i in range(1,21): #假设密钥长度在1-20之间
        k = count_key_len(cipher,i)
        if(abs(k-0.065)&lt; mins):
            mins = abs(k-0.065)
            key_len = i
            aver = k
    print(&quot;密钥长度为%d,此时重合指数每组的平均值为%.5f&quot; % (key_len,aver))
    return key_len

def count_MIC(c1,c2,n): #n=k1-k2为偏移量,计算c1,c2互重合指数MIC
    count_1 = [0 for i in range(26)]
    count_2 = [0 for i in range(26)]
    L_1 = len(c1)
    L_2 = len(c2)
    MIC = 0
    for i in range(L_1):
        if(c1[i].isupper()):
            count_1[ord(c1[i])-ord(&#39;A&#39;)] += 1
        elif(c1[i].islower()):
            count_1[ord(c1[i])-ord(&#39;a&#39;)] += 1
    for i in range(L_2):
        if(c2[i].isupper()):
            count_2[(ord(c2[i])-ord(&#39;A&#39;)+n+26)% 26] += 1
        elif(c2[i].islower()):
            count_2[(ord(c2[i])-ord(&#39;a&#39;)+n+26)% 26] += 1
    for i in range(26):
        MIC += count_1[i]*count_2[i]/(L_1*L_2)
    return MIC

def count_n(c1,c2): #确定两个子串最优的相对偏移量n=k1-k2
    n = 0
    mins = 100
    k = [0.0 for i in range(26)]
    for i in range(26):
        k[i] = count_MIC(c1,c2,i)
        #print(i,k[i])  
        if(abs(k[i]-0.065)&lt;mins):
            mins = abs(k[i]-0.065)
            n = i
    return n

def  group_k(cipher,key_len):#完成分组操作并计算每一组与第一组的最优相对偏移量并返回
    N = [&#39;&#39; for i in range(key_len)]
    MIC = [0 for i in range(key_len)]
    s = [0 for i in range(key_len)]
    for i in range(len(cipher)): #对密文进行分组
        m = i % key_len
        N[m] += cipher[i]
    for i in range(1,key_len):  #计算与第一组之间的相对偏移量
        s[i] = count_n(N[0],N[i])  # s[i] = k1-k(i+1)
        MIC[i] = count_MIC(N[0],N[i],s[i])  # MIC[i] = MIC(1,i+1)
        print(&quot;第1组和第%d组之间偏移为%d时，互重合指数为%.5f&quot; % (i+1,s[i],MIC[i]))
    return s

def miyao(key_len,s,k):  #k为第一个子串的移位，输出密钥并返回密钥所有字母的下标
    mi = [&#39;&#39; for i in range(key_len)]
    for i in range(key_len):
        s[i] = -s[i]+k   #k2=k1-n
        mi[i] = chr((s[i]+26) % 26 + ord(&#39;a&#39;))
    print(&quot;第一个偏移量为%d,密钥为%s时&quot; % (k,mi))
    return s

def the_end(cipher,key_len,s):#输入密文密钥返回明文结果
    plain =&#39;&#39;
    i = 0
    while( i &lt; len(cipher)):
        for j in range(key_len):
            if(cipher[i].isupper()):
                plain += chr((ord(cipher[i])-ord(&#39;A&#39;)-s[j]+26) % 26 + ord(&#39;A&#39;))
            else:
                plain += chr((ord(cipher[i])-ord(&#39;a&#39;)-s[j]+26) % 26 + ord(&#39;a&#39;))
            i+=1
            if(i == len(cipher)):
                break
    # print(plain)
    return plain

if __name__ == &quot;__main__&quot;:
    fp = open(&quot;&quot;,&quot;r&quot;) #在这里填入密文文件路径
    cipher = &#39;&#39;
    for i in fp.readlines():
        cipher = cipher + i
    fp.close()
    cipher = alpha(cipher)
    key_len = length(cipher)
    s = group_k(cipher,key_len)
    m = s.copy()
    for k in range(26):
        s = m.copy()
        s = miyao(key_len,s,k)
        plain = the_end(cipher,key_len,s)
        print(plain[0:20]) #输出部分明文确定偏移量k1
    print(&quot;参考输出，请输入第一个子串的偏移量:&quot;,end=&#39;&#39;)
    k = int(input())
    m = miyao(key_len,m,k)
    plain = the_end(cipher,key_len,m)

    &#39;&#39;&#39;对英文文本进行分词&#39;&#39;&#39;
    word = wordninja.split(plain)
    plain = &#39;&#39;
    for i in range(len(word)):
        plain += word[i]
        plain += &#39; &#39;
    print(&quot;明文为\n&quot;+plain)
</code></pre>
<h3><span id="其他类型密码">其他类型密码</span></h3><h4><span id="rail-fence-cipher-栅栏密码">Rail-Fence Cipher 栅栏密码</span></h4><p>将明文分n栏(分为n组)，然后明文按顺序依次进入各栏，形成类W的形状，最后进行各栏的拼接得到密文。<br>解密直接进行爆破即可</p>
<h4><span id="baconian-cipher-培根密码">Baconian Cipher 培根密码</span></h4><p>一种替换密码，每个明文字母由五个字符序列替换，一般使用AB，也可用其他</p>
<h5><span id="培根密码表">培根密码表</span></h5><p>A aaaaa B aaaab<br>C aaaba D aaabb<br>E aabaa F aabab<br>G aabba H aabbb<br>I abaaa J abaab<br>K ababa L ababb<br>M abbaa N abbab<br>O abbba P abbbb<br>Q baaaa R baaab<br>S baaba T baabb<br>U babaa V babab<br>W babba X babbb<br>Y bbaaa Z bbaab</p>
<h5><span id="栅栏加密代码实现">栅栏加密代码实现</span></h5><pre><code class="language-python">def fence_password_encode():
    # 获取用户输入(添加输入合法性校验)
    while True:
        plaintext = input(&#39;请输入需要加密的明文：&#39;).strip()
        if not plaintext:
            print(&quot;错误：明文不能为空，请重新输入！&quot;)
            continue
        break

    while True:
        try:
            fence_count = int(input(&#39;请输入栅栏数(密钥)：&#39;).strip())
            if fence_count &lt;= 0:
                print(&quot;错误：栅栏数必须是正整数，请重新输入！&quot;)
                continue
            break
        except ValueError:
            print(&quot;错误：请输入有效的整数作为栅栏数！&quot;)
    
    ciphertext = &quot;&quot;
    plaintext_len = len(plaintext)  # 提前计算长度，避免重复调用
    
    # 遍历每个栅栏(按栏索引循环)
    for fence_idx in range(fence_count):
        # 遍历当前栅栏的每个位置(步长为栅栏数)
        for char_idx in range(fence_idx, plaintext_len, fence_count):
            ciphertext += plaintext[char_idx]
    
    print(f&quot;\n加密完成！密文为：{ciphertext}&quot;)
    return ciphertext

if __name__ == &#39;__main__&#39;:
    fence_password_encode()
</code></pre>
<h5><span id="栅栏解密代码实现">栅栏解密代码实现</span></h5><pre><code class="language-python">import sys

def fence_password_brute_force():
    # 校验命令行参数
    if len(sys.argv) &lt; 2:
        print(&quot;-----------------------------------------------&quot;)
        print(&quot; &quot;)
        print(f&quot;Usage: python {sys.argv[0]} &lt;fence_encrypted_string&gt;&quot;)
        print(&quot;Example: python fence_Passwd_burst.py &#39;hloolelwrd&#39;&quot;)
        print(&quot; &quot;)
        print(&quot;说明：自动爆破2到密文长度-1之间的所有可能栅栏数&quot;)
        print(&quot;-----------------------------------------------&quot;)
        return

    # 获取密文并处理
    ciphertext = sys.argv[1].strip()
    ciphertext_len = len(ciphertext)

    # 校验密文有效性
    if ciphertext_len &lt; 2:
        print(&quot;错误：密文长度不能小于2，请输入有效的密文！&quot;)
        return

    # 生成所有可能的栅栏数(原逻辑：仅保留能整除密文长度的；补充：增加非整除情况，更全面)
    # 原逻辑保留：step 能整除密文长度(避免部分情况漏解)
    possible_steps = [
        step for step in range(2, ciphertext_len)
        if ciphertext_len % step == 0
    ]

    # 补充：添加不能整除的常见栅栏数(部分场景下栅栏数无需整除长度，原代码逻辑较局限)
    # 避免因密文长度非栅栏数倍数导致漏解，保留前N个常见值(平衡效率与全面性)
    additional_steps = [
        step for step in range(2, ciphertext_len)
        if ciphertext_len % step != 0
    ][:5]  # 最多补充5个，避免输出过多冗余
    possible_steps += additional_steps
    possible_steps = list(sorted(set(possible_steps)))  # 去重并排序

    # 无可能栅栏数的异常处理
    if not possible_steps:
        print(&quot;未找到可能的栅栏数，无法爆破！&quot;)
        return

    # 遍历所有可能的栅栏数进行解密
    print(f&quot;\n开始爆破(共{len(possible_steps)}种可能栅栏数)：&quot;)
    print(&quot;-&quot; * 50)
    for step in possible_steps:
        plaintext = &quot;&quot;
        # 按栅栏数拆分并重组(核心解密逻辑)
        for i in range(step):
            # 从索引i开始，步长为step，提取当前栅栏的所有字符
            plaintext += ciphertext[i::step]
        print(f&quot;栅栏数 {step:2d} | 解密结果：{plaintext}&quot;)
    print(&quot;-&quot; * 50)
    print(&quot;爆破完成！请根据语义判断正确结果～&quot;)

if __name__ == &#39;__main__&#39;:
    fence_password_brute_force()
</code></pre>
<h2><span id="现代密码">现代密码</span></h2><h3><span id="不同分类">不同分类</span></h3><h4><span id="按照密钥的特性进行分类">按照密钥的特性进行分类</span></h4><p>对称密码(AES，RC4)         速度快，密钥分发难<br>非对称密码(RSA，ECC)       密钥分发易，速度慢<br>混合密码(HTTPS)            结合两者优势，主流</p>
<h4><span id="按照功能分类">按照功能分类</span></h4><p>数据加密(AES，RSA)         保机密性<br>数字签名(ECDSA，EdDSA)     保完整+认证+不可否认<br>密钥交换(ECDH，TLS，ECDHE) 安全协商对称密钥<br>消息认证(HMAC，CMAC)       保完整+认证(无不可否认)</p>
<h4><span id="按照抗量子能力">按照抗量子能力</span></h4><p>传统密码(RSA，ECC)         抗经典，不抗量子<br>后量子密码(Kyber，Di)      抗量子，未来核心</p>
<h3><span id="对称密码">对称密码</span></h3><p>对称密码可以分为两大类：序列密码(流密码)和分组密码(块密码)<br>序列密码：生成与明文长度相同的密钥流(由密钥生成器产生)，逐位(或逐字节)加密，将明文与密钥流逐位异或<br>分组密码：将明文分成固定长度的组，每组独立加密，用同一密钥对每组明文加密，密钥长度固定</p>
<p>现代密码学设计密码算法一般遵循两个原则：<br>混淆：模糊明文和密文的关系，尝试用替换的方式实现<br>扩散：将明文中一位的影响扩散到多个密文，尝试用置换的方式实现<br>现代密码学中通常使用多轮运算，每一轮中会有若干层混淆变换和扩散变换</p>
<h4><span id="序列密码-rc4rivest-cipher-4-李维斯特密码4">序列密码-RC4(Rivest Cipher 4 李维斯特密码4)</span></h4><p>RC4 的核心分为两大阶段：S 盒初始化(KSA)和伪随机流生成(PRGA)</p>
<h5><span id="s盒初始化ksa">S盒初始化(KSA)</span></h5><p>首先S盒填充为0到255的连续字节<br>S[i] &#x3D; i<br>同时维护一个辅助数组k，将密钥key循环填充到k中<br>K[i] &#x3D; Key[i mod len(Key)]</p>
<pre><code class="language-python">j = 0
for i in range(256):
    j = (j + S[i] + K[i]) % 256
    # 计算交换索引j
    swap(S[i], S[j])
    # 交换S[i]和S[j]
</code></pre>
<h5><span id="伪随机流生成prga">伪随机流生成(PRGA)</span></h5><p>初始化索引：设两个初始索引i &#x3D; 0，j &#x3D; 0<br>逐字节生成密钥流：对每一个明文字节，执行：<br>i &#x3D; (i + 1) mod 256<br> #i递增1并取模256<br>j &#x3D; (j + S[i]) mod 256<br> #用S[i]更新j<br>swap(S[i], S[j])<br> #再次交换S盒元素，保证随机性<br>t &#x3D; (S[i] + S[j]) mod 256<br> #计算中间值t<br>Keystream_byte &#x3D; S[t]<br> #从S盒中取一个字节作为密钥流字节</p>
<p>将生成的Keystream_byte与明文（或密文）字节异或，得到密文（或明文）</p>
<h5><span id="序列密码-rc4加解密代码实现">序列密码-RC4加解密代码实现</span></h5><pre><code class="language-python">def rc4(key: bytes, data: bytes) -&gt; bytes:
    # 1. KSA：初始化S盒
    S = list(range(256))
    j = 0
    key_len = len(key)
    # 填充K数组并打乱S盒
    for i in range(256):
        j = (j + S[i] + key[i % key_len]) % 256
        S[i], S[j] = S[j], S[i]

    # 2. PRGA：生成密钥流并异或
    i = j = 0
    result = []
    for byte in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        t = (S[i] + S[j]) % 256
        keystream_byte = S[t]
        # 异或得到结果
        result.append(byte ^ keystream_byte)
    return bytes(result)

 #测试：加密和解密
key = b&quot;secret_key_123&quot;  # 密钥（ bytes类型）
plaintext = b&quot;Hello, RC4!&quot;  # 明文

ciphertext = rc4(key, plaintext)
decrypted_text = rc4(key, ciphertext)

print(&quot;密文（十六进制）:&quot;, ciphertext.hex())  # 输出密文（十六进制格式）
print(&quot;解密后明文:&quot;, decrypted_text.decode(&quot;utf-8&quot;))  # 输出：Hello, RC4!
</code></pre>
<h4><span id="序列密码-otpone-time-pad-一次一密">序列密码-OTP(One Time Pad 一次一密)</span></h4><p>将明文所有字符转化为八位二进制，然后随机生成和密文等长的密钥流，将明文和密钥流进行异或得到密文</p>
<h5><span id="otp加密代码实现">OTP加密代码实现</span></h5><pre><code class="language-python">import os

def otp_encrypt(plaintext: bytes, key: bytes) -&gt; bytes:
    &quot;&quot;&quot;
    使用一次一密(OTP)加密明文。
    :param plaintext: 明文数据(字节序列)
    :param key: 密钥(字节序列)
    :return: 密文(字节序列)
    &quot;&quot;&quot;
    if len(plaintext) != len(key):
        raise ValueError(&quot;密钥长度必须与明文长度相同&quot;)
    return bytes([p ^ k for p, k in zip(plaintext, key)])

def otp_decrypt(ciphertext: bytes, key: bytes) -&gt; bytes:
    &quot;&quot;&quot;
    使用一次一密(OTP)解密密文。
    :param ciphertext: 密文数据(字节序列)
    :param key: 密钥(字节序列)
    :return: 解密后的明文(字节序列)
    &quot;&quot;&quot;
    if len(ciphertext) != len(key):
        raise ValueError(&quot;密钥长度必须与密文长度相同&quot;)
    return bytes([c ^ k for c, k in zip(ciphertext, key)])

 #示例使用
plaintext = b&quot;Hello, OTP!&quot;
key = os.urandom(len(plaintext))  # 生成与明文等长的随机密钥

 #加密
ciphertext = otp_encrypt(plaintext, key)
print(&quot;密文:&quot;, ciphertext)

 #解密
decrypted_text = otp_decrypt(ciphertext, key)
print(&quot;解密后的明文:&quot;, decrypted_text)
</code></pre>
<h5><span id="otp解密方式一">OTP解密方式一</span></h5><p>得到完整的密钥流，不完整也无法进行解密</p>
<h5><span id="otp解密方式二可实现率极低">OTP解密方式二(可实现率极低)</span></h5><p>有多个加密后的密文(即同一个密钥流不断加密得到各阶段的密文)</p>
<h6><span id="解密原理一">解密原理一</span></h6><p>$c1 ⊕ c2 &#x3D; ( p1 ⊕ k) ⊕ ( p2 ⊕ k ) &#x3D; p1 ⊕ p2 ⊕ k ⊕ k &#x3D; p1 ⊕ p2$  (k的加密效果抵消)</p>
<h6><span id="解密原理二">解密原理二</span></h6><p>对于一个小写字母与space异或结果为大写字母，反之亦然</p>
<h6><span id="例题">例题</span></h6><pre><code class="language-python">c0=&quot;315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0&quot; c1=&quot;234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d&quot; c2=&quot;32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b&quot;
c3=&quot;32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197&quot; c4=&quot;3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade&quot; c5=&quot;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee71497&quot; c6=&quot;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148d&quot; c7=&quot;315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40ce0fff9e00fa1439f&quot; c8=&quot;271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a&quot; c9=&quot;466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138&quot;

#for each ciphertext
for current_index,ciphertext in enumerate (ciphers):

    counter = collections.Counter()
    # for each other ciphertext 
    for index,ciphertext2 in enumerate (ciphers):
        if current_index != index: # don&#39;t xor a ciphertext with itself
            for indexOfChar,char in enumerate(strxor(ciphertext.decode(&#39;hex&#39;),ciphertext2.decode(&#39;hex&#39;))): # XOR the two ciphertexts
                # if a chracter in the xored result is a alphabetic character, it means was probably a space character in one of the two plaintexts(we don&#39;t know which one)
                if char in string.printable and char.isalpha(): counter[indexOfChar] +=1
    knownSpaceIndexes = () 

    # loop through all positions where a space character was possible in the current_index ciphertext
    for ind,val in counter.items():
        # if a space character was found at least 7 times at this index out of the 9 possible XORS， then the space character was likely from the current_index ciphertext!
        if val &gt;=7: knownSpaceIndexes.append(ind)
        # print knownSpaceIndexes # Shows all the positions where we now know the key!

        # now xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!
        xor_with_spaces = strxor(ciphertext.decode(&#39;hex&#39;), &#39; &#39; * 150)
        for index in knownSpaceIndexes:
            # stoe the key&#39;s value at the correct position
            final_key[index] = xor_with_spaces[index].encode(&#39;hex&#39;)
            # record that we know the key at this position
            know_key_positions.add(index)
</code></pre>
<h4><span id="序列密码-lcglinear-congruential-generator-线性同余生成器">序列密码-LCG(Linear Congruential Generator 线性同余生成器)</span></h4><p>LCG生成伪随机数满足递推式： $X_{n+1} ≡ AX_n + B \ (mod \ M)$  其中A，B，M为常数且需要$X_0$作为种子<br>由此递推式生成伪随机数序列得到密钥流，再逐字节进行异或加密得到密文</p>
<h5><span id="解密前置知识">解密前置知识</span></h5><h6><span id="同余运算简单性质">同余运算简单性质</span></h6><p>$a \pm c ≡ b \pm c \ (mod \ m)$<br>$a \times c ≡ b \times c \ (mod \ m)$<br>$a ≡ b \ (mod \ m),b ≡ c \ (mod \ m) ➡ a ≡ c \ (mod \ m)$</p>
<h6><span id="逆相关运算">逆相关运算</span></h6><p>$a ÷ b ≡ c \ (mod \ m) ⬅➡ a \times b^{-1} ≡ c \ (mod \ m)$<br>$b \times b^{-1} ≡ 1 \ (mod \ m)$<br>注意：不是所有情况都存在逆，只有m与b互质是才存在逆</p>
<h5><span id="lcg解密方式一">LCG解密方式一</span></h5><p>在已知常数A，B，M的前提下，若能捕捉到LCG生成的一个输出，则可以恢复出状态，并通过递推式预测之后产生的所有随机数</p>
<p>$X_{n+1} ≡ A X_n + B \ (mod \ M)$ ➡ $X_n ≡ (X_{n+1} - B)A^{-1} \ (mod \ M)$</p>
<p>通过递推可以得到初始种子$X_0$以及后续所有组成密钥流</p>
<h5><span id="lcg解密方式二">LCG解密方式二</span></h5><p>在未知A，B，已知M的情况下，若能捕捉到LCG生成的连续两个输出，可以通过建立方程求解A，B得到递推公式</p>
<p>联立方程组：<br>$X_{n+1} ≡ A X_n + B \ (mod \ M)$<br>$X_{n+2} ≡ A X_{n+1} + B \ (mod \ M)$</p>
<p>解出A，B<br>$A ≡ ( X_{n+2} - X_{n+1} )( X_{n+1} - X_n )^{-1} \ (mod \ M)$<br>$B ≡ X_{n+1} - A X_n \ (mod \ M)$</p>
<p>后续递推密钥流即可</p>
<h5><span id="lcg例题">LCG例题</span></h5><h6><span id="lcg例题题目">LCG例题题目</span></h6><pre><code class="language-python">from hashlib import sha256
from Crypto.Util.number import *
import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
flag = b&#39;xxx&#39;
def step(x,y,p):
    return (5*y + 7)%p,(11*x + 13)%p

p = getPrime(64)
x,y = random.randint(0,p),random.randint(0,p)

key = sha256(str(x).encode() + str(y).encode()).digest()[:16]

cipher = AES.new(key, AES.MODE_ECB)
ct = cipher.encrypt(pad(flag,16))

ots = [x**2*y**2%p]
k = 10
for i in range(k):
    for j in range(10):
        x,y = step(x,y,p)
    ots.append(x**2*y**2%p)
print(&quot;ct =&quot;,ct.hex())
print(&quot;p =&quot;,p)
print(&quot;ots =&quot;,ots)

# ct = eedac212340c3113ebb6558e7af7dbfd19dff0c181739b530ca54e67fa043df95b5b75610684851ab1762d20b23e9144
# p = 13228731723182634049
# ots = [10200154875620369687, 2626668191649326298, 2105952975687620620, 8638496921433087800, 5115429832033867188, 9886601621590048254, 2775069525914511588, 9170921266976348023, 9949893827982171480, 7766938295111669653, 12353295988904502064]
</code></pre>
<h6><span id="lcg例题解题代码">LCG例题解题代码</span></h6><pre><code class="language-python">from hashlib import sha256
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Util.number import inverse
import sympy as sp

p = 13228731723182634049
ots = [10200154875620369687, 2626668191649326298, 2105952975687620620,8638496921433087800, 5115429832033867188, 9886601621590048254,2775069525914511588, 9170921266976348023, 9949893827982171480,7766938295111669653, 12353295988904502064]
ct = bytes.fromhex(&quot;eedac212340c3113ebb6558e7af7dbfd19dff0c181739b530ca54e67fa043df95b5b75610684851ab1762d20b23e9144&quot;)

# 一步迭代的线性变换矩阵（含常数项）
# [x&#39;]   [0  5  7] [x]
# [y&#39;] = [11 0 13] [y]
# [1 ]   [0  0  1] [1]
M = [[0, 5, 7], [11, 0, 13], [0, 0, 1]]

def mat_mul(A, B, mod):
    return [[sum(A[i][k] * B[k][j] for k in range(3)) % mod for j in range(3)] for i in range(3)]

def mat_pow(M, e, mod):
    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    B = [row[:] for row in M]
    while e &gt; 0:
        if e &amp; 1:
            R = mat_mul(R, B, mod)
        B = mat_mul(B, B, mod)
        e //= 2
    return R

# 10 步合并成一次变换
M10 = mat_pow(M, 10, p)
(a1, b1, c1), (a2, b2, c2), _ = M10

def tonelli(n, p):
    if n == 0:
        return 0
    if pow(n, (p - 1) // 2, p) != 1:
        print(&quot;No square root exists&quot;)
        return None
    if p % 4 == 3:
        return pow(n, (p + 1) // 4, p)
    q = p - 1
    s = 0
    while q % 2 == 0:
        s += 1
        q //= 2
    z = 2
    while pow(z, (p - 1) // 2, p) != p - 1:
        z += 1
    c = pow(z, q, p)
    x = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    while t != 1:
        i = 1
        t2 = pow(t, 2, p)
        while t2 != 1:
            t2 = pow(t2, 2, p)
            i += 1
        b = pow(c, 1 &lt;&lt; (m - i - 1), p)
        x = (x * b) % p
        t = (t * b * b) % p
        c = (b * b) % p
        m = i
    return x

# 计算 ots[0] 和 ots[1] 的平方根
s0_root = tonelli(ots[0], p)
s1_root = tonelli(ots[1], p)

# 两个平方根分支
s0_candidates = {s0_root, (-s0_root) % p}
s1_candidates = {s1_root, (-s1_root) % p}

x = sp.Symbol(&#39;x&#39;)
solutions = []

# 由 s0, s1 构造四次方程，解出 x0
for s0 in s0_candidates:
    for s1 in s1_candidates:
        A1, B1, C1 = a1 % p, c1 % p, (b1 * s0) % p
        A2, B2, C2 = a2 % p, c2 % p, (b2 * s0) % p
        k4 = (A1 * A2) % p
        k3 = (A1 * B2 + A2 * B1) % p
        k2 = (A1 * C2 + A2 * C1 + B1 * B2 - s1) % p
        k1 = (B1 * C2 + B2 * C1) % p
        k0 = (C1 * C2) % p

        poly = sp.Poly(k4 * x**4 + k3 * x**3 + k2 * x**2 + k1 * x + k0, x, modulus=p)
        coeff, factors = sp.factor_list(poly, modulus=p)

        for f, _ in factors:
            if f.degree() == 1:
                a, b = f.all_coeffs()
                r = (-b * sp.invert(a, p)) % p
                solutions.append((s0, s1, int(r)))
            elif f.degree() == 2:
                a, b, c = f.all_coeffs()
                a, b, c = int(a), int(b), int(c)
                d = (b * b - 4 * a * c) % p
                r1 = tonelli(d, p)
                if r1 is not None:
                    inv2a = inverse(2 * a, p)
                    r = ((-b + r1) * inv2a) % p
                    solutions.append((s0, s1, int(r)))
                    r = ((-b - r1) * inv2a) % p
                    solutions.append((s0, s1, int(r)))


def step10(x, y):
    v = [x, y, 1]
    v2 = [
        (M10[i][0] * v[0] + M10[i][1] * v[1] + M10[i][2] * v[2]) % p
        for i in range(3)
    ]
    return int(v2[0]), int(v2[1])

# 验证所有候选并解密
valid = []
for s0, s1, x0 in solutions:
    if x0 % p == 0:
        continue
    y0 = (s0 * inverse(x0, p)) % p
    x, y = x0, y0
    ok = True
    if (x * x * y * y) % p != ots[0]:
        ok = False
    else:
        for idx in range(1, len(ots)):
            x, y = step10(x, y)
            if (x * x * y * y) % p != ots[idx]:
                ok = False
                break
    if ok:
        valid.append((x0, y0))

for x0, y0 in valid:
    key = sha256(str(x0).encode() + str(y0).encode()).digest()[:16]
    flag = AES.new(key, AES.MODE_ECB).decrypt(ct)
    try:
        print(unpad(flag, 16))
    except Exception:
        pass
</code></pre>
<h4><span id="序列密码-lfsrlinear-feedback-shift-register-线性反馈移位寄存器">序列密码-LFSR(Linear Feedback Shift Register 线性反馈移位寄存器)</span></h4><p>我们将LFSR中的寄存器个数称为LFSR的级数，一个n级的LFSR最多可存储 $2^n$ - 1 种状态<br>在n个寄存器中，依次有状态$S_1$，$S_2$,···，$S_n$，向右移位则$S_n$输出为密钥流的第一项<br>$S_1$空缺由线性反馈函数 $f(S_1, S_2, S_3, S_4)$ 的处理结果补上<br>以此类推不断进行得到密钥流 (一般情况下会有循环周期效果，周期数 k ≤ $2^n$ - 1)<br>由反馈函数决定循环周期</p>
<h5><span id="lfsr线性反馈函数">LFSR线性反馈函数</span></h5><p>函数由状态$s$以及推头$m$组成，构成函数<br>$f(s_{n+1}) &#x3D; (s_1 \times m_1)⊕(s_2 \times m_2)⊕···⊕(s_n \times m_n)$<br>推头可以简单理解为0和1组成，决定该位置状态是否参与函数的运算</p>
<h5><span id="lfsr解密方式一">LFSR解密方式一</span></h5><p>在已知 LFSR 反馈函数的前提下，如果已知连续 n 位明文和 n 位密文，则可以计算得出 n 位密钥，即为 LFSR 的一个状态<br>此时根据反馈函数，即可计算出 LFSR 的全部输出，即全部密钥密钥流，从而破解 LFSR</p>
<h5><span id="lfsr解密方式二">LFSR解密方式二</span></h5><p>在未知 LFSR 反馈函数前提下，若获取2n位的明文和密文，计算得出2n位的密钥$[k_1,k_2,···,k_{2n}]$<br>这2n位密钥中有LFSR的n+1种状态，分别为$[k_1,k_2,···,k_{n}]$，$[k_2,k_2,···,k_{n+1}]$，··· $[k_{n+1},k_{n+2},···,k_{2n}]$<br>这些状态之间存在着互相递推关系，例如$k_{n+1}$就是由$[k_1,k_2,···,k_{n}]$计算出来的<br>以此类推，$k_{n+i}$ 就是由 $[k_i,k_{i+1},···,k_{i+n-1}]$ 计算得出，从而得到n个线性方程，进行矩阵运算接口解出反馈函数</p>
<h4><span id="分组密码-desdata-encryption-standard-数据加密标准">分组密码-DES(Data Encryption Standard 数据加密标准)</span></h4><p>DES块长度为64位，密钥长度为64位(其中8位为校验位，实际有效56位)，明文64位分组加密得到64位密文<br>DES对明文进行16轮加密运算，每一轮都有一个相应的子密钥参与(子密钥由密钥扩展算法计算得出)<br>此外，开头和结尾分别有初始置换和最终置换的操作</p>
<h5><span id="des加密初始置换和最终置换">DES加密初始置换和最终置换</span></h5><p>就是简单根据置换表，把长度为64比特的block每一个位置进行变换</p>
<h6><span id="初始置换initial-permutation代码实现">初始置换(Initial Permutation)代码实现</span></h6><pre><code class="language-python">IP_table=
[
    58,50,42,34,26,18,10,2,
    60,52,44,36,28,20,12,4,
    62,54,46,38,30,22,14,6,
    64,56,48,40,32,24,16,8,
    57,49,41,33,25,17,9,1,
    59,51,43,35,27,19,11,3,
    61,53,45,37,29,21,13,5,
    63,55,47,39,31,23,15,7,
]

def IP(block):
    result=[]
    for i in range(len(IP_table)):
        result.append(block[IP_table[i]-1])
    return result

###### 最终置换(Final Permutation)代码实现

FP_table=
[
    40,8,48,16,56,24,64,32,
    39,7,47,15,55,23,63,31,
    38,6,46,14,54,22,62,30,
    37,5,45,13,53,21,61,29,
    36,4,44,12,52,20,60,28,
    35,3,43,11,51,19,59,27,
    34,2,42,10,50,18,58,26,
    33,1,41,9,49,17,57,25,
]

def FP(block):
    result = []
    for i in range(len(FP_table)):
        result.append(block[FP_table[i]-1])
    return result
</code></pre>
<h5><span id="des密钥扩展算法">DES密钥扩展算法</span></h5><p>通过PC-1置换去除64比特密钥中的校验位<br>将56比特的密钥分成28比特<br>连续16轮运算，每一轮分别先对左右两半循环移位，再经过PC-2置换生成一个48比特的子密钥<br>最终得到16组48比特的子密钥</p>
<h6><span id="des密钥扩展算法代码实现">DES密钥扩展算法代码实现</span></h6><pre><code class="language-python">subkey=[]
if len(bkey)== 64:
    #PC-1
    bkey = PC_1(bkey)
eliflen(bkey) = 56:
    raise ValueError(&quot;key must be 56-bit or 64-bit in length&quot;)
 #divide the block into two halves
Ci, Di = bkey[:28], bkey[28:]
for i in range(16):
    #Left Rotation
    Ci, Di = LR(Ci, Di, i)
    #PC-2
    subkey.append(PC_2(Ci + Di))
return subkey
</code></pre>
<h5><span id="des加密轮函数feistel-function-费斯妥函数">DES加密轮函数(Feistel Function 费斯妥函数)</span></h5><p>先通过Expansion将32比特输入扩展成48比特<br>再与48比特的子密钥混合作异或运算<br>然后48比特分别分为8组，每组6比特，经过S盒替换，输出8组4比特，即32比特<br>最后对这32比特依据一张固定的置换表进行移位置换P</p>
<h6><span id="des加密轮函数代码实现">DES加密轮函数代码实现</span></h6><pre><code class="language-python">def Feistel(HalfBlock, subkey):
    eHalfBlock = Expansion(HalfBlock)
    xHalfBlock = BlockXor(eHalfBlock, subkey)
    sHalfBlock = Substitution(xHalfBlock)
    return Permutation(sHalfBlock)
</code></pre>
<h5><span id="des加密过程">DES加密过程</span></h5><p>将分块后的明文(64位)先进行初始置换，再分为左右两块$L_0,R_0$(32位)<br>在每一轮中进行下列运算(总共进行16轮)：<br>$L_{i+1} &#x3D; R_i$<br>$R_{i+1} &#x3D; L_i ⊕ F(R_i,K_i)$ (F为轮函数)<br>将$R_{16},L_{16}$进行交换拼接，进行最后置换得到64位密文</p>
<h6><span id="des加密代码实现">DES加密代码实现</span></h6><pre><code class="language-python"> #Initial permutation
m = IP(m)
 #divide the block into two 32-bit halves
Li, Ri = m[:32], m[32:]
 #16 rounds
for i in range(16):
    Li, Ri = Ri, BlockXor(Li, Feistel(Ri, subkey[i]))
 #merge the two divided half block which is 32-bit into one 64-bit block
m = Ri + Li # There is a need to change order of the final two halves
 #Final permutation
m = FP(m)
</code></pre>
<h5><span id="des加解密代码实现">DES加解密代码实现</span></h5><pre><code class="language-python">from Crypto.Cipher import DES

key = &#39;&#39;
des = DES.new(key,DES.MODE_ECB)
plaintext = b&#39;&#39;

cipher = des.encrypt(plaintext)
des.decrypt(cipher)
</code></pre>
<h6><span id="des解密方式一">DES解密方式一</span></h6><p>在已知密文和16个子密钥的情况下，由于轮函数以及置换的可逆性，仅需要在轮函数作用时使用逆序的子密钥即可</p>
<h4><span id="分组密码-aesadvanced-encryption-standard-高级加密标准">分组密码-AES(Advanced Encryption Standard 高级加密标准)</span></h4><p>AES算法的块长度为128位，不同密钥长度分别有不同加密轮数<br>128位密钥对应10轮，192位密钥对应12轮，256位密钥对应14轮<br>AES每一轮直接对整个128位进行加密，使用算法层进行加密</p>
<h5><span id="aes算法层加密">AES算法层加密</span></h5><p>AES128位(16字节)首先按照从左向右，从上到下排成一个4\times4的矩阵<br>先对密钥k进行扩展得到子密钥用于密钥加法层处理，其中$k_0$先对明文进行密钥加法层处理，后续$k_n$进行第n轮密钥加法层处理<br>随后直到n-1轮都进行字节代换层➡扩散层(由Shift Rows层和Mix Column层构成)➡密钥加法层<br>最后一轮删去Mix Column层处理，其余不变，得到最后密文</p>
<h6><span id="aes加密算法框架代码实现">AES加密算法框架代码实现</span></h6><pre><code class="language-python">#start
r=0
k_sch=self.subkeys[0] + self.subkeys[1] + self.subkeys[2] + self.subkeys[3]

state = list(msg)
AES.add_round_key(state,k_sch)

 #round 1~rounds&#39;-1
for r in range(1,self.rounds):
    AES.sub_bytes(state)
    AES.shift_rows(state)
    AES.mix_columns(state)
    k_sch=self.subkeys[4*r] + self.subkeys[4*r+1] + self.subkeys[4*r+2] + self.subkeys[4*r+3]
    AES.add_round_key(state,k_sch)

 #the last round
r = self.rounds
AES.sub_bytes(state)
AES.shift_rows(state)
k_sch=self.subkeys[-4] + self.subkeys[-3] +self.siubkeys[-2] + self.subkeys[-1]
AES.add_round_key(state,k_sch)

 #convert &#39;list&#39;stateto&#39;bytes&#39;output
output=bytes(state)
return output

###### AES算法层-字节代换层

让输入的每一个字节，通过S盒代换(映射)到另外一个字节
此处的S盒是可以经过每种方式计算出来的，也可以直接使用计算好的进行代换

@staticmethod
def sub_bytes(s):
    for i in range(16):
        s[i] = AES.Sbox[s[i]]
</code></pre>
<h6><span id="aes算法层-扩散层">AES算法层-扩散层</span></h6><p>行移位层(Shift Rows层)<br>对于4\times4的矩阵，在做行移位时，第一行保持不变，第二行往左移动一格，第三行左移两格，第四行左移三格</p>
<p>行混淆层(Mix Column层)<br>将整个字节矩阵乘上一个列混淆矩阵(有限域上的矩阵运算)<br>相当于正常矩阵运算结果取模</p>
<pre><code class="language-python">@staticmethod
def shift_rows(s):
    s[i] = list(s[0::5] + s[4::5] + s[3:4:5] + s[8::5] + s[2:8:5] +s[12::5] + s[1:12:5])

@staticmethod
def mix_columns(s):
    def xtime(a):
        return((((a &lt;&lt; 1) ^ 0x1B) &amp; 0XFF) if (a &amp; 0x80) else (a &lt;&lt;1))

    for i in range(4):
        t=s[4*i] s[4*i+1] ^s[4*i+2]^s[4*i+3]
        u=s[4*i]
        s[4*i] ^=t xtime(s[4*i] ^ s[4*i+1])
        s[4*i+1] ^= t xtime(s[4*i+1] ^ s[4*i+2])
        s[4*i+2] ^= t xtime(s[4*i+2] ^ s[4*i+3])
        s[4*i+3] ~ t xtime(s[4*i+3] ^ u)
</code></pre>
<h6><span id="aes算法层-密钥加法层">AES算法层-密钥加法层</span></h6><p>输入16字节的明文和子密钥，对这两个输入逐字节异或，并将异或结果输出</p>
<pre><code class="language-python">@staticmethod
def add_round_key(s, k):
    for i in range(16):
        s[i] ^= k[i]
</code></pre>
<h6><span id="aes密钥扩展算法">AES密钥扩展算法</span></h6><p>以标准128位密钥，对应共有11组子密钥，反别在一开始盒每一轮(共十轮)中参与轮密钥加法层运算<br>子密钥的生成是以列为单位，一列4字节32比特构成一个字(word)，四个字拼接成一个子密钥</p>
<p>$k[0]$的生成<br>将密钥同样从左到右，从上到下排列为一个矩阵，第一列$k_1,k_2,k_3,k_4$为$w_0$<br>$w_0,w_1,w_2,w_3$拼接构成$k[0]$</p>
<p>$k[1],k[2]···k[n]$的生成<br>首先存在G函数接收$w_3$的结果，其输出与$w_0$进行异或得到$w_4$，然后$w_1$与$w_4$异或得到$w_5$<br>以此类推得到$w_4,w_5,w_6,w_7$拼接得到$k[1]$<br>$w_4,w_5,w_6,w_7$重复上述过程即可，以此类推拿到所有子密钥</p>
<p>G函数<br>将输入的w分成四块(每块1字节)$B_1,B_2,B_3,B_4$<br>将每个字节进行向循环左移一位<br>逐字节经过S盒进行代换<br>用第一个字节盒轮系数进行异或运算(实际上是四个字节整体与轮常量异或，但是常量后续三个字节都是0)</p>
<pre><code class="language-python">@staticmethod
defkey_expansion(k,r):
 #fips-197 Figure 11
    k = list(k) # in case k is bytes
    Nk = len(k) // 4
    subkeys=[k[i:i+4]foriinrange(0,4*Nk,4*Nk,4)]

    i = Nk
    while i &lt; 4*(r+1):
        t=subkeys[i-1]
    if i % Nk == 0:
        tt=AES.sub_word(AES.rot_word(t))
        t=[tt[0] ^AES.Rcon[i // Nk]] + tt[1:]
    elif Nk &gt; 6 and i % Nk == 4:
        t = AES.sub_word(t)
    subkeys.append(AES.word_xor(subkeys[i - Nk], t))
    i += 1
return subkeys
</code></pre>
<h5><span id="aes加解密代码实现">AES加解密代码实现</span></h5><pre><code class="language-python">from Crypto.Cipher import AES

key = b&quot;&quot;
aes = AES.new(key,mode=AES.MODE_ECB)
plaintext = b&quot;&quot;

ciphertext = aes.encrypt(plaintext)
aes.decrypt(ciphertext)

##### AES例题一

import time
import random
from Crypto.Cipher import AES
from Crypto.Util.number import *

random.seed(int(time.time())) #抽取当前时间的时间戳转化成int类型作为随机数生成的种子seed
key = long_to_bytes(random.getrandbits(128)) #用函数生成一个128位的整数并转化为字节形式得到一个16字节

aes=AES.new(key, mode=AES.MODE_ECB)
cipher= aes.encrypt(flag)
with open(&quot;cipher&quot;, &quot;wb&quot;) as f:
    f.write(cipher)
 #AES加密是难以爆破的，我们一般只可以取找key
 #由于random算法的固定，所以直接找到时间戳就可以拿到key
</code></pre>
<h4><span id="分组密码-分组模式">分组密码-分组模式</span></h4><p>分组密码算法只能加密固定长度的分组，当我们加密的明文长度超过块长度时，需要分组密码算法迭代以全部加密<br>而不同的分组密码算法分组就是分组密码的模式(mode)</p>
<p>常见的分组模式有如下几种:<br>ECB模式:Electronic Code Book mode(电子密码本模式)<br>CBC模式:Cipher Block Chaining mode(密码分组链接模式)<br>CFB模式:Cipher FeedBack mode(密文反馈模式)<br>OFB模式:Output FeedBack mode (输出反馈模式)<br>CTR模式:CounTeR mode (计数器模式)<br>GCM模式:Galois&#x2F;Counter Mode(伽罗瓦&#x2F;计数器模式)</p>
<p>分组密码迭代加密要求每一个明文分组都是块长度(8或16字节)<br>当分组到最后一组时，其长度不足块长度，就需要对其进行填充，将长度扩展为块长度</p>
<p>常见的填充方式有如下几种:<br>补零:在末尾补上0x00字节<br>… | DD DD DD DD DD DD DD DD DD DD DD DD 00 00 00 00 00 |<br>字节填充:先填充0x00字节,直至最后一字节填充值为填充长度<br>… | DD DD DD DD DD DD DD DD DD DD DD DD 00 00 00 00 04 |<br>PKCS7填充:若需填充N个字节,则每个填充字节值都是N<br>… | DD DD DD DD DD DD DD DD | DD DD DD 04 04 04 04 04 |</p>
<h5><span id="分组模式-ecbelectronic-code-book-mode-电子密码本模式">分组模式-ECB(Electronic Code Book mode 电子密码本模式)</span></h5><p>最简单的分组方式，直接将明文分成固定的块大小，每个块进行独立且相同的加密，明文和密文一一对应</p>
<h6><span id="分组模式-ecb加解密代码实现">分组模式-ECB加解密代码实现</span></h6><pre><code class="language-python">from Crypto.Cipher import AES

def aes_ecb_encrypt(pt, key):
    aes=AES.new(key, AES.MODE_ECB)
    ct = aes.encrypt(pt)
    return ct
def aes_ecb_decrypt(ct, key):
    aes=AES.new(key,AES.MODE_ECB)
    pt=aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式-cbccipher-block-chaining-mode-密码分组链接模式">分组模式-CBC(Cipher Block Chaining mode 密码分组链接模式)</span></h5><p>首先一样先对明文进行分块填充，然后使用初始化向量IV对第一个明文块进行异或操作，然后进行加密<br>第一个加密得到密文在与第二块明文进行异或，随后第二块去加密，以此类推</p>
<h6><span id="分组模式-cbc加解密代码实现">分组模式-CBC加解密代码实现</span></h6><pre><code class="language-python">def aes_cbc_encrypt(pt, key,iv):
    aes=AES.new(key,AES.MODE_CBC, iv=iv=iv=iv)
    ct = aes.encrypt(pt)
    return ct

def aes_cbc_decrypt(ct, key,iv):
    aes=AES.new(key,AES.MODE_CBC, iv=iv=iv=iv)
    pt = aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式-cfbcipher-feedback-mode-密文反馈模式">分组模式-CFB(Cipher FeedBack mode 密文反馈模式)</span></h5><p>首先一样先对明文进行分块填充，然后对IV进行加密得到中间结果，将这个结果与第一块明文进行异或得到第一块密文<br>第一块密文进行加密得到中间结果，中间结果再与第二块明文异或，得到第二块密文，以此类推</p>
<h6><span id="分组模式-cfb加解密代码实现">分组模式-CFB加解密代码实现</span></h6><pre><code class="language-python">def aes_cfb_encrypt(pt, key,iv):
    aes=AES.new(key,AES.MODE_CFB, iv=iv=iv=iv)
    ct = aes.encrypt(pt)
    return ct

def aes_cfb_decrypt(ct, key,iv):
    aes=AES.new(key,AES.MODE_CFB, iv=iv=iv=iv)
    pt = aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式-ctrcounter-mode-计数器模式">分组模式-CTR(CounTeR mode 计数器模式)</span></h5><p>首先一样先对明文进行分块填充，然后对一个逐次累加的计数器进行加密得到中间结果(密钥流的流密码)<br>将这个结果与块明文进行异或得到块密文</p>
<h6><span id="分组模式-ctr计数器构造">分组模式-CTR计数器构造</span></h6><p>CTR每一次解密时，都会生成一个nonce(仅用一次的数)来作为计数器的初始值<br>计数器格式：前面字节为固定的nonce，后面字节为分组序号，会逐次累加</p>
<h6><span id="分组模式-ctr加解密代码实现">分组模式-CTR加解密代码实现</span></h6><pre><code class="language-python">def aes_ctr_encrypt(pt,key, nonce):
    aes = AES.new(key, AES.MODE_CTR, nonce=nonce)
    ct = aes.encrypt(pt)
    return ct

def aes_ctr_decrypt(ct, key, nonce):
    aes = AES.new(key, AES.MODE_CTR, nonce=nonce)
    pt = aes.decrypt(ct)
    return pt
</code></pre>
<h5><span id="分组模式相关利用手法a">分组模式相关利用手法A</span></h5><p>初始化向量IV(initialization vector)是一个固定长度的输入值，一般会要求它是随机数或者拟随机数<br>ECB模式中，由于没有IV，导致密钥不变的情况下，相同的明文必然会加密生成相同的密文，会泄露明文部分信息</p>
<h6><span id="初始化向量iv代码生成">初始化向量IV代码生成</span></h6><pre><code class="language-python">#系统内置的密码学安全生成器
import os
iv = os.urandom(16)
</code></pre>
<h6><span id="iv复用">IV复用</span></h6><p>CTR模式中，IV&#x2F;nonce和计数器的组合是用于产生流密钥的关键<br>如果每一次加密的IV&#x2F;nonce都是一样的，导致生成的流密钥也是一样的<br>如果已知一段明密文，则可以通过明文和密文的异或恢复出密钥流，并用这个密钥流对其他密文解密，这就是IV复用</p>
<h6><span id="iv复用例题">IV复用例题</span></h6><pre><code class="language-python">import os
from Crypto.Cipher import AES

FLAG=b&quot;flag{test_flag_}&quot;
KEY=os.urandom(16)
NONCE = os.urandom(12)

def aes_ctr_encrypt(pt):
    aes = AES.new(KEY,AES.MODE_CTR, nonce=NONCE)
    ct=aes.encrypt(pt)
    return ct

def aes_ctr_decrypt(ct):
    aes = AES.new(KEY,AES.MODE_CTR, nonce=NONCE)
    pt=aes.decrypt(ct)
    return pt

print(f&quot;flag:{aes_ctr_encrypt(FLAG)}&quot;)
while True:
    user_input=bytes.fromhex(input(&quot;Input a hex string tto encrypt:&quot;))
    ct=aes_ctr_encrypt(user_input)
    print(f&quot;Your ciphertext:{ct}&quot;)
</code></pre>
<p>从题目中我们可以获取以下信息(其中$P_{flag}$和$K$均未知)<br>$P_{flag} ⊕ K &#x3D; C_{flag}$<br>我们可以任意选取一段明文$P_{user}$发送给服务端,并得到$C_{user}$满足<br>$P_{user}⊕ K &#x3D; C_{user}$<br>从中可以解出$K$<br>$K &#x3D; P_{user} ⊕ C_{user}$<br>从而可以求出$P_{flag}$<br>$P_{flag}&#x3D;K ⊕ C_{flag} &#x3D; P_{user} ⊕ C_{user} ⊕ C_{flag}$</p>
<h5><span id="分组模式相关利用手法b">分组模式相关利用手法B</span></h5><h6><span id="ecb模式剪贴">ECB模式剪贴</span></h6><p>某个网站的用户cookie如下:<br>coukte&#x3D;session:aa82ef0a;timedl&#x3D;1;admin&#x3D;0;guess_cookie_ma&#x3D;1;gueess_mp_ab&#x3D;1;guess_cookie_mb&#x3D;0;hell_pad&#x3D;233<br>采用128位的AES-ECB模式对cookie进行加密,所得的密文如下:<br>fa38dcf486e5098ad574c1cc5b06aa7dd6e125070668ffc10579d2dcb71a<br>3871a6ffd90507da87a355702ea8d329d01aced9355f1a946843e452f3299b<br>ae84ab736c4f6306a98cef4e0e294b4bd397d1aa696c56b5950fae5c7ce61f<br>e5fc2579<br>仅当”admin&#x3D;1”时,才能得到flag</p>
<p>由于ECB模式下密文和明文一一对应，所以可以进行特定的剪贴修改</p>
<pre><code class="language-python">plain = &quot;session:aa82ef0a;timedl=1;admin=0;guess_cookie_ma=1;gueess_mp_ab=1;guess_cookie_mb=0;hell_pad=233&quot;
for i in range(0,len(plain),16)
    print(i//16 + 1,plain[i:i+16])
</code></pre>
<p>输出结果：<br>1 session:aa82ef0a<br>2 ;timedl&#x3D;1;admin&#x3D;<br>3 0;guess_cookie_m<br>4 a&#x3D;1;guess_mp_ab&#x3D;<br>5 1;guess_cookie_m<br>6 b&#x3D;0;hell_pad&#x3D;233<br>可以看见第三行和第五行相似，第五行就是我们想要的第三行效果，进行剪贴</p>
<p>new_cipher &#x3D; <br>cipher_blocks[0] + <br>cipher_blocks[1] + <br>cipher_blocks[4] + \ 替换为第5组密文块<br>cipher_blocks[3] + <br>cipher_blocks[4] + <br>cipher_blocks[5]</p>
<h6><span id="cbc模式字节翻转">CBC模式字节翻转</span></h6><p>CBC模式的解密过程可以由如下关系式来表示(其中nb是块的数量):</p>
<p>$P_1&#x3D;Dec_k(C_1) ⊕ IV$<br>$P_i&#x3D;Dec_k(C_i) ⊕ C_{i-1}, 1&lt;i&lt;nb$</p>
<p>从中可以看出,若修改某个密文块$C_{i-1}$,<br>则会影响到解密出来的了不一个明文块$P_i$,即我们可以通过篡改密文来任意操纵明文</p>
<p>假设想要控制某个块的明文,可以通过修改前一块密文相应的字节来达到这个目的<br>若要修改第3个明文块第i个字节的数值,则可以对第2个密文块第i个字节异或上相应的数值<br>(但也会导致解密出来的第2块明文不可预测)</p>
<h5><span id="分组模式相关利用手法c">分组模式相关利用手法C</span></h5><h6><span id="pkcs7填充">PKCS7填充</span></h6><p>PKCS7是一种常用的填充方式,其具体的填充方式为:填充N个字节,且这N个填充字节的字节值均N</p>
<p>例如,当块大小为16时,对”aaaabbbcccc”进行填充<br>填充的结果为”aaaabbbcccc\x04\x04\x04\x04\x04”</p>
<p>注意:即使最后一个块的长度为16,PKCS7填充方式仍然会对其<br>进行填充,会在其后填充一块全为0x10的16字节块。</p>
<pre><code class="language-python">def pad(pt):
    pad_length = 16 - len(pt)%16
    pt += bytes([pad_length]) * pad_length
    return pt

def unpad(pt):
    pad_length = pt[-1]
    if not 1≤ pad_length ≤ 16:
        return None
    if pad(pt[:-pad_length]) != pt:
        return None
    return pt[:-pad_length]
</code></pre>
<h6><span id="padding-oracle">Padding Oracle</span></h6><p>服务端在进行AES-CBC解密的时候,会对解密的结果做解除填充(unpad)操作<br>如果解除填充时校验到填充格式不合法,则会直接报错,通常会返回对应的错误消息息”Padding Error!”</p>
<pre><code class="language-python">def decrypt(cipher):
    #AES-CBC解密
    decrypted_res = aes.decrypt(cipher)
    #解除填充
    plaintext = unpad(decrypted_res)
    if not plaintext:#填充格式错误,unpad函数返回None
        return &quot;Padding Error!&quot;
    #继续执行
    return &quot;OK&quot;
</code></pre>
<p>场景目标:对手获取到了一段密文,想要对其进行解密<br>利用思路:可以通过字节翻转的手法来修改解密后的明文,并将其发送给服务端<br>若修改后的明文符合填充格式,服务器返回OK,则对手可以从中获取到一些关于原始密文的一些信息</p>
<p>如何解密最后一个字节?<br>我们要利用……0x01这个合法的填充格式<br>假设g为最后一字节(共有256种可能性)<br>对上一个密文块的最后一字节异或上g^0x01<br>则解密后的最后一个明文块也会异或上g^0x01<br>若g正确,则最后一块格式为……0x01,服务器返回OK,否则服务器返回Padding Error</p>
<p>如何解密倒数第i个字节?<br>我们要利用……0x0i这个合法的填充格式<br>先通过已解出来倒数i-1个明文,通过字节翻转的方式将解密后的明文块后i-1修改为0x0i;<br>然后继续使用解密倒数第1个字节的方式,尝试256种可能的g,直至服务器返回OK,说明g即为倒数第i个字节</p>
<p>通过上述方法,可以解密出最后一个明文块的16个字节<br>解密完之后,即可将最后16字节的密文抛弃,继续对倒数第二块密文块进行解密<br>依此方法,可以对所有密文进行解密,恢复出整个明文信息</p>
<pre><code class="language-python">#padding_oracle recovers the last 16 plaintext bytesof the given ciphertext
def padding_oracle(cipher):
    plaintext=b&quot;&quot;
    for indexinrange(1,17):
        print f&quot;[*] index:{index}&quot;
        for byte in range(0,256):
            bytes_xor=b&quot;\x00&quot;*(16-index)+bytes [byte index]+xor plaintext,bytes([index]*(index-1))
            new_cipher = cipher[:-32] + xor cipher[-32:-16], bytes_xor + cipher -16:

            if oracle(new_cipher)== &quot;Padding Error!&quot;:
                print(f&quot;[{byte:&gt;3d}], Padding Error!&quot;)
            else:
                plaintext=bytes([byte])+plaintext
                print(f&quot;[{byte:&gt;3d}] OK&quot;)
                print(f&quot;plaintext:{plaintext}&quot;)
                break
return plaintext
</code></pre>
<h3><span id="非对称密码">非对称密码</span></h3><p>公钥密码一般都是基于一些数学难题设计的<br>如RSA算法就是基于大整数因数的分解问题<br>DH密钥交换算法是基于离散对数问题<br>ECC算法是基于椭圆曲线离散对数问题</p>
<h4><span id="公钥密码-rsa">公钥密码-RSA</span></h4><p>RSA算法的安全性取决于其底层的数学难题–大整数因数分解问题的难度<br>对于一些不安全&#x2F;位数比较小的素数,以当前的算法和算力很容容易将其分解<br>通常300bit以下的模数均可在较短时间内被分解,一些不安全的素数也会很快被特定算法所分解<br>RSA过程分为密钥生成、加密、解密三部分</p>
<h5><span id="公钥密码-rsa密钥生成">公钥密码-RSA密钥生成</span></h5><p>选两个大素数：随机选两个不同的大素数p和q<br>计算 n：n &#x3D; p \times q(n是公钥 &#x2F; 私钥的 “模数”，会公开)<br>计算欧拉函数 φ(n)：φ(n) &#x3D; (p-1) \times (q-1)(φ(n) 是小于 n 且与 n 互质的数的数量)<br>选公钥指数 e：选一个整数e，满足1 &lt; e &lt; φ(n)且e与φ(n)互质<br>算私钥指数 d：求d，满足(e \times d) mod φ(n) ≡ 1（即d是e在模φ(n)下的逆元<br>最终密钥：<br>公钥：(e, n)(公开给其他人)<br>私钥：(d, n)(自己保管，绝对保密)</p>
<h5><span id="公钥密码-rsa加解密">公钥密码-RSA加解密</span></h5><p>假设要加密的明文是M(需满足0 &lt; M &lt; n，若 M 太大则分段加密)<br>加密公式：密文C ≡ M ^ e (mod n)</p>
<p>用私钥解密密文C<br>解密公式：明文M ≡ C ^ d (mod n)</p>
<h5><span id="公钥密码-rsa模数分解">公钥密码-RSA模数分解</span></h5><h6><span id="公钥密码-rsa模数分解方式一直接分解">公钥密码-RSA模数分解方式一(直接分解)</span></h6><p>sagemath中直接使用函数 factor(n)即可</p>
<h6><span id="公钥密码-rsa模数分解方式二pq相近">公钥密码-RSA模数分解方式二(p,q相近)</span></h6><pre><code class="language-python">from Crypto.Util.number import getPrime, isPrime

def nextPrime(p):
    p = (p+2)|1
    while not isPrime(p):
        p += 2
    return p

def genkey(bits):
    p = getPrime(bits)
    q = nextPrime(p)
    e = 65537
    n = p*q
    return n

p = getPrime(512)
q = nextPrime(p)
</code></pre>
<p>一般来说，这样生成的两个p，q相差不过几百或者几千<br>有关系：$p^2&lt;n&lt;q^2$<br>则近似平方根必然落在pq之间且距离近，可以通过穷举的方式找到</p>
<h6><span id="公钥密码-rsa模数分解方式三模不互素">公钥密码-RSA模数分解方式三(模不互素)</span></h6><p>当两个模数共有一个素数时，有下面关系：<br>$n_1 &#x3D; p·q_1$<br>$n_2 &#x3D; p·q_2$<br>可以对两个模数求最大公约数gcd，这个数就是素因子p，从而分解两个模数</p>
<p>from Crypto.Util.number import GCD</p>
<p>p &#x3D; GCD(n1, n2)<br>q1 &#x3D; n1 &#x2F;&#x2F; p<br>q2 &#x3D; n2 &#x2F;&#x2F; p</p>
<h6><span id="公钥密码-rsa模数分解方式四共模攻击">公钥密码-RSA模数分解方式四(共模攻击)</span></h6><p>当n难以分解时，使用相同的模数、不同的私钥,加密同一明文消息时即存在”共模”，绕过分解n<br>$已知密文c_1,c_2，公钥e_1,e_2以及模数n$时<br>现在有下面关系：<br>$m ^ {e_1} ≡ c_1 \ (mod \ n)$<br>$m ^ {e_2} ≡ c_2 \ (mod \ n)$</p>
<p>扩展欧几里得算法计算：<br>$ax + by &#x3D; gcd(a,b)$</p>
<p>根据此算法计算出<br>$re_1 + se_2 &#x3D; 1$<br>从而有<br>$c_{1}^{r} c_{2}^{s} ≡ m^{re_1 + se_2} ≡ m^1 \ (mod \ n)$<br>使得右上角的指数变成1</p>
<pre><code class="language-python">from Crypto.Util.number import *
from math import gcd
import gmpy2 as gp

n = &#39;&#39;
e1 = &#39;&#39;
e2 = &#39;&#39;
c1 = &#39;&#39;
c2 = &#39;&#39;

g, r, s = gp.gcdext(e1,e2)
m = pow(m,r,n) * pow(m,s,n) % n
print(long_to_bytes(gp.iroot(m,g) [0]))
</code></pre>
<h5><span id="公钥密码-rsa指数利用方法">公钥密码-RSA指数利用方法</span></h5><h6><span id="小公钥e指数利用">小公钥e指数利用</span></h6><p>RSA通过模幂运算对明文加密,当指数逐渐增大时,模运算发挥作用将整数幂运算的结果截断至有限范围内<br>但是当指数太小时,模运算还未发挥作用,幂运算就已经结束<br>此时的加密结果并没有被截断,即是原本的幂运算,此时就不存在”加密”效果<br>$c ≡ m^e \ (mod \ n) ➡ c &#x3D; m^e$</p>
<p>当$m$较小时,即$m^e&lt;n$时,就会存在这种利用<br>另外,即使$m^e$稍比$n$大一点点,也可以通过穷举的方式对其尝试开根<br>$c ≡ m^e \ (mod \ n) ➡ c &#x3D; m^e - k·n$<br>可以从0开始穷举$k$,并对$k·n + c$尝试开$e$次方根,若可以开出来根,则说明成功解密<br>(对于正常的RSA加密,$k$一般很大,无法被穷举)</p>
<pre><code class="language-python">for k in range(0,100000000000):
    tmp=k*n+c
    root, ok = tmp.nth_root(e,truncate_mode=True)
    if ok:
        print(root)
        break
</code></pre>
<h6><span id="已知e和d分解n">已知e和d分解n</span></h6><p>RSA算法若能够知道加密指数e和解密指数d,则可以完成对n的的分解。<br>根据e和d的关系有<br>$e·d ≡ 1 \ (mod \ \phi(n))$<br>同样可以化为<br>$➡e·d &#x3D; 1 + k·\phi(n)$<br>其中$d &lt; \phi(n)$,因此必有$k&lt;e&#x3D;65537$,k可以穷举,从而可以得到中<br>$\phi(n)&#x3D;(p-1)·(q-1)$</p>
<p>得到$\phi(n)$后，根据n的表达式我们可以得到二元二次方程<br>$\phi(n)&#x3D;(p-1)·(q-1)$<br>$n &#x3D; p·q$<br>解出这个方程从而分解n</p>
<pre><code class="language-python">for k in range(1,e):
    if (e*d - 1) % k == 0: #k可以整除e·d-1
        phi=(e*d - 1) // k
        if pow(123,phi,n) == 1: #满足欧拉定理
            var(&#39;p q&#39;)
            print(solve([(p-1)*(q-1)== phi,p*q=n, p*q = n], [p,q]))
</code></pre>
<h6><span id="wiener利用">Wiener利用</span></h6><p>当d比较小($d&lt;\frac{1}{3}N^\frac{1}{4}$)时,可以使用Wiener利用来获取私钥d<br>特征:通常出题人为了要使得生成的私钥d比较小,通常会先生成一个比较小的d,<br>然后再去求e,从而使得e的取值范围位于(1,$\phi$)之间,会导致e看起来很大</p>
<p>从两条关系出发<br>$\phi(n) &#x3D; (p-1)·(q-1) &#x3D; n - (p + q) +1$<br>$e·d &#x3D; 1 + k·\phi(n)$<br>带入有<br>$e·d &#x3D; 1 + k·[ n - (p + q) +1]$<br>两边同时除以nd，得到<br>$\frac{e}{n} &#x3D; \frac{k}{d}(1 - \delta)$<br>式子左边均已知,右边均未知,右边和左边非常接近<br>这种情况可以使用连分数来将左边的比值展开,在连分数的展开式中,很大概率存在k和d<br>从而可以求出私钥d,进行解密</p>
<pre><code class="language-python">def recover(e, N):
    e = Integer(e)
    N = Integer(N)
    cf = continued_fraction(e / N).convergents()
    G.&lt;x&gt; = ZZ[&#39;x&#39;]

    for k_frac in cf[1:]:
        d0 = k_frac.denominator()
        k = k_frac.numerator()
        if k == 0 or d0 == 0:
            continue
        if (e * d0 - 1) % k != 0:
            continue
        phi = (e * d0 - 1) // k
        s = N - phi + 1
        f = x^2 - s*x + N
        discriminant = f.discriminant()
        if discriminant &lt;= 0 or not discriminant.is_square():
            continue
        roots = f.roots(multiplicities=False)
        roots = [Integer(root) for root in roots if root.is_integer()]
        if len(roots) == 2 and roots[0] * roots[1] == N:
            p, q = roots
            true_phi = (p - 1) * (q - 1)
            if (e * d0) % true_phi == 1:
                print(f&quot;[x] 恢复成功！&quot;)
                print(f&quot;d = {d0}&quot;)
                print(f&quot;d (十六进制) = {hex(d0)}&quot;)
                print(f&quot;p = {p}&quot;)
                print(f&quot;q = {q}&quot;)
                print(f&quot;phi(N) = {true_phi}&quot;)
                print(f&quot;验证：e*d mod phi(N) = {(e*d0) % true_phi}（应为1）&quot;)
                return d0  # 返回正确的d
    print(&quot;[-] 恢复失败&quot;)
    return None
</code></pre>
<h5><span id="公钥密码-rsa-lsb利用方法">公钥密码-RSA-LSB利用方法</span></h5><h6><span id="最低位预言机攻击lsb-oracle-attack">最低位预言机攻击(LSB Oracle Attack)</span></h6><p>假设现在有一个oracle(预言机),它会对一个给定的密文进行解密<br>但并不会直接返回解密结果,而是检验解密的明文的奇偶性<br>根据奇偶性返回相应的值,比如1表示奇数,0表示偶数,即最低位( LSB, least significant bit )<br>那么给定任意一个消息被加密后的密文,只需要$log_2(N)$次oracle询问,就可以解密出明文消息<br>(例如当N是1024位时,只需要大约1024次左右的oracle询问,就可以解密出明文)</p>
<pre><code class="language-python">cc = int(raw_input(&#39;Your encrypted message:&#39;).strip())
mm = k.decrypt(cc)
if mm &amp; 1 == 1:
    print &#39;The plain of your decrypted message is odd!&quot;
else:
    print &#39;The plain of your decrypted message is even!
</code></pre>
<h6><span id="rsa的积性乘法同态">RSA的积性(乘法同态)</span></h6><p>由RSA加密关系<br>$(P_1·P_2)^e &#x3D; P_{1}^e · P_{2}^e \ (mod \ n)$<br>可证明得到<br>$Enc(P_1,P_2) &#x3D; Enc(P_1) · Enc(P_2)$<br>利用这个性质，可以选择一个s，计算$c’ ≡ c·s^e \ (mod \ n)<br>将$c’$发送给服务器，服务器就会返回加密结果$m·s$的奇偶性<br>通过巧妙地继续选取s，就可以恢复出m</p>
<h6><span id="公钥密码-rsa-lsb解密代码实现">公钥密码-RSA-LSB解密代码实现</span></h6><pre><code class="language-python">L, H = 0, n
t = pow(2,e, e, n)
cc = c
for i in range(n.bit_length()):
    cc = (t * cc) % n
    if oracle(cc)== 0:
        H = (L + H) // 2
    else:
        L = (L + H) // 2
    print(L,H)
 #结果并不一定精确,需要再附近找一下正确的
for x in range(-1000,1000):
    if pow(x+m,e,n) == c:
        print(x+m)
</code></pre>
<h5><span id="公钥密码-rsa-coppersmith利用方法">公钥密码-RSA-Coppersmith利用方法</span></h5><h6><span id="coppersmith定理">Coppersmith定理</span></h6><p>假设N为一个未知分解情况的合数，并定义<br>$p(x) &#x3D; x^k + a_{k-1} x^{k-1} +···+ a_2 x^2 + a_1 x + a \ (mod \ N)$<br>为一个最高次数为k的整数系多项式</p>
<p>假设这个多项式存在一个根$x_0$，即<br>$p(x_0) &#x3D; 0 \ (mod \ N)$ 且满足$|x_0| &lt; N^\frac{1}{k}$<br>Coppersmith给出了一个算法可以很快求出这个小根</p>
<p>Coppersmith定理<br>令$p(x)$为一个最高次位数为k的首一多项式，N为一个未知分解情况的正合数,$\epsilon&gt;0$为一个极小的量<br>那么在多项式时间(算法复杂度较低)内,我们可以找到$p(x)$的整数解$x_0$,满足<br>$|x_0| &lt; \frac{1}{2}N^{(\frac{1}{k}-\epsilon)}$<br>(证明过于复杂,涉及到格构造、LLL算法等知识点)</p>
<h6><span id="已知m高位">已知m高位</span></h6><p>题目场景:假设模数n为1024bit,e&#x3D;3,现在已知m的高位m0,<br>只有低72位未知,未知量符合小根的条件(小于341bit)<br>设未知量为x,构造如下modn的多项式:<br>$f&#x3D; (m_0 + x)^3 - c \ (mod \ n)$<br>使用Coppersmith定理即可求解出x</p>
<pre><code class="language-python">K = Zmod(n)
P.&lt;x&gt; = PolynomialRing(K)

f = (m0 + x)^e - c
f.small_roots()
</code></pre>
<h4><span id="公钥密码-dh密钥交换">公钥密码-DH密钥交换</span></h4><h5><span id="公钥密码-dh密钥交换前置知识">公钥密码-DH密钥交换前置知识</span></h5><h6><span id="群基础基础定义">群基础基础定义</span></h6><p>集合简单来讲就是把一堆东西(元素)放在一起<br>群是一个集合,并且在这个集合上定义了一个运算(比如加法、乘法)<br>简而言之群，就是集合+运算</p>
<p>简单来说，群的作用就是描述对称性<br>系统从一个状态通过某种运算变换到另一个状态<br>如果这两个状态等价，则说系统对这一变换时对称的</p>
<p>群通过数学化的方式定义对称性<br>群只关心对称最本质，最抽象的性质，所以只关心操作，将操作放到集合里面</p>
<p>举例对一个正方体进行操作，有操作{保持不变，旋转90°，旋转180°，旋转270°}</p>
<p>类比加法<br>保持不变 ➡ 0<br>旋转90° ➡ r<br>旋转180° ➡ 2r<br>旋转270° ➡ 3r</p>
<p>类比乘法<br>保持不变 ➡ 0<br>旋转90° ➡ r<br>旋转180° ➡ r^2<br>旋转270° ➡ r^3</p>
<p>这里的加法乘法都是模运算，每四次运算就是一个周期<br>3r + r &#x3D; 0 (mod 4)<br>r^3 · r &#x3D; 0 (mod 4)<br>这样我们就得到了两个群<br>$(G,+) &#x3D; ({0,r,2r,3r},+)$<br>$(G,\times) &#x3D; ({0,r,r^2,r^3},\times)$</p>
<p>所以群就是一个集合G，加上一个运算“·”，满足以下四个条件:<br>封闭性：$对于所有a,b∈G，有a·b∈G$<br>结合性：$对于所有a,b,c∈G，有(a·b)·c&#x3D;a·(b·c)$<br>单位元：$存在一个e∈G，使得对于所有a∈G，有e·a&#x3D;a·e&#x3D;a$<br>逆元：$对于每个a∈G，存在一个b∈G，使得a·b&#x3D;b·a&#x3D;e，即b就是a的逆元，记作a^{-1}$</p>
<p>以$(G,+) &#x3D; ({0,r,2r,3r},+)$为例：<br>集合元素：所有保证对称的操作{0,r,2r,3r}<br>二元运算：加法“+”<br>封闭性：旋转组合的结果还是在集合里面<br>结合性：旋转的顺序不影响最终结果<br>单位元：保持不变0<br>逆元：每个操作都有一个对应的逆操作，比如r的逆操作是3r</p>
<p>模p乘法运算也可以组成一个群，定义为：<br>$(Z_p^*, \times) &#x3D; ({1,2,3,···，p-1}, \times)$<br>集合元素：所有小于p的正整数<br>二元运算：模p乘法<br>封闭性：两个小于p的数相乘模p结果还是小于p的数<br>结合性：乘法满足结合律<br>单位元：1<br>逆元：根据扩展欧几里得定理，对于每一个元素a，都存在整数x和y<br>使得$ax + py &#x3D; 1$，则x就是a的逆元</p>
<h6><span id="群的特性">群的特性</span></h6><p>群的阶数：群中所有元素的个数，记作|G|<br>元素的阶数：对于群G中的元素a，存在最小的正整数k，使$a^k &#x3D; e$，则称k为a的阶数，记作ord(a)</p>
<p>有些元素的阶数等于群的阶数，这样的元素称为生成元或者原根，一般记作g</p>
<p>对于乘法群$(Z_p^<em>, \times)$，其阶数为p-1<br>通过g的幂次运算，可以生成群中的所有元素<br>例如$(Z_{11}^</em>, \times)$的原根g&#x3D;2来说</p>
<table>
<thead>
<tr>
<th>(i)</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>(a^i)</td>
<td>2</td>
<td>4</td>
<td>8</td>
<td>5</td>
<td>10</td>
<td>9</td>
<td>7</td>
<td>3</td>
<td>6</td>
<td>1</td>
</tr>
</tbody></table>
<p>对于加法群$(Z_n, +)$来说，生成元是所有和n互素的数<br>例如$(Z_{10}, +)$的生成元g&#x3D;3来说</p>
<table>
<thead>
<tr>
<th>(i)</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>(a^i)</td>
<td>0</td>
<td>3</td>
<td>6</td>
<td>9</td>
<td>2</td>
<td>5</td>
<td>8</td>
<td>1</td>
<td>4</td>
<td>7</td>
</tr>
</tbody></table>
<h6><span id="离散对数难题">离散对数难题</span></h6><p>在群$(Z_p^*, \times)$中，若有一个原根g，很容易算出所有元素<br>$a ≡ g^k \ (mod \ p)$<br>但是反过来，已知a和g，要算出k就非常困难<br>$k &#x3D; log_g a \ (mod \ p)$<br>这就是离散对数难题(DLP, Discrete Logarithm Problem)</p>
<p>在密码学的实际应用中，一般会选择大素数p(至少2048bit)和对应的原根g<br>现有的最好的通用型解决离散对数问题的算法，其算法的时间复杂度也非常高<br>Baby Step Giant Step算法的时间复杂度为$O(\sqrt{p})$<br>Pollard’s Rho算法的时间复杂度为$O(\sqrt{p}·log(p))$<br>Pohlig-Hellman算法的时间复杂度为$O(\sum_{i&#x3D;1}^{k} e_i (log p + \sqrt{p_i}))$<br>(其中$p_i^{e_i}$为p的质因数分解)<br>Index Calculus算法的时间复杂度为$L_p[1&#x2F;2, c] &#x3D; exp(c (log p)^{1&#x2F;2} (log log p)^{1&#x2F;2})$</p>
<p>SageMath中可以直接使用discrete_log函数来计算离散对数<br>默认调用Baby Step Giant Step算法和Pollard’s Rho算法<br>在数据量比较小的时候可以快速解决(100bit以下)</p>
<pre><code class="language-python">g = Mod(2, 37)
discrete_log(Mod(15, 37), g)
</code></pre>
<h5><span id="公钥密码-dh密钥交换协议">公钥密码-DH密钥交换协议</span></h5><p>首先通信双方先共享两个公共参数，模数p和生成元g<br>Alice本地随机生成一个私钥a，并计算$A ≡ g^a \ (mod \ p)$，将A发送给Bob<br>Bob收到A后，本地随机生成一个私钥b，并计算$B ≡ g^b \ (mod \ p)$，将B发送给Alice<br>同时Bob计算共享密钥$K ≡ A^b ≡ g^{ab} \ (mod \ p)$<br>Alice计算共享密钥$K ≡ B^a ≡ g^{ab} \ (mod \ p)$<br>最终Alice和Bob都得到了相同的共享密钥K<br>以这个key作为对称加密算法的密钥，进行后续的通信加密</p>
<h5><span id="公钥密码-dh密钥交换中间人攻击">公钥密码-DH密钥交换中间人攻击</span></h5><p>假设有一个攻击者Eve,她可以监听Alice和Bob之间的通信<br>当Alice发送A给Bob时,Eve截获了A,并生成自己的私钥c,计算$E ≡ g^c \ (mod \ p)$,将E发送给Bob<br>当Bob发送B给Alice时,Eve截获了B,并将E发送给Alice<br>此时Alice计算共享密钥$K_{AE} ≡ E^a ≡ g^{ac} \ (mod \ p)$<br>Eve计算共享密钥$K_{AE} ≡ A^c ≡ g^{ac} \ (mod \ p)$<br>Bob计算共享密钥$K_{BE} ≡ E^b ≡ g^{bc} \ (mod \ p)$<br>Eve计算共享密钥$K_{BE} ≡ B^c ≡ g^{bc} \ (mod \ p)$<br>最终Eve成功地和Alice、Bob分别建立了两个共享密钥，可以伪装进行通信<br>拿到双方的通信原始数据</p>
<h4><span id="公钥密码-elgamal加密算法">公钥密码-ElGamal加密算法</span></h4><p>ElGamal加密算法基于离散对数难题设计<br>首先通信双方先共享两个公共参数，模数p和生成元g<br>Alice本地随机生成一个私钥x，并计算$y ≡ g^x \ (mod \ p)$，将y作为公钥发送给Bob<br>Bob收到y后，选择一个随机数k(1 &lt; k &lt; p-2且k与p-1互素)<br>Bob计算临时公钥$C_1 ≡ g^k \ (mod \ p)$<br>Bob计算共享密钥$K ≡ y^k ≡ g^{xk} \ (mod \ p)$<br>对m进行处理使得$m &lt; p$(如果m过大，可以分段加密)<br>Bob使用共享密钥K对消息m进行加密，计算$C_2 ≡ m·K \ (mod \ p)$<br>Bob将密文对$(C_1, C_2)$发送给Alice<br>Alice收到密文对$(C_1, C_2)$后，计算共享密钥$K ≡ C_1^x ≡ g^{kx} \ (mod \ p)$<br>Alice使用共享密钥K对$C_2$进行解密，计算$m ≡ C_2 · K^{-1} \ (mod \ p)$</p>
<p>加密侧（B）：$K &#x3D; y_A^k &#x3D; (g^x)^k &#x3D; g^{xk}$  → $C_2 &#x3D; M \times K \mod p$<br>解密侧（A）：$K &#x3D; C_1^x &#x3D; (g^k)^x &#x3D; g^{xk}$  → $M &#x3D; C_2 \times K^{-1} \mod p$</p>
<h4><span id="公钥密码-dsa数字签名算法">公钥密码-DSA数字签名算法</span></h4><p>数字签名用于验证消息的完整性和真实性<br>数字签名一般是基于非对称密码加密算法实现的，非对称算法的解密运算即为签名，加密运算即位验签<br>假设Bob想要对一份文档m进行签名，Bob会使用他的私钥对文档进行签名运算，并得到签名sig<br>随后Bob将文档m和签名sig发送给Alice，Alice使用Bob的公钥对签名sig进行验签运算</p>
<p>数字签名的要点：<br>签名的消息m不一定要加密，可以明文的形式传输<br>只有签名者有私钥，能够对消息进行签名，任何其他人没有私钥无法签名<br>任何人都可以使用签名者的公钥对签名进行验证<br>消息完整性：如果消息在传输过程中被篡改，验签会失败<br>不可抵赖性：因为只有Bob有私钥，只有他能生成有效签名，所以Bob不能否认他签署过该消息</p>
<h5><span id="哈希函数">哈希函数</span></h5><p>在数字签名中，一般不会直接对消息m进行签名<br>而是先对消息m进行哈希运算，得到消息摘要H(m)<br>然后对消息摘要H(m)进行签名</p>
<p>哈希函数能够将任意长度的输入映射为固定长度的输出值(散列值或摘要)<br>特征：<br>接受任意长度输入：SHA1最高可接受2^64-1位的输入<br>固定长度输出：SHA1输出160位(20字节)的摘要<br>高效性：哈希函数计算时间短<br>单向性：已知哈希函数的输出$y &#x3D; H(m)$，很难反推出输入m<br>抗碰撞性：很难找到两个不同的输入m1和m2，使得$H(m1) &#x3D; H(m2)$<br>雪崩效应：输入的微小变化会导致输出的显著变化</p>
<p>常见的哈希函数：<br>MD2：输出128位摘要，设计用于8位处理器<br>MD5：输出128位摘要，已被证明存在碰撞漏洞，不推荐用于安全<br>SHA1：输出160位摘要，已被证明存在碰撞漏洞，不推荐用于安全<br>SHA256：输出256位摘要，当前被广泛使用，安全性较高<br>SHA512：输出512位摘要，安全性更高，但计算速度较慢<br>CRC32：输出32位摘要，主要用于数据完整性校验，不适合安全应用<br>Tiger：输出192位摘要，设计用于高安全性应用<br>Adler32：输出32位摘要，速度快，适用于数据完整性校验<br>RipeMD160：输出160位摘要，设计用于数字签名和加密应用</p>
<p>哈希函数除了数字签名，还有很多其他用途：<br>散列表：方便数据的查询，搜索，可以达到O(1)的时间复杂度<br>错误矫正：可以通过检查散列值，判断传输的信息是否在中途被篡改<br>区块链：可被用作工作量证明，使用散列值来链接区块</p>
<h6><span id="哈希函数-sha1算法secure-hash-algorithm-1-安全散列算法1">哈希函数-SHA1算法(Secure Hash Algorithm 1 安全散列算法1)</span></h6><p>SHA1算法的输入是几乎任意长度的消息(最大2^64bit)，输出是160位(20字节)的消息摘要<br>SHA1算法采用Merkle-Damgård结构，分块处理输入消息，每块512位(64字节)<br>SHA1算法的主要步骤：<br>填充消息：在消息末尾添加一个’1’位，然后添加足够的’0’位，使消息长度对512取模后等于448<br>添加长度：在消息末尾添加一个64位的整数l，l表示原始消息的长度<br>初始化哈希值：使用五个32位的常数IV作为初始哈希值<br>处理消息块：压缩函数将消息处理<br>输出摘要：将最终的哈希值连接起来，得到160位的消息摘要</p>
<p>压缩函数：<br>初始化链接状态为固定的初始值IV<br>将512位消息块扩散为80个字<br>每20个字会经过一个20轮的运算，每一轮都会更新链接状态<br>80轮运算后，链接状态经过变换输出，作为下一次压缩函数的输入</p>
<h6><span id="哈希函数长度扩展攻击">哈希函数长度扩展攻击</span></h6><p>在某些登录场景中，服务器会通过哈希函数来进行全校认证<br>合法用户应当知道$secret的具体值，从而可以计算出正确的散列值以此校验登录</p>
<pre><code class="language-php">&lt;?php
include &quot;secret.php&quot;; // secret.php中定义了$secret变量
@$username = (string)$_POST[&#39;username&#39;];
function enc($text){
    global $secret;
    return md5($secret . $text);
}
if(enc($username) === $_COOKIE[&#39;verify&#39;]){
    if(is_numeric(strpos($username, &quot;admin&quot;))){
        echo ($flag);
    } else {
        die(&quot;you are not admin!&quot;);
    }
}
else{kie(&quot;verify&quot;, enc($guest), time() + 60*60*24*7);
}
?&gt;
</code></pre>
<p>哈希长度扩展利用：当已知Hash(m)，但未知m，能够计算Hash(secret || m || padding || m’)<br>当我们初次登陆时，服务器会设置cookie为Hash(secret || “guest”)，并将摘要以cookie的形式发送给客户端<br>借助哈希长度扩展攻击，我们可以计算出Hash(secret || “guest” || padding || “admin”)<br>设置username为”guest” || padding || “admin”，其中带有admin字样，就可以登陆拿flag</p>
<h5><span id="公钥密码-数字签名-rsa签名">公钥密码-数字签名-RSA签名</span></h5><p>RSA加密算法不仅可以对数据进行加密，也可以用来数字签名<br>不同的是，签名使用私钥进行“加密”，验签使用公钥进行“解密”</p>
<h5><span id="公钥密码-数字签名-elgamal签名">公钥密码-数字签名-ElGamal签名</span></h5><p>p：一个大素数<br>g：p的一个原根(生成元)<br>x：签名者的私钥，随机选择，1 &lt; x &lt; p-2<br>y：签名者的公钥，计算$y ≡ g^x \ (mod \ p)$得到</p>
<h6><span id="公钥密码-数字签名-elgamal签名过程">公钥密码-数字签名-ElGamal签名过程</span></h6><p>随机生成一个整数k，满足1 &lt; k &lt; p-2且k与p-1互素<br>计算$r ≡ g^k \ (mod \ p)$<br>计算$s ≡ (H(m) - x*r) k^{-1} \ (mod \ p-1)$<br>签名结果为签名对$(r, s)$</p>
<h6><span id="公钥密码-数字签名-elgamal验签过程">公钥密码-数字签名-ElGamal验签过程</span></h6><p>计算$v &#x3D; y^r \times r^s \ (mod \ p)$<br>计算解密后的消息相关量$H(m)$<br>如果$v ≡ g^{H(m)} \ (mod \ p)$，则验签通过，否则验签失败</p>
<p>$v &#x3D; y^r * r^s (mod \ p)$<br>$  &#x3D; (g^x)^r * (g^k)^s (mod \ p)$<br>$  &#x3D; g^{xr} * g^{ks} (mod \ p)$<br>$  &#x3D; g^{xr + ks} (mod \ p)$<br>$  &#x3D; g^{H(m)} (mod \ p)$  # 根据签名计算公式可知$xr + ks ≡ H(m) \ mod \ (p)$</p>
<h6><span id="公钥密码-数字签名-elgamal签名k重用攻击">公钥密码-数字签名-ElGamal签名k重用攻击</span></h6><p>假设签名者在对两个不同的消息$H(m_1)$和$H(m_2)$进行签名时，不小心重用了同一个随机数k<br>得到签名对$(r, s_1)$和$(r, s_2)$<br>根据签名公式，有下面两条关系：<br>$s_1 ≡ (H(m_1) - x<em>r) k^{-1} \ (mod \ p-1)$<br>$s_2 ≡ (H(m_2) - x</em>r) k^{-1} \ (mod \ p-1)$<br>将上面两条关系式相减，得到：<br>$k ≡ (H(m_1) - H(m_2))(s_1 - s_2)^{-1} \ (mod \ p-1)$<br>恢复出k后，带入任意一条关系式，即可求出私钥x：<br>$x ≡ (H(m_1) - s_1*k) r^{-1} \ (mod \ p-1)$</p>
<pre><code class="language-python">from Crypto.Util.number import inverse

(p,g) = ( , )
(m1,r1,s1) = ( , , )
(m2,r2,s2) = ( , , )

k = (m1 - m2) * inverse(s1 - s2, p-1) % (p-1)
x = (m1 - s1 * k) * inverse(r1, p-1) % (p-1)
print(f&quot;私钥x: {x}&quot;)
</code></pre>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/myblog.github.io/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Dorange</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://lr2006-robot.github.io/myblog.github.io/post/undefined.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://lr2006-robot.github.io/myblog.github.io/post/undefined.html')">密码学笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://lr2006-robot.github.io/myblog.github.io/post/undefined.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=密码学笔记&amp;url=https://lr2006-robot.github.io/myblog.github.io/post/undefined.html&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://LR2006-Robot.github.io/myblog.github.io" target="_blank">Alice and Bodの神秘小屋</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/myblog.github.io/post/undefined.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/myblog.github.io/" onerror="onerror=null;src='/myblog.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RSA题型总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/myblog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">古典密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">单表替换密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.1.</span> <span class="toc-text">Caesar Cipher 凯撒密码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">凯撒加密代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">凯撒解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.2.</span> <span class="toc-text">Simple Substitution Cipher 简单替换密码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">字频攻击代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.3.</span> <span class="toc-text">Atbash Cipher 埃特巴什码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.4.</span> <span class="toc-text">Morse Cipher 摩斯密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.5.</span> <span class="toc-text">Affine Cipher 仿射密码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">多表替换密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.1.</span> <span class="toc-text">维吉尼亚密码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">维吉尼亚解密代码实现(不一定准确只可以大致参考)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">其他类型密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.</span> <span class="toc-text">Rail-Fence Cipher 栅栏密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.</span> <span class="toc-text">Baconian Cipher 培根密码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">培根密码表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">栅栏加密代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">栅栏解密代码实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">现代密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">不同分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.1.</span> <span class="toc-text">按照密钥的特性进行分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.2.</span> <span class="toc-text">按照功能分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.3.</span> <span class="toc-text">按照抗量子能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">对称密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.1.</span> <span class="toc-text">序列密码-RC4(Rivest Cipher 4 李维斯特密码4)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">S盒初始化(KSA)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">伪随机流生成(PRGA)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">序列密码-RC4加解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.2.</span> <span class="toc-text">序列密码-OTP(One Time Pad 一次一密)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">OTP加密代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">OTP解密方式一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">OTP解密方式二(可实现率极低)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.2.3.1.</span> <span class="toc-text">解密原理一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.2.3.2.</span> <span class="toc-text">解密原理二</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.2.3.3.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.3.</span> <span class="toc-text">序列密码-LCG(Linear Congruential Generator 线性同余生成器)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">解密前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.3.1.1.</span> <span class="toc-text">同余运算简单性质</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.3.1.2.</span> <span class="toc-text">逆相关运算</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">LCG解密方式一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">LCG解密方式二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">LCG例题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.3.4.1.</span> <span class="toc-text">LCG例题题目</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.3.4.2.</span> <span class="toc-text">LCG例题解题代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.4.</span> <span class="toc-text">序列密码-LFSR(Linear Feedback Shift Register 线性反馈移位寄存器)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">LFSR线性反馈函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">LFSR解密方式一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">LFSR解密方式二</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.5.</span> <span class="toc-text">分组密码-DES(Data Encryption Standard 数据加密标准)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">DES加密初始置换和最终置换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.5.1.1.</span> <span class="toc-text">初始置换(Initial Permutation)代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">DES密钥扩展算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.5.2.1.</span> <span class="toc-text">DES密钥扩展算法代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">DES加密轮函数(Feistel Function 费斯妥函数)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.5.3.1.</span> <span class="toc-text">DES加密轮函数代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">DES加密过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.5.4.1.</span> <span class="toc-text">DES加密代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.5.5.</span> <span class="toc-text">DES加解密代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.5.5.1.</span> <span class="toc-text">DES解密方式一</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.6.</span> <span class="toc-text">分组密码-AES(Advanced Encryption Standard 高级加密标准)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">AES算法层加密</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.6.1.1.</span> <span class="toc-text">AES加密算法框架代码实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.6.1.2.</span> <span class="toc-text">AES算法层-扩散层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.6.1.3.</span> <span class="toc-text">AES算法层-密钥加法层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.6.1.4.</span> <span class="toc-text">AES密钥扩展算法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">AES加解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.7.</span> <span class="toc-text">分组密码-分组模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">分组模式-ECB(Electronic Code Book mode 电子密码本模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.1.1.</span> <span class="toc-text">分组模式-ECB加解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">分组模式-CBC(Cipher Block Chaining mode 密码分组链接模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.2.1.</span> <span class="toc-text">分组模式-CBC加解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">分组模式-CFB(Cipher FeedBack mode 密文反馈模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.3.1.</span> <span class="toc-text">分组模式-CFB加解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.4.</span> <span class="toc-text">分组模式-CTR(CounTeR mode 计数器模式)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.4.1.</span> <span class="toc-text">分组模式-CTR计数器构造</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.4.2.</span> <span class="toc-text">分组模式-CTR加解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.5.</span> <span class="toc-text">分组模式相关利用手法A</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.5.1.</span> <span class="toc-text">初始化向量IV代码生成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.5.2.</span> <span class="toc-text">IV复用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.5.3.</span> <span class="toc-text">IV复用例题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.6.</span> <span class="toc-text">分组模式相关利用手法B</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.6.1.</span> <span class="toc-text">ECB模式剪贴</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.6.2.</span> <span class="toc-text">CBC模式字节翻转</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.2.7.7.</span> <span class="toc-text">分组模式相关利用手法C</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.7.1.</span> <span class="toc-text">PKCS7填充</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.2.7.7.2.</span> <span class="toc-text">Padding Oracle</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">非对称密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.3.1.</span> <span class="toc-text">公钥密码-RSA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">公钥密码-RSA密钥生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">公钥密码-RSA加解密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">公钥密码-RSA模数分解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.3.1.</span> <span class="toc-text">公钥密码-RSA模数分解方式一(直接分解)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.3.2.</span> <span class="toc-text">公钥密码-RSA模数分解方式二(p,q相近)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.3.3.</span> <span class="toc-text">公钥密码-RSA模数分解方式三(模不互素)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.3.4.</span> <span class="toc-text">公钥密码-RSA模数分解方式四(共模攻击)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">公钥密码-RSA指数利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.4.1.</span> <span class="toc-text">小公钥e指数利用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.4.2.</span> <span class="toc-text">已知e和d分解n</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.4.3.</span> <span class="toc-text">Wiener利用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">公钥密码-RSA-LSB利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.5.1.</span> <span class="toc-text">最低位预言机攻击(LSB Oracle Attack)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.5.2.</span> <span class="toc-text">RSA的积性(乘法同态)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.5.3.</span> <span class="toc-text">公钥密码-RSA-LSB解密代码实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.1.6.</span> <span class="toc-text">公钥密码-RSA-Coppersmith利用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.6.1.</span> <span class="toc-text">Coppersmith定理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.1.6.2.</span> <span class="toc-text">已知m高位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.3.2.</span> <span class="toc-text">公钥密码-DH密钥交换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">公钥密码-DH密钥交换前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.2.1.1.</span> <span class="toc-text">群基础基础定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.2.1.2.</span> <span class="toc-text">群的特性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.2.1.3.</span> <span class="toc-text">离散对数难题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">公钥密码-DH密钥交换协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">公钥密码-DH密钥交换中间人攻击</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.3.3.</span> <span class="toc-text">公钥密码-ElGamal加密算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.3.4.</span> <span class="toc-text">公钥密码-DSA数字签名算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.4.1.1.</span> <span class="toc-text">哈希函数-SHA1算法(Secure Hash Algorithm 1 安全散列算法1)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.4.1.2.</span> <span class="toc-text">哈希函数长度扩展攻击</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">公钥密码-数字签名-RSA签名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">公钥密码-数字签名-ElGamal签名</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.4.3.1.</span> <span class="toc-text">公钥密码-数字签名-ElGamal签名过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.4.3.2.</span> <span class="toc-text">公钥密码-数字签名-ElGamal验签过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">2.3.4.3.3.</span> <span class="toc-text">公钥密码-数字签名-ElGamal签名k重用攻击</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/myblog.github.io/post/undefined.html" title="RSA题型总结">RSA题型总结</a><time datetime="2026-02-08T09:05:00.000Z" title="发表于 2026-02-08 17:05:00">2026-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/myblog.github.io/post/undefined.html" title="密码学笔记">密码学笔记</a><time datetime="2026-02-08T02:00:00.000Z" title="发表于 2026-02-08 10:00:00">2026-02-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2026 By <a class="footer-bar-link" href="/myblog.github.io/" title="Dorange" target="_blank">Dorange</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/myblog.github.io/archives/" title="archive"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/myblog.github.io/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/myblog.github.io/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hexo.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/myblog.github.io/js/utils.js"></script><script src="/myblog.github.io/js/main.js"></script><script src="/myblog.github.io/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.7.1",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Dorange 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdn.cbd.int/qrcodejs@1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/myblog.github.io/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script src="/myblog.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/myblog.github.io/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>