<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RSA题型总结</title>
      <link href="/myblog.github.io/post/undefined.html"/>
      <url>/myblog.github.io/post/undefined.html</url>
      
        <content type="html"><![CDATA[<h2><span id="rsa-基础定义">RSA 基础定义</span></h2><h3><span id="基础字母含义">基础字母含义</span></h3><p>明文$m$：用于以数字或字节形式记录信息<br>公钥$e$：用于加密明文<br>密文$m$：用于以数字或字节形式记录加密信息<br>私钥$d$：用于解密密文<br>模数$n$：用于加解密信息，安全性的核心<br>欧拉函数$phi$(数学形式$\phi(n)$)：用于计算私钥<br>质数$p$：用于解密<br>质数$q$：用于解密</p><h3><span id="基础字母关系">基础字母关系</span></h3><p>$n = p × q$<br>$\phi(n)  = (p-1)(q-1)$</p><p>$m^e \equiv c \ (\bmod \ n)$<br>$e × d \equiv 1 \ (\bmod \ \phi(n))$<br>$c^d \equiv m \ (\bmod \ n)$</p><h3><span id="基础定义例题">基础定义例题</span></h3><h4><span id="基础定义题目">基础定义题目</span></h4><pre><code class="lang-python">import gmpy2from Crypto.Util.number import *from binascii import a2b_hex,b2a_hexflag = &quot;*****************&quot;p = 262248800182277040650192055439906580479q = 262854994239322828547925595487519915551e = 65533n = p*qc = pow(int(b2a_hex(flag),16),e,n)print (c)c = 27565231154623519221597938803435789010285480123476977081867877272451638645710</code></pre><h4><span id="基础定义解题代码">基础定义解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inversep =q =c =e =n = p*qd = inverse(e, (p-1)*(q-1))m = pow(c, d, n)print(long_to_bytes(m))</code></pre><h2><span id="rsa-进阶定义">RSA 进阶定义</span></h2><h3><span id="进阶字母含义">进阶字母含义</span></h3><p>通过中国剩余定理CRT拆分运算<br>$dp$：辅助私钥参数<br>$dq$：辅助私钥参数</p><h3><span id="进阶字母关系">进阶字母关系</span></h3><p>$dp \equiv d \ (\bmod \ (p - 1))$<br>$dq \equiv d \ (\bmod \ (q - 1))$</p><p>$m1 \equiv c^dp \ (\bmod \ p)$<br>$m2 \equiv c^dq \ (\bmod \ q)$</p><p>$q^{-1}  × q \equiv 1 \ (\bmod \ p)$<br>$q^{-1} × (m1 - m2) \equiv h \ (\bmod \ p)$<br>$m2 + h × q \equiv m \ (\bmod \ n)$</p><p>$p^{-1}  × p \equiv 1 \ (\bmod \ q)$<br>$p^{-1} × (m2 - m1) \equiv h \ (\bmod \ q)$<br>$m1 + h × p \equiv m \ (\bmod \ n)$</p><h3><span id="进阶定义例题">进阶定义例题</span></h3><h4><span id="进阶定义题目">进阶定义题目</span></h4><pre><code class="lang-python">p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</code></pre><h4><span id="进阶定义解题代码">进阶定义解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import inverse, long_to_bytesn = p * qm1 = pow(c, dp, p)m2 = pow(c, dq, q)q_inv = inverse(q, p)h = (q_inv*(m1 - m2)) % pm = (m2 + h*q) % nprint(m)flag = long_to_bytes(m)print(flag)</code></pre><h2><span id="rsa-简单转化">RSA 简单转化</span></h2><h3><span id="简单转化出题思路">简单转化出题思路</span></h3><p>构建一些简单的关系如<br>$p + q$<br>$(p+1)(q+1)$<br>进行推到解密即可</p><h3><span id="简单转化例题">简单转化例题</span></h3><h4><span id="简单转化题目">简单转化题目</span></h4><pre><code class="lang-python">p+q : 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea(p+1)(q+1) : 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740e : 0xe6b1bee47bd63f615c7d0a43c529d219d : 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5enc_flag : 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a</code></pre><h4><span id="简单转化解题代码">简单转化解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inversepart_hex =total_hex =e_hex =d_hex =c_hex =part = int(part_hex, 16)total = int(total_hex, 16)e = int(e_hex, 16)d = int(d_hex, 16)c = int(c_hex, 16)n = total - part - 1 #n = p × q = (p+1)(q+1) - (p+q) - 1m = pow(c, d, n)print(long_to_bytes(m))</code></pre><h2><span id="rsa-方程相关运用">RSA 方程相关运用</span></h2><h3><span id="方程相关出题思路">方程相关出题思路</span></h3><p>构建一些次方级的方程进行求解，使用sympy库进行解方程即可</p><h3><span id="方程相关例题">方程相关例题</span></h3><h4><span id="方程相关题目">方程相关题目</span></h4><pre><code class="lang-python">N=636585149594574746909030160182690866222909256464847291783000651837227921337237899651287943597773270944384034858925295744880727101606841413640006527614873110651410155893776548737823152943797884729130149758279127430044739254000426610922834573094957082589539445610828279428814524313491262061930512829074466232633130599104490893572093943832740301809630847541592548921200288222432789208650949937638303429456468889100192613859073752923812454212239908948930178355331390933536771065791817643978763045030833712326162883810638120029378337092938662174119747687899484603628344079493556601422498405360731958162719296160584042671057160241284852522913676264596201906163m1=90009974341452243216986938028371257528604943208941176518717463554774967878152694586469377765296113165659498726012712288670458884373971419842750929287658640266219686646956929872115782173093979742958745121671928568709468526098715927189829600497283118051641107305128852697032053368115181216069626606165503465125725204875578701237789292966211824002761481815276666236869005129138862782476859103086726091860497614883282949955023222414333243193268564781621699870412557822404381213804026685831221430728290755597819259339616650158674713248841654338515199405532003173732520457813901170264713085107077001478083341339002069870585378257051150217511755761491021553239m2=487443985757405173426628188375657117604235507936967522993257972108872283698305238454465723214226871414276788912058186197039821242912736742824080627680971802511206914394672159240206910735850651999316100014691067295708138639363203596244693995562780286637116394738250774129759021080197323724805414668042318806010652814405078769738548913675466181551005527065309515364950610137206393257148357659666687091662749848560225453826362271704292692847596339533229088038820532086109421158575841077601268713175097874083536249006018948789413238783922845633494023608865256071962856581229890043896939025613600564283391329331452199062858930374565991634191495137939574539546import hashlibimport sympyfrom Crypto.Util.number import *flag = &#39;GWHT{******}&#39;secret = &#39;******&#39;assert(len(flag) == 38)half = len(flag) / 2flag1 = flag[:half]flag2 = flag[half:]secret_num = getPrime(1024) * bytes_to_long(secret)p = sympy.nextprime(secret_num)q = sympy.nextprime(p)N = p * qe = 0x10001F1 = bytes_to_long(flag1)F2 = bytes_to_long(flag2)c1 = F1 + F2c2 = pow(F1, 3) + pow(F2, 3)assert(c2 &lt; N)m1 = pow(c1, e, N)m2 = pow(c2, e, N)</code></pre><h4><span id="方程相关解题代码">方程相关解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytesimport gmpy2 as gpfrom sympy import solve, symbolse =n =c1 =c2 =p, ok = gp.iroot(n,2)for i in range(100000):    if n % p == 0:        q = n // p        print(f&quot;p = {p}&quot;)        print(f&quot;q = {q}&quot;)        break    p = gp.next_prime(p)phi = (p-1)*(q-1)d = gp.invert(e, phi)m1 = pow(c1, d, n)m2 = pow(c2, d, n)print(f&quot;m1 = {m1}&quot;)print(f&quot;m2 = {m2}&quot;)f1, f2 = symbols(&#39;f1 f2&#39;)x = solve([f1 + f2 -m1,pow(f1,3) + pow(f2,3) - m2],[f1,f2])print(f&quot;x = {x}&quot;)f1 = 1141553212031156130619789508463772513350070909f2 = 1590956290598033029862556611630426044507841845flag1 = long_to_bytes(f1) + long_to_bytes(f2)flag2 = long_to_bytes(f2) + long_to_bytes(f1)print(f&quot;flag2 = {flag2}&quot;)print(f&quot;flag1 = {flag1}&quot;)</code></pre><h2><span id="rsa-小e爆破">RSA 小e爆破</span></h2><h3><span id="小e爆破出题思路">小e爆破出题思路</span></h3><p>特征是明显非常小的e，可以由关系<br>$m^e \equiv c \ (\bmod \ n)$<br>推导关系<br>$m = \sqrt[e]{c + k × n}$</p><p>直接爆破k，当m是整数时就可以输出了</p><h3><span id="小e爆破例题">小e爆破例题</span></h3><h4><span id="小e爆破题目">小e爆破题目</span></h4><pre><code class="lang-python">n= 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793e = 0x3c = 0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365#so,how to get the message?</code></pre><h4><span id="小e爆破解题代码">小e爆破解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inverseimport gmpy2n_hex =e_hex =c_hex =n = int(n_hex,16)e = int(e_hex,16)c = int(c_hex,16)for k in range(0,1000000):    temp = c + k * n    m, ok = gmpy2.iroot(temp, e)    print(f&quot;Trying k={k}...&quot;, end=&quot;\r&quot;)    if ok:        print(long_to_bytes(int(m)))        break</code></pre><h2><span id="rsa-pq选取不当">RSA pq选取不当</span></h2><h3><span id="pq选取不当出题思路">pq选取不当出题思路</span></h3><p>p和q差值过大，可以直接进行小的范围爆破<br>p和q差值过小，可以通过费马因式分解进行爆破</p><h3><span id="费马因式分解在rsa中的应用">费马因式分解在RSA中的应用</span></h3><p>依据公式<br>$\frac{(p+q)^2}{4} - n = \frac{(p+q)^2}{4} - pq = \frac{(p-q)^2}{4}$<br>$|p-q|$比较小,那么$\frac{(p-q)^2}{4}$也小，所以$\frac{(p+q)^2}{4}$接近于n，可以通过不断增加$\frac{(p+q)}{2}$的值，直到$\frac{(p-q)^2}{4}$为完全平方数</p><p>设x=$\frac{(p+q)}{2}$,y=$\frac{(p-q)}{2}$<br>当满足$x^2 - n = y^2$时即可求出方程</p><h3><span id="pq差值过大例题">pq差值过大例题</span></h3><h4><span id="pq差值过大题目">pq差值过大题目</span></h4><pre><code class="lang-python">n = 1906011750017368771307796117673461157817901033778025473698320639347279300698085835647703350923834808686618760795173855605538695556283974551407384296775817454538392743419582983483423430619884117509611946945420798868634216459855241900807180705272425022537879022082812277121832800892726814372715231802506905483235703703  c = 1813938701877845244891542403221397546309695735830614414823144998397779069720891016412390561291374385722837407507863630503077703755780891882029985205298169331480246769220977772002051973812821294349985237911202368331033856552284454208053314132392846017514315058559493210418463581508042060692714222299519015824148532123 p = getPrime(1024)q = getPrime(25)e = 65537</code></pre><h4><span id="pq差值过大解题代码">pq差值过大解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inversefor p in range (2**24,2**25):    if n % p == 0:        q = n // p        print(f&quot;Found factors:\np = {p}\nq = {q}&quot;)        breake = 65537m = pow(c, inverse(e, (p-1)*(q-1)), n)print(f&quot;Decrypted message:\n{long_to_bytes(m)}&quot;)</code></pre><h3><span id="pq差值过小例题">pq差值过小例题</span></h3><h4><span id="pq差值过小题目">pq差值过小题目</span></h4><h4><span id="pq差值过小解题代码">pq差值过小解题代码</span></h4><h2><span id="rsa-模不互素">RSA 模不互素</span></h2><h3><span id="模不互素出题思路">模不互素出题思路</span></h3><p>模数用了相同的质数，可以通过最大公约数求解</p><h3><span id="模不互素例题">模不互素例题</span></h3><h4><span id="模不互素题目">模不互素题目</span></h4><pre><code class="lang-python">from Crypto.Util.number import getPrime,bytes_to_longflag=open(&quot;flag&quot;,&quot;rb&quot;).read()p=getPrime(1024)q=getPrime(1024)assert(e&lt;100000)n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print(c,n)print(pow(294,e,n))p=getPrime(1024)n=p*qm=bytes_to_long(&quot;BJD&quot;*32)c=pow(m,e,n)print(c,n)&#39;&#39;&#39;output:12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120  13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721  12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047&#39;&#39;&#39;</code></pre><h4><span id="模不互素解题代码">模不互素解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytesimport gmpy2 as gp #assert(e&lt;100000) #task = pow(294,e,n1)c1 =n1 =task =c2 =n2 =q = gp.gcd(n1, n2)p1 = n1 // qp2 = n2 // qphi1 = (p1 - 1)*(q - 1)phi2 = (p2 - 1)*(q - 1)&quot;&quot;&quot;for e in range(3, 100000):    if pow(294,e,n1) == task:        print(f&quot;Found e: {e}&quot;)&quot;&quot;&quot;e = 52361d1 = gp.invert(e, phi1)d2 = gp.invert(e, phi2)m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)print(long_to_bytes(m1))print(long_to_bytes(m2))</code></pre><h2><span id="rsa-共模攻击">RSA 共模攻击</span></h2><h3><span id="共模攻击出题思路">共模攻击出题思路</span></h3><p>对于同一个模数n，用于加密同一个m，但是用不同e加密两次<br>$m^{e_1} \equiv c_1 \ (\bmod \ n)$<br>$m^{e_2} \equiv c_2 \ (\bmod \ n)$</p><p>使用欧拉定理可以破解,构造<br>$re_1 + se_2 = gcd(e_1,e_2)$</p><p>则由<br>$c<em>{1}^r + c</em>{2}^s \equiv m^{er_1 + se_2} \ (\bmod \ n)$<br>从而绕过私钥d解密</p><h3><span id="共模攻击例题">共模攻击例题</span></h3><h4><span id="共模攻击题目">共模攻击题目</span></h4><pre><code class="lang-python">c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291</code></pre><h4><span id="共模攻击解题代码">共模攻击解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inverseimport gmpy2 as gpc1 =n =e1 =c2 =e2 =g,r,s = gp.gcdext(e1, e2)m_g = pow(c1, r, n) * pow(c2, s, n) % nm, ok = gp.iroot(m_g,g)print(long_to_bytes(m))</code></pre><h2><span id="rsa-已知ed爆破">RSA 已知ed爆破</span></h2><p>密钥关系推导<br>$e × d = 1 + k × \phi(n)$<br>确定$\phi$的范围(用n近似)，还有ed范围进行爆破</p><h3><span id="出题思路">出题思路</span></h3><h3><span id="已知ed爆破例题">已知ed爆破例题</span></h3><h4><span id="已知ed爆破题目">已知ed爆破题目</span></h4><pre><code class="lang-python">from Crypto.Util.number import *from flag import flagdef nextPrime(n):    n += 2 if n &amp; 1 else 1    while not isPrime(n):        n += 2    return np = getPrime(1024)q = nextPrime(p)n = p*qe = 0x10001d = inverse(e, (p-1)*(q-1))c = pow(bytes_to_long(flag.encode()), e, n)d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804</code></pre><h4><span id="已知ed爆破解题代码">已知ed爆破解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import *from bitarray import bitarrayimport gmpy2 as gpimport sympye =d =c =ed = bitarray(bin(e*d - 1) [2:])print(&quot;ed =&quot;, ed) # 2065count = 0for k in range(pow(2,15),pow(2,16)):    if (e*d - 1 ) % k == 0:        count += 1        phi = (e*d - 1) // k        p = sympy.prevprime(gp.iroot(phi,2) [0])        q = sympy.nextprime(p)        #print(&quot;count =&quot;, count, &quot;phi =&quot;, phi)        if (p - 1) * (q - 1) == phi:            print(&quot;Found p and q:&quot;)            print(&quot;p =&quot;, p)            print(&quot;q =&quot;, q)            breakn = p * qm = pow(c, d, n)print(long_to_bytes(m))</code></pre><h2><span id="rsa-e和phi不互质">RSA e和phi不互质</span></h2><h3><span id="e和phi不互质出题思路">e和phi不互质出题思路</span></h3><p>这情况下，解密时用e/gcd(e,phi)，并且m也开gcd(e,phi)次方</p><h3><span id="e和phi不互质例题">e和phi不互质例题</span></h3><h4><span id="e和phi不互质题目">e和phi不互质题目</span></h4><pre><code class="lang-python">from gmpy2 import lcm , powmod , invert , gcd , mpzfrom Crypto.Util.number import getPrimefrom sympy import nextprimefrom random import randintp = getPrime(1024)q = getPrime(1024)n = p * qgift = lcm(p - 1 , q - 1) #最小公倍数，所以phi为gift的偶数倍e = 54722flag = b&#39;NPUCTF{******************}&#39;m = int.from_bytes(flag , &#39;big&#39;)c = pow(m , e , n)print(&#39;n: &#39; , n)print(&#39;gift: &#39; , gift)print(&#39;c: &#39; , c)n =  17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121gift =  2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104c =  3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319</code></pre><h4><span id="e和phi不互质解题代码">e和phi不互质解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import inverse,long_to_bytesfrom math import gcdimport gmpy2 as gpn =gift =c =e =for k in range(1,1000000):    phi = 2*k*gift    if phi &lt; n -1:        g = gcd(phi,e)        e_true = e // g        phi_true = phi // g        d = inverse(e_true, phi_true)        m = pow(c, d, n)        m_true = gp.iroot(m, g) [0]        m_bytes = long_to_bytes(m_true)        print(f&quot;Trying k={k}: {m_bytes}\n&quot;)</code></pre><h2><span id="rsa-欧拉函数相关运用">RSA 欧拉函数相关运用</span></h2><h3><span id="欧拉函数相关运用出题思路">欧拉函数相关运用出题思路</span></h3><p>明确欧拉函数的定义<br>$m ^ e \equiv c \ (\bmod \ n)$<br>$c ^ d \equiv m \ (\bmod \ n)$<br>将n分解为所有质因数的乘积，然后算出$\phi(n)$,才有关系<br>$e × d \equiv 1 \ (\bmod \ \phi(n))$</p><p>关于欧拉函数有如下公式：<br>$\phi(n) = \prod_{i=1}^{m} \phi(n_i)$<br>$\phi(p^k) = p^{k-1}\phi(p)$<br>$\phi(p) = p-1$</p><h3><span id="欧拉函数相关运用例题">欧拉函数相关运用例题</span></h3><h4><span id="欧拉函数相关运用题目">欧拉函数相关运用题目</span></h4><pre><code class="lang-python">import sympyimport randomfrom gmpy2 import gcd, invertfrom Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytesfrom z3 import *flag = b&quot;MRCTF{xxxx}&quot;base = 65537def GCD(A):    B = 1    for i in range(1, len(A)):        B = gcd(A[i-1], A[i])    return Bdef gen_p():    P = [0 for i in range(17)]    P[0] = getPrime(128)    for i in range(1, 17):        P[i] = sympy.nextprime(P[i-1])    print(&quot;P_p :&quot;, P[9])    n = 1    for i in range(17):        n *= P[i]    p = getPrime(1024)    factor = pow(p, base, n)    print(&quot;P_factor :&quot;, factor)    return sympy.nextprime(p)def gen_q():    sub_Q = getPrime(1024)    Q_1 = getPrime(1024)    Q_2 = getPrime(1024)    Q = sub_Q ** Q_2 % Q_1    print(&quot;Q_1: &quot;, Q_1)    print(&quot;Q_2: &quot;, Q_2)    print(&quot;sub_Q: &quot;, sub_Q)    return sympy.nextprime(Q)if __name__ == &quot;__main__&quot;:    _E = base    _P = gen_p()    _Q = gen_q()    assert (gcd(_E, (_P - 1)*(_Q - 1)) == 1)    _M = bytes_to_long(flag)    _C = pow(_M,_E, _P*_Q)    print(&quot;Ciphertext = &quot;, _C)&#39;&#39;&#39;P_p : 206027926847308612719677572554991143421P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839Q_1:  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521Q_2:  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743sub_Q:  168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832&#39;&#39;&#39;</code></pre><h4><span id="欧拉函数相关运用解题代码">欧拉函数相关运用解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inverseimport sympyQ_1 =Q_2 =sub_Q =Q = pow(sub_Q, Q_2, Q_1)q = sympy.nextprime(Q)print(&quot;q=&quot;, q)P_p =f1 = P_pf2 = P_pP_factor =P=[0 for i in range(17)]for i in range(9):    P_p=sympy.prevprime(P_p)P[0] = P_pfor i in range(1, 17):    P[i] = sympy.nextprime(P[i-1])n=1phi=1for i in range(17):    n*=P[i]    phi*=(P[i]-1)base = 65537inv_base = inverse(base,phi)p = sympy.nextprime(pow(P_factor, inv_base, n))print(&quot;p=&quot;, p)e = based = inverse(e, (p - 1)*(q - 1))Ciphertext =m = pow(Ciphertext,d,p*q)print(long_to_bytes(m))</code></pre><h2><span id="rsa-简单pem分解">RSA 简单pem分解</span></h2><h3><span id="简单pem分解出题思路">简单pem分解出题思路</span></h3><p>直接给出pem格式的公钥文件，要求分解出n和e，然后解密<br>注意格式，尝试用cryptography库</p><h3><span id="简单pem分解例题">简单pem分解例题</span></h3><h4><span id="简单pem分解题目">简单pem分解题目</span></h4><p>——-BEGIN PUBLIC KEY——-<br>MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+<br>/AvKr1rzQczdAgMBAAE=<br>——-END PUBLIC KEY——-</p><h4><span id="简单pem分解解题代码">简单pem分解解题代码</span></h4><pre><code class="lang-python">from Crypto.PublicKey import RSAfrom Crypto.Util.number import inverse,long_to_bytesfrom cryptography.hazmat.primitives import serialization #把PEM公钥内容复制到这里（包含BEGIN/END部分）pem_public_key = &quot;&quot;&quot;   &quot;&quot;&quot; #加载PEM公钥并提取e和npublic_key = serialization.load_pem_public_key(    pem_public_key.encode(&quot;utf-8&quot;)  # 转换为字节流)public_numbers = public_key.public_numbers() #输出结果print(&quot;公钥指数 e =&quot;, public_numbers.e)print(&quot;模数 n =&quot;, public_numbers.n)n = public_numbers.ne = public_numbers.ep = 285960468890451637935629440372639283459q = 304008741604601924494328155975272418463phi = (p - 1) * (q - 1)d = inverse(e, phi)print(&quot;私钥指数 d =&quot;, d)with open(r&quot;flag.enc&quot;,&quot;rb&quot;) as f:    c = f.read()m = pow(int.from_bytes(c, &#39;big&#39;), d, n)print(&quot;明文 m =&quot;, long_to_bytes(m))</code></pre><h2><span id="rsa-wiener攻击">RSA wiener攻击</span></h2><h3><span id="wiener攻击出题思路">wiener攻击出题思路</span></h3><p>wiener攻击是针对d非常小的RSA私钥的攻击方法<br>通过连分数逼近e/n，找到可能的k/d对，从而计算出phi和n的因子<br>特征是与n大小非常接近的e值</p><h3><span id="wiener攻击例题">wiener攻击例题</span></h3><h4><span id="wiener攻击题目">wiener攻击题目</span></h4><pre><code class="lang-python">N = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085import hashlibflag = &quot;flag{&quot; + hashlib.md5(hex(d)).hexdigest() + &quot;}&quot;#### wiener攻击解题代码 #sage运行得到d&quot;&quot;&quot;def recover(e, N):    e = Integer(e)    N = Integer(N)    cf = continued_fraction(e / N).convergents()    G.&lt;x&gt; = ZZ[&#39;x&#39;]    for k_frac in cf[1:]:        d0 = k_frac.denominator()        k = k_frac.numerator()        if k == 0 or d0 == 0:            continue        if (e * d0 - 1) % k != 0:            continue        phi = (e * d0 - 1) // k        s = N - phi + 1        f = x^2 - s*x + N        discriminant = f.discriminant()        if discriminant &lt;= 0 or not discriminant.is_square():            continue        roots = f.roots(multiplicities=False)        roots = [Integer(root) for root in roots if root.is_integer()]        if len(roots) == 2 and roots[0] * roots[1] == N:            p, q = roots            true_phi = (p - 1) * (q - 1)            if (e * d0) % true_phi == 1:                print(f&quot;[x] 恢复成功！&quot;)                print(f&quot;d = {d0}&quot;)                print(f&quot;d (十六进制) = {hex(d0)}&quot;)                print(f&quot;p = {p}&quot;)                print(f&quot;q = {q}&quot;)                print(f&quot;phi(N) = {true_phi}&quot;)                print(f&quot;验证：e*d \bmod phi(N) = {(e*d0) % true_phi}（应为1）&quot;)                return d0  # 返回正确的d    print(&quot;[-] 恢复失败&quot;)    return Noned = recover(e,N)&quot;&quot;&quot;N = e = import hashlibd = d_hex = hex(d)md5_input = d_hex[2:].encode()  # 去掉 &#39;0x&#39; 前缀并编码为字节md5_hash = hashlib.md5(md5_input).hexdigest()flag =&quot;flag{&quot; + md5_hash + &quot;}&quot;print(flag)</code></pre><h2><span id="rsa-dp泄露">RSA dp泄露</span></h2><h3><span id="dp泄露出题思路">dp泄露出题思路</span></h3><p>如果我们已知dp，则可以推导出关系<br>$dp \equiv d \ (\bmod \ p-1)$<br>$e × d \equiv 1 \ (\bmod \ (p-1)(q-1))$<br>结合关系可得到<br>$e × dp \equiv 1 \ (\bmod \ (p-1))$</p><h3><span id="dp泄露例题一e较小时可以爆破">dp泄露例题一(e较小时可以爆破)</span></h3><h4><span id="dp泄露题目一">dp泄露题目一</span></h4><pre><code class="lang-python">e = 65537n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825</code></pre><h4><span id="dp泄露解题代码一">dp泄露解题代码一</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytesimport gmpy2 as gpe = 65537n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825for k in range(2,e):    if (e*dp - 1) % k == 0:        p = (e*dp - 1) // k + 1        print(f&quot;p = {p}&quot;)        q = n // p        print(f&quot;q = {q}&quot;)        phi = (p-1)*(q-1)        d = gp.invert(e, phi)        m = pow(c, d, n)        print(f&quot;m = {m}&quot;)        flag = long_to_bytes(m)        print(f&quot;flag = {flag}&quot;)</code></pre><h3><span id="dp泄露例题二e较大时小费马定理">dp泄露例题二(e较大时小费马定理)</span></h3><h4><span id="小费马定理">小费马定理</span></h4><p>如果p是一个质数，整数a不是p的倍数，那么<br>$a^{p-1} \equiv 1 \ (\bmod \ p)$</p><p>RSA中的运用<br>$e × dp \equiv 1 \ (\bmod \ (p-1))$<br>由$e × dp = 1 + k(p-1)$<br>则$a^{e×dp} \equiv a \cdot (a^{p-1})^k$</p><p>带入小费马定理得<br>$a^{e×dp} \equiv a \cdot 1^k \equiv a \ (\bmod \ p)$</p><p>令a = 2，显然与p互质<br>$2^{e×dp} \equiv 2 \ (\bmod \ p)$<br>故找到$2^{e×dp} - 2$和n的最大公约数即可得到p</p><h4><span id="dp泄露题目二">dp泄露题目二</span></h4><pre><code class="lang-python">c = 82404436498466895324733436901056359489189960512493202570903960333247277400247388969097533191635462377037232768074464944681385506170855774688613792302290304494481765906529480985984818897269069587516233500512849282866396228645039453616712857020451120948641770106851301755195757766245239907077580562163260112662n_hex = &quot;0x9d034fa9ab29cabdcdff047e688e751704c756cbd2f38bd4f049a3a0889ea4cbffd006b58608d6a7f7c09835ca0abb1db23ad1ca223c54acf87e2dd823996fbfa5a58f272ae7a10c394aa0fe16fa8d4e31bb024bf1f93517c8c7e52fdaa876b58111b97fc66374d506e2be8dfaf94d6614307ee8b10d93fdc1c165c7563d03bd&quot;e_hex = &quot;0xbeed55cdffde31057bea5a58a3684d5fbed81f03d53fa28bb658b32de4535c8d&quot;dp_hex = &quot;0x26b285848e6997fa01376059a8b4dff8d69c1aa4c5af399b8bb45515a378de45d85eed75bab5f22d39dc7c95c1a5186d18576c2f7d638acc21898469f728d3fb&quot;</code></pre><h4><span id="dp泄露解题代码二">dp泄露解题代码二</span></h4><pre><code class="lang-python">p = gp.gcd((pow(2,e*dp,n) -2) ,n) #核心步骤q = n // pif n == p * q and p &gt; 1 and q &gt; 1:    print(&quot;成功分解n:&quot;)    print(&quot;p =&quot;, p)    print(&quot;q =&quot;, q)    phi = (p - 1) * (q - 1)    d = gp.invert(e, phi)    m = pow(c, d, n)    print(long_to_bytes(m))</code></pre><h2><span id="rsa-密文填充">RSA 密文填充</span></h2><h3><span id="密文填充出题思路">密文填充出题思路</span></h3><p>RSA加密前对明文进行填充，常见的填充方式有PKCS#1 v1.5和OAEP<br>使用Crypto.Cipher库进行去填充化</p><h3><span id="密文填充例题">密文填充例题</span></h3><h4><span id="密文填充题目">密文填充题目</span></h4><p>——-BEGIN PUBLIC KEY——-<br>MIIBJDANBgkqhkiG9w0BAQEFAAOCAREAMIIBDAKCAQMlsYv184kJfRcjeGa7Uc/4<br>3pIkU3SevEA7CZXJfA44bUbBYcrf93xphg2uR5HCFM+Eh6qqnybpIKl3g0kGA4rv<br>tcMIJ9/PP8npdpVE+U4Hzf4IcgOaOmJiEWZ4smH7LWudMlOekqFTs2dWKbqzlC59<br>NeMPfu9avxxQ15fQzIjhvcz9GhLqb373XDcn298ueA80KK6Pek+3qJ8YSjZQMrFT<br>+EJehFdQ6yt6vALcFc4CB1B6qVCGO7hICngCjdYpeZRNbGM/r6ED5Nsozof1oMbt<br>Si8mZEJ/Vlx3gathkUVtlxx/+jlScjdM7AFV5fkRidt0LkwosDoPoRz/sDFz0qTM<br>5q5TAgMBAAE=<br>——-END PUBLIC KEY——-</p><p>flag.enc =<br>‘GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW/MgPwxVBSl46joFCQ1plcnlDGfL19K/3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK/1EYU7NzrhGE7J5jPdi0Aj7xi/Odxy0hGMgpaBLd/nL3N8O6i9pc4Gg3O8soOlciBG/6/xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA==’</p><h4><span id="密文填充解题代码">密文填充解题代码</span></h4><pre><code class="lang-python">from cryptography.hazmat.primitives import serializationfrom Crypto.Util.number import inverse,long_to_bytesfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.PublicKey import RSApem_public_key = &quot;&quot;&quot;   &quot;&quot;&quot;public_key = serialization.load_pem_public_key(    pem_public_key.encode(&quot;utf-8&quot;)  )public_numbers = public_key.public_numbers()print(&quot;公钥指数 e =&quot;, public_numbers.e)print(&quot;模数 n =&quot;, public_numbers.n)# Attempt OAEP unpadding (SHA1 and SHA256) on the raw decrypted block.import hashlib, binasciiimport base64# Re-use previous variables from the last run if available; else reinitialize.# For safety, reassign here:n = public_numbers.ne = public_numbers.ep =     q = c_b64 = c_bytes = base64.b64decode(c_b64)c_int = int.from_bytes(c_bytes,&#39;big&#39;)c = c_intd = inverse(e, (p-1)*(q-1))m = pow(c, d, n)print(long_to_bytes(m))key = RSA.construct((n,e,d,p,q))cipher = PKCS1_OAEP.new(key)decrypted = cipher.decrypt(c_bytes)print(decrypted)</code></pre><h2><span id="rsa-中国剩余定理ctr攻击">RSA 中国剩余定理CTR攻击</span></h2><h3><span id="中国剩余定理ctr攻击出题思路">中国剩余定理CTR攻击出题思路</span></h3><p>利用CRT加速RSA解密的特性，用多个不同模数进行加密，得到多个密文<br>关系如下<br>$c_1 \equiv m^e \ (\bmod \ n_1)$<br>$c_2 \equiv m^e \ (\bmod \ n_2)$<br>$c_3 \equiv m^e \ (\bmod \ n_3)$<br>通过CRT将这些同余方程合并成一个方程，然后使用e次根<br>$N = n_1 × n_2 × n_3$<br>$m^e \equiv c_1×M_1 + c_2×M_2 + c_3×M_3 \ (\bmod \ N)$<br>其中$M_i = N/n_i × [(N/n_i)^{-1} \ (\bmod \ n_i)]$以此类推</p><h3><span id="中国剩余定理ctr攻击例题">中国剩余定理CTR攻击例题</span></h3><h4><span id="中国剩余定理ctr攻击题目">中国剩余定理CTR攻击题目</span></h4><pre><code class="lang-python">N = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004 c = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243N = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114 c = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344N = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323 c = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242</code></pre><h4><span id="中国剩余定理ctr攻击解题代码">中国剩余定理CTR攻击解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytesimport gmpy2n1 = int(&#39;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#39;,5)c1 = int(&#39;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#39;,5)n2 = int(&#39;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#39;,5)c2 = int(&#39;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#39;,5)n3 = int(&#39;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#39;,5)c3 = int(&#39;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#39;,5)M1=n2*n3*gmpy2.invert(n2*n3,n1)M2=n1*n3*gmpy2.invert(n1*n3,n2)M3=n1*n2*gmpy2.invert(n1*n2,n3)num=c1*M1+c2*M2+c3*M3me=num%(n1*n2*n3)print(long_to_bytes(me))for e in range(2,10000000):    m, ok= gmpy2.iroot(me, e)    if ok:        breakprint(long_to_bytes(int(m)))</code></pre><h2><span id="rsa-多n分解公因数">RSA 多n分解公因数</span></h2><h3><span id="多n分解公因数出题思路">多n分解公因数出题思路</span></h3><p>特征有非常多的密文和模数，尝试看看会不会有n有相同的公因数</p><h3><span id="多n分解公因数例题">多n分解公因数例题</span></h3><h4><span id="多n分解公因数题目">多n分解公因数题目</span></h4><pre><code class="lang-python">m = xxxxxxxxe = 65537========== n c ==========n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346</code></pre><h4><span id="多n分解公因数解题代码">多n分解公因数解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes,inversefrom math import gcde = 65537n=[n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19]c=[c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19]for i in range(len(n)):    for j in range(len(n)):        if(i!=j):            if(gcd(n[i],n[j])!=1):   #对不同的n进行 欧几里得算法，以求出最大公约数(p)                print(i,j)                 #输出对应的n的序号                            p = gcd(n[i],n[j])                print(&quot;p = &quot;,p)                q = n[i] // p                print(&quot;q = &quot;,q)                d = inverse(e , (p-1)*(q-1))                print(&quot;d = &quot;,d)                m = pow(c[i],d,n[i])                print(&quot;m = &quot;,m)print(long_to_bytes(m))</code></pre><h2><span id="rsa-破损私钥恢复">RSA 破损私钥恢复</span></h2><h3><span id="rsa破损私钥恢复出题思路">RSA破损私钥恢复出题思路</span></h3><h4><span id="rsa私钥pem结构">RSA私钥pem结构</span></h4><p>在文件进行base64解码后，可以看到pem文件的结构如下：</p><p>RSAPrivateKey ::= SEQUENCE {<br>    version           Version,     0表示两个素数的RSA  1表示多素数的RSA<br>    modulus           INTEGER,  — n<br>    publicExponent    INTEGER,  — e<br>    privateExponent   INTEGER,  — d<br>    prime1            INTEGER,  — p<br>    prime2            INTEGER,  — q<br>    exponent1         INTEGER,  — d mod (p-1) dp<br>    exponent2         INTEGER,  — d mod (q-1) dq<br>    coefficient       INTEGER,  — (inverse of q) mod p<br>    otherPrimeInfos   OtherPrimeInfos OPTIONAL<br>}</p><p>十六进制格式如下：<br>表示头 30<br>表示长度 82 xx xx<br>版本信息 02 01 00<br>n 02 xx xx<br>e 02 xx<br>d 02 xx xx<br>p 02 xx<br>q 02 xx<br>dp 02 xx<br>dq 02 xx<br>inv 02 xx<br>如果数据长度超过128字节，则长度部分会多出两个字节表示实际长度</p><h3><span id="破损私钥恢复例题">破损私钥恢复例题</span></h3><h4><span id="破损私钥恢复题目">破损私钥恢复题目</span></h4><pre><code class="lang-python">cipher = 82404436498466895324733436901056359489189960512493202570903960333247277400247388969097533191635462377037232768074464944681385506170855774688613792302290304494481765906529480985984818897269069587516233500512849282866396228645039453616712857020451120948641770106851301755195757766245239907077580562163260112662&quot;&quot;&quot;-----BEGIN RSA PRIVATE KEY-----MIICewIBAAKBgQCdA0+pqynKvc3/BH5ojnUXBMdWy9Lzi9TwSaOgiJ6ky//QBrWGCNan98CYNcoKux2yOtHKIjxUrPh+LdgjmW+/paWPJyrnoQw5SqD+FvqNTjG7Akvx+TUXyMflL9qodrWBEbl/xmN01Qbivo36+U1mFDB+6LENk/3BwWXHVj0DvQIhAL7tVc3/3jEFe+paWKNoTV++2B8D1T+ii7ZYsy3kU1yNAoGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkCQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwJAJrKFhI5pl/oBN2BZqLTf+NacGqTFrzmbi7RVFaN43kXYXu11urXyLTncfJXBpRhtGFdsL31jiswhiYRp9yjT+wJBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-----END RSA PRIVATE KEY-----&quot;&quot;&quot;</code></pre><h4><span id="破损私钥恢复解题代码">破损私钥恢复解题代码</span></h4><pre><code class="lang-python">from base64 import b64decodeimport binasciifrom Crypto.Util.number import long_to_bytesimport gmpy2 as gps = &quot;&quot;&quot;&quot;&quot;&quot;s = b64decode(s)print(binascii.hexlify(s))&quot;&quot;&quot;3082027b020100028181 #n009d034fa9ab29cabdcdff047e688e751704c756cbd2f38bd4f049a3a0889ea4cbffd006b58608d6a7f7c09835ca0abb1db23ad1ca223c54acf87e2dd823996fbfa5a58f272ae7a10c394aa0fe16fa8d4e31bb024bf1f93517c8c7e52fdaa876b58111b97fc66374d506e2be8dfaf94d6614307ee8b10d93fdc1c165c7563d03bd0221   #e00beed55cdffde31057bea5a58a3684d5fbed81f03d53fa28bb658b32de4535c8d028180 #d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090241   #p00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000241   #q00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030240   #dp26b285848e6997fa01376059a8b4dff8d69c1aa4c5af399b8bb45515a378de45d85eed75bab5f22d39dc7c95c1a5186d18576c2f7d638acc21898469f728d3fb0241   #dq00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030241   #inv0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;&quot;&quot;c = 82404436498466895324733436901056359489189960512493202570903960333247277400247388969097533191635462377037232768074464944681385506170855774688613792302290304494481765906529480985984818897269069587516233500512849282866396228645039453616712857020451120948641770106851301755195757766245239907077580562163260112662n_hex = &quot;0x9d034fa9ab29cabdcdff047e688e751704c756cbd2f38bd4f049a3a0889ea4cbffd006b58608d6a7f7c09835ca0abb1db23ad1ca223c54acf87e2dd823996fbfa5a58f272ae7a10c394aa0fe16fa8d4e31bb024bf1f93517c8c7e52fdaa876b58111b97fc66374d506e2be8dfaf94d6614307ee8b10d93fdc1c165c7563d03bd&quot;n = int(n_hex,16)e_hex = &quot;0xbeed55cdffde31057bea5a58a3684d5fbed81f03d53fa28bb658b32de4535c8d&quot;e = int(e_hex,16)dp_hex = &quot;0x26b285848e6997fa01376059a8b4dff8d69c1aa4c5af399b8bb45515a378de45d85eed75bab5f22d39dc7c95c1a5186d18576c2f7d638acc21898469f728d3fb&quot;dp = int(dp_hex,16)p = gp.gcd((pow(2,e*dp,n) -2) ,n)q = n // pif n == p * q and p &gt; 1 and q &gt; 1:    print(&quot;成功分解n:&quot;)    print(&quot;p =&quot;, p)    print(&quot;q =&quot;, q)    phi = (p - 1) * (q - 1)    d = gp.invert(e, phi)    m = pow(c, d, n)    print(long_to_bytes(m))</code></pre><h2><span id="rsa-勒让德符号应用">RSA 勒让德符号应用</span></h2><h3><span id="二次剩余定义">二次剩余定义</span></h3><p>若存在整数x使得$x^2 \equiv a \ (\bmod \ p)$(p为奇素数)，则称a为模p的二次剩余，方程无解称为二次非剩余。</p><h3><span id="欧拉判别法与勒让德符号">欧拉判别法与勒让德符号</span></h3><p>设p为奇素数，a为整数，则<br>$a^{\frac{p-1}{2}} \equiv \left(\frac{a}{p}\right) \ (\bmod \ p)$</p><p>其中，$\left(\frac{a}{p}\right)$为勒让德符号，定义如下：<br>$\left(\frac{a}{p}\right) = 0$，若p整除a<br>$\left(\frac{a}{p}\right) = 1$，若a为模p的二次剩余<br>$\left(\frac{a}{p}\right) = -1$，若a为模p的二次非剩余</p><p>推导使用费马小定理转化为方程<br>$a^{p-1} \equiv 1 \ (\bmod \ p)$<br>$\left(\frac{a}{p}\right)$即为下面方程的解<br>$x^2 \equiv 1 \ (\bmod \ p)$</p><h3><span id="rsa勒让德符号应用例题">RSA勒让德符号应用例题</span></h3><h4><span id="勒让德符号应用题目">勒让德符号应用题目</span></h4><pre><code class="lang-python">from Crypto.Util.number import *from secret import flagdef gift(m, prime):    return pow(m, (prime + 1) // 2, prime)m = bytes_to_long(flag)p = getPrime(256)q = getPrime(256)print(f&#39;p = {p}&#39;)print(f&#39;q = {q}&#39;)print(f&#39;gift1 = {gift(m, p)}&#39;)print(f&#39;gift2 = {gift(m, q)}&#39;)# p = 71380997427449345634700552609577271052193856747526826598031269184817312570231# q = 65531748297495117965939047069388412545623909154912018722160805504300279801251# gift1 = 40365143212042701723922505647865230754866250738391105510918441288000789123995# gift2 = 10698628345523517254945893573969253712072344217500232111817321788145975103342</code></pre><h4><span id="勒让德符号应用解题代码">勒让德符号应用解题代码</span></h4><pre><code class="lang-python">from Crypto.Util.number import long_to_bytes, inverseimport gmpy2 as gpp =q =gift1 =gift2 =mp_list = [gift1, -gift1 % p]mq_list = [gift2, -gift2 % q]for mp in mp_list:    print(long_to_bytes(mp))for mq in mq_list:    print(long_to_bytes(mq))for mp in mp_list:    for mq in mq_list:        m = mp*inverse(q, p)*q + mq*inverse(p, q)*p        m = m % (p * q)        print(long_to_bytes(m))</code></pre><h2><span id="rsa-衍生rabin算法">RSA 衍生Rabin算法</span></h2><h3><span id="rabin算法简介">Rabin算法简介</span></h3><p>Rabin算法是算是RSA的一个特例，e取一个固定值2<br>Rabin的密文与明文并不是一一对应的关系，同一个密文可能解出多种不同的明文<br>Rabin的安全性取决于求解模平方根的难度，破解难度与分解大整数的难度相当</p><p>密文：$c = m^2 \ (\bmod \ n)$</p><p>解密：</p><p>$c = m^2 \ (\bmod \ p)$<br>$c = m^2 \ (\bmod \ q)$</p><p>Tonelli-Shanks算法计算$m_p$和$m_q$：<br>分解$p-1 = q \cdot 2^s$，其中$q$为奇数<br>找到一个$z$，满足模$p$的二次非剩余，计算$c^s$和$z^s$<br>计算$x$，使得$(z^s)^x \equiv c^s \ (\bmod \ p)$<br>计算$k=z^{\frac{sx}{2}} \ (\bmod \ p)$<br>则有解$ \pm kc^{-q}$</p><pre><code class="lang-python">def tonelli(n, p):    if n == 0:        return 0    if pow(n, (p - 1) // 2, p) != 1:        print(&quot;No square root exists&quot;)        return None    if p % 4 == 3:        return pow(n, (p + 1) // 4, p)    q = p - 1    s = 0    while q % 2 == 0:        s += 1        q //= 2    z = 2    while pow(z, (p - 1) // 2, p) != p - 1:        z += 1    c = pow(z, q, p)    x = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    while t != 1:        i = 1        t2 = pow(t, 2, p)        while t2 != 1:            t2 = pow(t2, 2, p)            i += 1        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        x = (x * b) % p        t = (t * b * b) % p        c = (b * b) % p        m = i    return x&quot;&quot;&quot;计算p的k次方模平方根用henell-lift方法from Crypto.Util.number import inverseb = tonelli(n, p)t = 1while (t != k):    v = ((a - b*b)//pow(p,t)) % p    c = (b + pow(p,t)*inverse(2*b, p)*v) % pow(p,t+1)    b = c    t += 1print(c)&quot;&quot;&quot;</code></pre><p>特别的，如果$p \equiv 3 \ (\bmod \ 4)且 q \equiv 3 \ (\bmod \ 4)$，则<br>$m_p = c^{\frac{p+1}{4}} \ (\bmod \ p)$<br>$m_q = c^{\frac{q+1}{4}} \ (\bmod \ q)$</p><p>用扩展欧几里得算法计算出$y_p$和$y_q$，满足<br>$y_p \cdot p + y_q \cdot q = 1$</p><p>解出四个明文：<br>$a = (y_p \cdot p \cdot m_q + y_q \cdot q \cdot m_p) \ (\bmod \ n)$<br>$b = n - a$<br>$c = (y_p \cdot p \cdot m_q - y_q \cdot q \cdot m_p) \ (\bmod \ n)$<br>$d = n - c$</p><h3><span id="rabin算法例题">Rabin算法例题</span></h3><h4><span id="rabin算法题目">Rabin算法题目</span></h4><pre><code class="lang-python">from Crypto.Util.number import *from secret import flagp = getPrime(64)q = getPrime(64)assert p % 4 == 3assert q % 4 == 3n = p * qe = 2m = bytes_to_long(flag)c = pow(m,e,n)print(&#39;n =&#39;, n)print(&#39;c =&#39;, c)# n = 201354090531918389422241515534761536573# c = 20442989381348880630046435751193745753</code></pre><h4><span id="rabin算法解题代码">Rabin算法解题代码</span></h4><pre><code class="lang-python">import gmpy2 as gpfrom Crypto.Util.number import long_to_bytese = 2n = 201354090531918389422241515534761536573c = 20442989381348880630046435751193745753p = 13934102561950901579q = 14450452739004884887g, y_p, y_q = gp.gcdext(p, q)m_p = pow(c,(p + 1) // 4, p)m_q = pow(c,(q + 1) // 4, q)a = (y_p * p * m_q + y_q * q * m_p) % nb = n - ac = (y_p * p * m_q - y_q * q * m_p) % nd = n - cprint(long_to_bytes(a))print(long_to_bytes(b))print(long_to_bytes(c))print(long_to_bytes(d))</code></pre><h2><span id="rsa-模数光滑">RSA 模数光滑</span></h2><h3><span id="rsa模数光滑出题思路">RSA模数光滑出题思路</span></h3><p>光滑数的定义：若一个正整数n的所有素因子均小于等于某一给定正整数B，则称n为B-光滑数<br>当p - 1或q - 1是光滑数时，可以使用Pollard’s p-1算法分解n，从而破解RSA<br>当p + 1或q + 1是光滑数时，可以使用Williams’s p + 1算法分解n，从而破解RSA</p><h3><span id="rsa模数光滑例题">RSA模数光滑例题</span></h3><h4><span id="rsa模数光滑题目">RSA模数光滑题目</span></h4><pre><code class="lang-python">n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</code></pre><h4><span id="rsa模数光滑解题代码">RSA模数光滑解题代码</span></h4><pre><code class="lang-python"># williams&#39;s p+1 factorizationdef mlucas(v, a, n):    v1, v2 = v, (v ** 2 - 2) % n    for bit in bin(a)[3:]:        if bit == &quot;0&quot;:            v1, v2 = (v1 ** 2 - 2) % n, (v1 * v2 - v) % n        else:            v1, v2 = (v1 * v2 - v) % n, (v2 ** 2 - 2) % n    return v1# 素数生成器def primegen():    yield from primerange(2, 10**6)  # 生成到 10^6 的素数，够用了# 整数对数：ilog(x, b) = 最大整数 l，使得 b^l &lt;= xdef ilog(x, b):    l = 0    while x &gt;= b:        x //= b        l += 1    return l# Williams p+1 分解攻击def Williams_p_plus_1_attack(n):    for v in count(1):  # 不断尝试新的 v        for p in primegen():            e = ilog(isqrt(n), p)            if e == 0:                break            for _ in range(e):                v = mlucas(v, p, n)            g = gcd(v - 2, n)            if 1 &lt; g &lt; n:                return int(g), int(n // g)            if g == n:                break# 开始攻击p1, q1 = Williams_p_plus_1_attack(n)if p1 and q1:    print(&quot;williams&#39;s p+1 factorization successful!&quot;)    print(f&quot;p = {p1}&quot;)    print(f&quot;q = {q1}&quot;)# pollard&#39;s p-1 factorizationdef pollard_p_minus_1(n, B=10**5): # B为素数表的上限,可以根据实际往上调    a = 2  # 通常选2作为基    for p in primerange(2, B):        e = int(isqrt(n).bit_length() / p.bit_length())        a = pow(a, pow(p, e), n)    g = gcd(a - 1, n)    if 1 &lt; g &lt; n:        return g, n // g    else:        return Nonep2, q2 = pollard_p_minus_1(n)if p2 and q2:    print(&quot;pollard&#39;s p-1 factorization successful!&quot;)    print(f&quot;p = {p2}&quot;)    print(f&quot;q = {q2}&quot;)</code></pre><h2><span id="rsa-d泄露攻击">RSA d泄露攻击</span></h2><h3><span id="rsa-d泄露出题思路">RSA d泄露出题思路</span></h3><p>首先，已知RSA的公钥(e, n)和私钥d满足以下关系：<br>$e \cdot d \equiv 1 \ (\bmod \ \phi(n))$<br>所以，存在整数k，使得<br>$e \cdot d - 1 = k \cdot \phi(n)$<br>又$ \forall a \in Z_n^*$，满足$a^{ed - 1} \equiv 1 \ (\bmod \ n)$<br>令$a^{ed - 1} - 1 \equiv 2^{s}t $，其中，$t$为奇数<br>可以证明至少一半的$a$满足，存在$i \in [1, s]$，使得<br>$a^{2^{i}t} \equiv 1 \ (\bmod \ n)$<br>如果$a,i$满足上述条件，则gcd$(a^{2^{i}t} - 1, n)$为n的非平凡因子</p><h3><span id="rsa-d泄露例题">RSA d泄露例题</span></h3><h4><span id="rsa-d泄露题目">RSA d泄露题目</span></h4>]]></content>
      
      
      <categories>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
            <tag> 题型总结 </tag>
            
            <tag> 现代密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学笔记</title>
      <link href="/myblog.github.io/post/undefined.html"/>
      <url>/myblog.github.io/post/undefined.html</url>
      
        <content type="html"><![CDATA[<h2><span id="古典密码">古典密码</span></h2><p>常见的古典密码在计算机时代大部分可以通过计算机的算法完成爆破类似的解密</p><h3><span id="单表替换密码">单表替换密码</span></h3><h4><span id="caesar-cipher-凯撒密码">Caesar Cipher 凯撒密码</span></h4><p>对于26个字母进行数字映射(a—&gt;0)，然后对于明文映射后加上同一个密钥n，得到密文<br>破解同理转化为数字映射然后同时减去n即可</p><p>加密函数：<br>$E_k(x) ≡ (x + k) \ mod \ 26$<br>解密函数：<br>$D_k(x) ≡ (x - k) \ mod \ 26$</p><h5><span id="凯撒加密代码实现">凯撒加密代码实现</span></h5><pre><code class="lang-python">def caesar_encrypt(plaintext, shift):    &quot;&quot;&quot;    凯撒密码加密函数    :param plaintext: 明文(需要加密的字符串)    :param shift: 移位量(整数，可正可负，正表示向后移，负表示向前移)    :return: 密文(加密后的字符串)    &quot;&quot;&quot;    ciphertext = &quot;&quot;  # 存储最终的密文    for char in plaintext:  # 遍历明文中的每个字符        # 处理小写字母(a-z)        if char.islower():            # 1. 字母转数字：a→0, b→1, ..., z→25(ord(&#39;a&#39;)=97，减去97得到0-25)            char_num = ord(char) - ord(&#39;a&#39;)            # 2. 移位运算：(原数字 + 移位量) %26(循环移位)            encrypted_num = (char_num + shift) % 26            # 3. 数字转字母：0→a, 1→b, ..., 25→z(加上97还原为小写字母的ASCII码)            encrypted_char = chr(encrypted_num + ord(&#39;a&#39;))            ciphertext += encrypted_char        # 处理大写字母(A-Z)        elif char.isupper():            # 同理：A→0, B→1, ..., Z→25(ord(&#39;A&#39;)=65，减去65得到0-25)            char_num = ord(char) - ord(&#39;A&#39;)            encrypted_num = (char_num + shift) % 26            encrypted_char = chr(encrypted_num + ord(&#39;A&#39;))            ciphertext += encrypted_char        # 非字母字符(数字、空格、符号等)直接保留        else:            ciphertext += char    return ciphertextif __name__ == &quot;__main__&quot;:    # 自定义明文和移位量    plaintext = &quot;Hello, Caesar Cipher! 123&quot;  # 包含大小写、符号、数字    shift = 3  # 经典凯撒密码移位量(可修改为任意整数，如5、-2等)    # 调用加密函数    ciphertext = caesar_encrypt(plaintext, shift)    # 输出结果    print(f&quot;明文：{plaintext}&quot;)    print(f&quot;移位量：{shift}&quot;)    print(f&quot;密文：{ciphertext}&quot;)</code></pre><h5><span id="凯撒解密代码实现">凯撒解密代码实现</span></h5><pre><code class="lang-python">def caesar_decrypt(ciphertext, shift):    &quot;&quot;&quot;凯撒密码解密函数(独立实现)&quot;&quot;&quot;    plaintext = &quot;&quot;    for char in ciphertext:        # 处理小写字母        if char.islower():            char_num = ord(char) - ord(&#39;a&#39;)  # 密文字母转数字(a→0)            decrypted_num = (char_num - shift) % 26  # 解密核心：减移位量            decrypted_char = chr(decrypted_num + ord(&#39;a&#39;))            plaintext += decrypted_char        # 处理大写字母        elif char.isupper():            char_num = ord(char) - ord(&#39;A&#39;)            decrypted_num = (char_num - shift) % 26            decrypted_char = chr(decrypted_num + ord(&#39;A&#39;))            plaintext += decrypted_char        # 非字母字符直接保留        else:            plaintext += char    return plaintext------------------- 测试 -------------------if __name__ == &quot;__main__&quot;:    ciphertext = input(&quot;请输入需要解密的密文：&quot;)    shift = int(input(&quot;请输入加密时的移位量(整数)：&quot;))    decrypted_text = caesar_decrypt(ciphertext, shift)    print(f&quot;解密后的明文：{decrypted_text}&quot;)</code></pre><h4><span id="simple-substitution-cipher-简单替换密码">Simple Substitution Cipher 简单替换密码</span></h4><p>对于26个字母进行一一替换，一般情况下可以用字频攻击破解大部分，后续人工微调</p><h5><span id="字频攻击代码">字频攻击代码</span></h5><pre><code class="lang-python">import numpy as npimport matplotlib.pyplot as plt #定义字母表和密文alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;cipher_text = &quot;wb wi kjb mk rmit bmiq bj rashmwk rmvp yjeryrkb mkd wbi iwokwxwvmkvrmkd&quot; #统计密文中每个字母的频率count = np.zeros(len(alphabet))for char in cipher_text:    if char in alphabet:        index = alphabet.index(char)        count[index] += 1 #计算频率并排序total = sum(count)frequency = count / totalsorted_indices = np.argsort(-frequency)sorted_alphabet = &#39;&#39;.join([alphabet[i] for i in sorted_indices]) #英文字母标准频率(从高到低)english_frequency_order = &#39;etaoinshrdlcumwfgypbvkjxqz&#39; #初步替换密文字符translation_table = str.maketrans(sorted_alphabet, english_frequency_order)decoded_text = cipher_text.translate(translation_table)print(&quot;初步解密结果：&quot;, decoded_text)</code></pre><h4><span id="atbash-cipher-埃特巴什码">Atbash Cipher 埃特巴什码</span></h4><p>加密方式是将字母表前后倒转进行替换，可以一般难以判别，使用字频攻击破解</p><h4><span id="morse-cipher-摩斯密码">Morse Cipher 摩斯密码</span></h4><p>主要由点(.)，横杠(-)，字符间停顿(一般用空格space)，单词间停顿(一般用/)构成</p><h4><span id="affine-cipher-仿射密码">Affine Cipher 仿射密码</span></h4><p>对于26个字母进行数字映射(a—&gt;0)，然后经过一个单射函数处理，再转回字母加密<br>加密函数：<br>$E(x) ≡ (ax + b) \ mod \ 26$<br>解密函数：<br>$D(x) ≡ a^{-1} (x - b) \ mod \ 26$</p><h3><span id="多表替换密码">多表替换密码</span></h3><h4><span id="维吉尼亚密码">维吉尼亚密码</span></h4><p>首先拿到明文长度，然后将密钥长度扩展到明文长度，然后转化为数字映射，进行一一对应相加得到密文<br>解密时首先要得到key的长度，然后尝试得到key的具体内容才可以解密</p><h5><span id="维吉尼亚解密代码实现不一定准确只可以大致参考">维吉尼亚解密代码实现(不一定准确只可以大致参考)</span></h5><pre><code class="lang-python">&#39;&#39;&#39;维吉尼亚破解&#39;&#39;&#39;import numpy as npimport wordninjadef alpha(cipher): #预处理,去掉空格以及回车    c = &#39;&#39;    for i in range(len(cipher)):        if(cipher[i].isalpha()):            c += cipher[i]    return cdef count_IC(cipher): #给定字符串计算其重合指数    count = [0 for i in range(26)]    L = len(cipher)    IC = 0.0    for i in range(len(cipher)):        if(cipher[i].isupper()):            count[ord(cipher[i])-ord(&#39;A&#39;)] += 1        elif(cipher[i].islower()):            count[ord(cipher[i])-ord(&#39;a&#39;)] += 1    for i in range(26):        IC += (count[i]*(count[i]-1))/(L*(L-1))    return ICdef count_key_len(cipher,key_len): #对字符串按输入个数进行分组，计算每一组的IC值返回平均值    N = [&#39;&#39; for i in range(key_len)]    IC = [0 for i in range(key_len)]    for i in range(len(cipher)):        m = i % key_len        N[m] += cipher[i]    for i in range(key_len):        IC[i] = count_IC(N[i])    #print(IC)    print(&quot;长度为%d时,平均重合指数为%.5f&quot; % (key_len,np.mean(IC)))    return np.mean(IC)def length(cipher): #遍历确定最有可能的密钥长度返回密钥长度    key_len = 0    mins = 100    aver = 0.0    for i in range(1,21): #假设密钥长度在1-20之间        k = count_key_len(cipher,i)        if(abs(k-0.065)&lt; mins):            mins = abs(k-0.065)            key_len = i            aver = k    print(&quot;密钥长度为%d,此时重合指数每组的平均值为%.5f&quot; % (key_len,aver))    return key_lendef count_MIC(c1,c2,n): #n=k1-k2为偏移量,计算c1,c2互重合指数MIC    count_1 = [0 for i in range(26)]    count_2 = [0 for i in range(26)]    L_1 = len(c1)    L_2 = len(c2)    MIC = 0    for i in range(L_1):        if(c1[i].isupper()):            count_1[ord(c1[i])-ord(&#39;A&#39;)] += 1        elif(c1[i].islower()):            count_1[ord(c1[i])-ord(&#39;a&#39;)] += 1    for i in range(L_2):        if(c2[i].isupper()):            count_2[(ord(c2[i])-ord(&#39;A&#39;)+n+26)% 26] += 1        elif(c2[i].islower()):            count_2[(ord(c2[i])-ord(&#39;a&#39;)+n+26)% 26] += 1    for i in range(26):        MIC += count_1[i]*count_2[i]/(L_1*L_2)    return MICdef count_n(c1,c2): #确定两个子串最优的相对偏移量n=k1-k2    n = 0    mins = 100    k = [0.0 for i in range(26)]    for i in range(26):        k[i] = count_MIC(c1,c2,i)        #print(i,k[i])          if(abs(k[i]-0.065)&lt;mins):            mins = abs(k[i]-0.065)            n = i    return ndef  group_k(cipher,key_len):#完成分组操作并计算每一组与第一组的最优相对偏移量并返回    N = [&#39;&#39; for i in range(key_len)]    MIC = [0 for i in range(key_len)]    s = [0 for i in range(key_len)]    for i in range(len(cipher)): #对密文进行分组        m = i % key_len        N[m] += cipher[i]    for i in range(1,key_len):  #计算与第一组之间的相对偏移量        s[i] = count_n(N[0],N[i])  # s[i] = k1-k(i+1)        MIC[i] = count_MIC(N[0],N[i],s[i])  # MIC[i] = MIC(1,i+1)        print(&quot;第1组和第%d组之间偏移为%d时，互重合指数为%.5f&quot; % (i+1,s[i],MIC[i]))    return sdef miyao(key_len,s,k):  #k为第一个子串的移位，输出密钥并返回密钥所有字母的下标    mi = [&#39;&#39; for i in range(key_len)]    for i in range(key_len):        s[i] = -s[i]+k   #k2=k1-n        mi[i] = chr((s[i]+26) % 26 + ord(&#39;a&#39;))    print(&quot;第一个偏移量为%d,密钥为%s时&quot; % (k,mi))    return sdef the_end(cipher,key_len,s):#输入密文密钥返回明文结果    plain =&#39;&#39;    i = 0    while( i &lt; len(cipher)):        for j in range(key_len):            if(cipher[i].isupper()):                plain += chr((ord(cipher[i])-ord(&#39;A&#39;)-s[j]+26) % 26 + ord(&#39;A&#39;))            else:                plain += chr((ord(cipher[i])-ord(&#39;a&#39;)-s[j]+26) % 26 + ord(&#39;a&#39;))            i+=1            if(i == len(cipher)):                break    # print(plain)    return plainif __name__ == &quot;__main__&quot;:    fp = open(&quot;&quot;,&quot;r&quot;) #在这里填入密文文件路径    cipher = &#39;&#39;    for i in fp.readlines():        cipher = cipher + i    fp.close()    cipher = alpha(cipher)    key_len = length(cipher)    s = group_k(cipher,key_len)    m = s.copy()    for k in range(26):        s = m.copy()        s = miyao(key_len,s,k)        plain = the_end(cipher,key_len,s)        print(plain[0:20]) #输出部分明文确定偏移量k1    print(&quot;参考输出，请输入第一个子串的偏移量:&quot;,end=&#39;&#39;)    k = int(input())    m = miyao(key_len,m,k)    plain = the_end(cipher,key_len,m)    &#39;&#39;&#39;对英文文本进行分词&#39;&#39;&#39;    word = wordninja.split(plain)    plain = &#39;&#39;    for i in range(len(word)):        plain += word[i]        plain += &#39; &#39;    print(&quot;明文为\n&quot;+plain)</code></pre><h3><span id="其他类型密码">其他类型密码</span></h3><h4><span id="rail-fence-cipher-栅栏密码">Rail-Fence Cipher 栅栏密码</span></h4><p>将明文分n栏(分为n组)，然后明文按顺序依次进入各栏，形成类W的形状，最后进行各栏的拼接得到密文。<br>解密直接进行爆破即可</p><h4><span id="baconian-cipher-培根密码">Baconian Cipher 培根密码</span></h4><p>一种替换密码，每个明文字母由五个字符序列替换，一般使用AB，也可用其他</p><h5><span id="培根密码表">培根密码表</span></h5><p>A aaaaa B aaaab<br>C aaaba D aaabb<br>E aabaa F aabab<br>G aabba H aabbb<br>I abaaa J abaab<br>K ababa L ababb<br>M abbaa N abbab<br>O abbba P abbbb<br>Q baaaa R baaab<br>S baaba T baabb<br>U babaa V babab<br>W babba X babbb<br>Y bbaaa Z bbaab</p><h5><span id="栅栏加密代码实现">栅栏加密代码实现</span></h5><pre><code class="lang-python">def fence_password_encode():    # 获取用户输入(添加输入合法性校验)    while True:        plaintext = input(&#39;请输入需要加密的明文：&#39;).strip()        if not plaintext:            print(&quot;错误：明文不能为空，请重新输入！&quot;)            continue        break    while True:        try:            fence_count = int(input(&#39;请输入栅栏数(密钥)：&#39;).strip())            if fence_count &lt;= 0:                print(&quot;错误：栅栏数必须是正整数，请重新输入！&quot;)                continue            break        except ValueError:            print(&quot;错误：请输入有效的整数作为栅栏数！&quot;)    ciphertext = &quot;&quot;    plaintext_len = len(plaintext)  # 提前计算长度，避免重复调用    # 遍历每个栅栏(按栏索引循环)    for fence_idx in range(fence_count):        # 遍历当前栅栏的每个位置(步长为栅栏数)        for char_idx in range(fence_idx, plaintext_len, fence_count):            ciphertext += plaintext[char_idx]    print(f&quot;\n加密完成！密文为：{ciphertext}&quot;)    return ciphertextif __name__ == &#39;__main__&#39;:    fence_password_encode()</code></pre><h5><span id="栅栏解密代码实现">栅栏解密代码实现</span></h5><pre><code class="lang-python">import sysdef fence_password_brute_force():    # 校验命令行参数    if len(sys.argv) &lt; 2:        print(&quot;-----------------------------------------------&quot;)        print(&quot; &quot;)        print(f&quot;Usage: python {sys.argv[0]} &lt;fence_encrypted_string&gt;&quot;)        print(&quot;Example: python fence_Passwd_burst.py &#39;hloolelwrd&#39;&quot;)        print(&quot; &quot;)        print(&quot;说明：自动爆破2到密文长度-1之间的所有可能栅栏数&quot;)        print(&quot;-----------------------------------------------&quot;)        return    # 获取密文并处理    ciphertext = sys.argv[1].strip()    ciphertext_len = len(ciphertext)    # 校验密文有效性    if ciphertext_len &lt; 2:        print(&quot;错误：密文长度不能小于2，请输入有效的密文！&quot;)        return    # 生成所有可能的栅栏数(原逻辑：仅保留能整除密文长度的；补充：增加非整除情况，更全面)    # 原逻辑保留：step 能整除密文长度(避免部分情况漏解)    possible_steps = [        step for step in range(2, ciphertext_len)        if ciphertext_len % step == 0    ]    # 补充：添加不能整除的常见栅栏数(部分场景下栅栏数无需整除长度，原代码逻辑较局限)    # 避免因密文长度非栅栏数倍数导致漏解，保留前N个常见值(平衡效率与全面性)    additional_steps = [        step for step in range(2, ciphertext_len)        if ciphertext_len % step != 0    ][:5]  # 最多补充5个，避免输出过多冗余    possible_steps += additional_steps    possible_steps = list(sorted(set(possible_steps)))  # 去重并排序    # 无可能栅栏数的异常处理    if not possible_steps:        print(&quot;未找到可能的栅栏数，无法爆破！&quot;)        return    # 遍历所有可能的栅栏数进行解密    print(f&quot;\n开始爆破(共{len(possible_steps)}种可能栅栏数)：&quot;)    print(&quot;-&quot; * 50)    for step in possible_steps:        plaintext = &quot;&quot;        # 按栅栏数拆分并重组(核心解密逻辑)        for i in range(step):            # 从索引i开始，步长为step，提取当前栅栏的所有字符            plaintext += ciphertext[i::step]        print(f&quot;栅栏数 {step:2d} | 解密结果：{plaintext}&quot;)    print(&quot;-&quot; * 50)    print(&quot;爆破完成！请根据语义判断正确结果～&quot;)if __name__ == &#39;__main__&#39;:    fence_password_brute_force()</code></pre><h2><span id="现代密码">现代密码</span></h2><h3><span id="不同分类">不同分类</span></h3><h4><span id="按照密钥的特性进行分类">按照密钥的特性进行分类</span></h4><p>对称密码(AES，RC4)         速度快，密钥分发难<br>非对称密码(RSA，ECC)       密钥分发易，速度慢<br>混合密码(HTTPS)            结合两者优势，主流</p><h4><span id="按照功能分类">按照功能分类</span></h4><p>数据加密(AES，RSA)         保机密性<br>数字签名(ECDSA，EdDSA)     保完整+认证+不可否认<br>密钥交换(ECDH，TLS，ECDHE) 安全协商对称密钥<br>消息认证(HMAC，CMAC)       保完整+认证(无不可否认)</p><h4><span id="按照抗量子能力">按照抗量子能力</span></h4><p>传统密码(RSA，ECC)         抗经典，不抗量子<br>后量子密码(Kyber，Di)      抗量子，未来核心</p><h3><span id="对称密码">对称密码</span></h3><p>对称密码可以分为两大类：序列密码(流密码)和分组密码(块密码)<br>序列密码：生成与明文长度相同的密钥流(由密钥生成器产生)，逐位(或逐字节)加密，将明文与密钥流逐位异或<br>分组密码：将明文分成固定长度的组，每组独立加密，用同一密钥对每组明文加密，密钥长度固定</p><p>现代密码学设计密码算法一般遵循两个原则：<br>混淆：模糊明文和密文的关系，尝试用替换的方式实现<br>扩散：将明文中一位的影响扩散到多个密文，尝试用置换的方式实现<br>现代密码学中通常使用多轮运算，每一轮中会有若干层混淆变换和扩散变换</p><h4><span id="序列密码-rc4rivest-cipher-4-李维斯特密码4">序列密码-RC4(Rivest Cipher 4 李维斯特密码4)</span></h4><p>RC4 的核心分为两大阶段：S 盒初始化(KSA)和伪随机流生成(PRGA)</p><h5><span id="s盒初始化ksa">S盒初始化(KSA)</span></h5><p>首先S盒填充为0到255的连续字节<br>S[i] = i<br>同时维护一个辅助数组k，将密钥key循环填充到k中<br>K[i] = Key[i mod len(Key)]</p><pre><code class="lang-python">j = 0for i in range(256):    j = (j + S[i] + K[i]) % 256    # 计算交换索引j    swap(S[i], S[j])    # 交换S[i]和S[j]</code></pre><h5><span id="伪随机流生成prga">伪随机流生成(PRGA)</span></h5><p>初始化索引：设两个初始索引i = 0，j = 0<br>逐字节生成密钥流：对每一个明文字节，执行：<br>i = (i + 1) mod 256</p><h1><span id="i递增1并取模256">i递增1并取模256</span></h1><p>j = (j + S[i]) mod 256</p><h1><span id="用si更新j">用S[i]更新j</span></h1><p>swap(S[i], S[j])</p><h1><span id="再次交换s盒元素保证随机性">再次交换S盒元素，保证随机性</span></h1><p>t = (S[i] + S[j]) mod 256</p><h1><span id="计算中间值t">计算中间值t</span></h1><p>Keystream_byte = S[t]</p><h1><span id="从s盒中取一个字节作为密钥流字节">从S盒中取一个字节作为密钥流字节</span></h1><p>将生成的Keystream_byte与明文（或密文）字节异或，得到密文（或明文）</p><h5><span id="序列密码-rc4加解密代码实现">序列密码-RC4加解密代码实现</span></h5><pre><code class="lang-python">def rc4(key: bytes, data: bytes) -&gt; bytes:    # 1. KSA：初始化S盒    S = list(range(256))    j = 0    key_len = len(key)    # 填充K数组并打乱S盒    for i in range(256):        j = (j + S[i] + key[i % key_len]) % 256        S[i], S[j] = S[j], S[i]    # 2. PRGA：生成密钥流并异或    i = j = 0    result = []    for byte in data:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        t = (S[i] + S[j]) % 256        keystream_byte = S[t]        # 异或得到结果        result.append(byte ^ keystream_byte)    return bytes(result) #测试：加密和解密key = b&quot;secret_key_123&quot;  # 密钥（ bytes类型）plaintext = b&quot;Hello, RC4!&quot;  # 明文ciphertext = rc4(key, plaintext)decrypted_text = rc4(key, ciphertext)print(&quot;密文（十六进制）:&quot;, ciphertext.hex())  # 输出密文（十六进制格式）print(&quot;解密后明文:&quot;, decrypted_text.decode(&quot;utf-8&quot;))  # 输出：Hello, RC4!</code></pre><h4><span id="序列密码-otpone-time-pad-一次一密">序列密码-OTP(One Time Pad 一次一密)</span></h4><p>将明文所有字符转化为八位二进制，然后随机生成和密文等长的密钥流，将明文和密钥流进行异或得到密文</p><h5><span id="otp加密代码实现">OTP加密代码实现</span></h5><pre><code class="lang-python">import osdef otp_encrypt(plaintext: bytes, key: bytes) -&gt; bytes:    &quot;&quot;&quot;    使用一次一密(OTP)加密明文。    :param plaintext: 明文数据(字节序列)    :param key: 密钥(字节序列)    :return: 密文(字节序列)    &quot;&quot;&quot;    if len(plaintext) != len(key):        raise ValueError(&quot;密钥长度必须与明文长度相同&quot;)    return bytes([p ^ k for p, k in zip(plaintext, key)])def otp_decrypt(ciphertext: bytes, key: bytes) -&gt; bytes:    &quot;&quot;&quot;    使用一次一密(OTP)解密密文。    :param ciphertext: 密文数据(字节序列)    :param key: 密钥(字节序列)    :return: 解密后的明文(字节序列)    &quot;&quot;&quot;    if len(ciphertext) != len(key):        raise ValueError(&quot;密钥长度必须与密文长度相同&quot;)    return bytes([c ^ k for c, k in zip(ciphertext, key)]) #示例使用plaintext = b&quot;Hello, OTP!&quot;key = os.urandom(len(plaintext))  # 生成与明文等长的随机密钥 #加密ciphertext = otp_encrypt(plaintext, key)print(&quot;密文:&quot;, ciphertext) #解密decrypted_text = otp_decrypt(ciphertext, key)print(&quot;解密后的明文:&quot;, decrypted_text)</code></pre><h5><span id="otp解密方式一">OTP解密方式一</span></h5><p>得到完整的密钥流，不完整也无法进行解密</p><h5><span id="otp解密方式二可实现率极低">OTP解密方式二(可实现率极低)</span></h5><p>有多个加密后的密文(即同一个密钥流不断加密得到各阶段的密文)</p><h6><span id="解密原理一">解密原理一</span></h6><p>$c1 ⊕ c2 = ( p1 ⊕ k) ⊕ ( p2 ⊕ k ) = p1 ⊕ p2 ⊕ k ⊕ k = p1 ⊕ p2$  (k的加密效果抵消)</p><h6><span id="解密原理二">解密原理二</span></h6><p>对于一个小写字母与space异或结果为大写字母，反之亦然</p><h6><span id="例题">例题</span></h6><pre><code class="lang-python">c0=&quot;315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0&quot; c1=&quot;234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d&quot; c2=&quot;32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b&quot;c3=&quot;32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197&quot; c4=&quot;3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade&quot; c5=&quot;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee71497&quot; c6=&quot;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148d&quot; c7=&quot;315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40ce0fff9e00fa1439f&quot; c8=&quot;271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a&quot; c9=&quot;466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138&quot;#for each ciphertextfor current_index,ciphertext in enumerate (ciphers):    counter = collections.Counter()    # for each other ciphertext     for index,ciphertext2 in enumerate (ciphers):        if current_index != index: # don&#39;t xor a ciphertext with itself            for indexOfChar,char in enumerate(strxor(ciphertext.decode(&#39;hex&#39;),ciphertext2.decode(&#39;hex&#39;))): # XOR the two ciphertexts                # if a chracter in the xored result is a alphabetic character, it means was probably a space character in one of the two plaintexts(we don&#39;t know which one)                if char in string.printable and char.isalpha(): counter[indexOfChar] +=1    knownSpaceIndexes = ()     # loop through all positions where a space character was possible in the current_index ciphertext    for ind,val in counter.items():        # if a space character was found at least 7 times at this index out of the 9 possible XORS， then the space character was likely from the current_index ciphertext!        if val &gt;=7: knownSpaceIndexes.append(ind)        # print knownSpaceIndexes # Shows all the positions where we now know the key!        # now xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!        xor_with_spaces = strxor(ciphertext.decode(&#39;hex&#39;), &#39; &#39; * 150)        for index in knownSpaceIndexes:            # stoe the key&#39;s value at the correct position            final_key[index] = xor_with_spaces[index].encode(&#39;hex&#39;)            # record that we know the key at this position            know_key_positions.add(index)</code></pre><h4><span id="序列密码-lcglinear-congruential-generator-线性同余生成器">序列密码-LCG(Linear Congruential Generator 线性同余生成器)</span></h4><p>LCG生成伪随机数满足递推式： $X_{n+1} ≡ AX_n + B \ (mod \ M)$  其中A，B，M为常数且需要$X_0$作为种子<br>由此递推式生成伪随机数序列得到密钥流，再逐字节进行异或加密得到密文</p><h5><span id="解密前置知识">解密前置知识</span></h5><h6><span id="同余运算简单性质">同余运算简单性质</span></h6><p>$a \pm c ≡ b \pm c \ (mod \ m)$<br>$a \times c ≡ b \times c \ (mod \ m)$<br>$a ≡ b \ (mod \ m),b ≡ c \ (mod \ m) ➡ a ≡ c \ (mod \ m)$</p><h6><span id="逆相关运算">逆相关运算</span></h6><p>$a ÷ b ≡ c \ (mod \ m) ⬅➡ a \times b^{-1} ≡ c \ (mod \ m)$<br>$b \times b^{-1} ≡ 1 \ (mod \ m)$<br>注意：不是所有情况都存在逆，只有m与b互质是才存在逆</p><h5><span id="lcg解密方式一">LCG解密方式一</span></h5><p>在已知常数A，B，M的前提下，若能捕捉到LCG生成的一个输出，则可以恢复出状态，并通过递推式预测之后产生的所有随机数</p><p>$X<em>{n+1} ≡ A X_n + B \ (mod \ M)$ ➡ $X_n ≡ (X</em>{n+1} - B)A^{-1} \ (mod \ M)$</p><p>通过递推可以得到初始种子$X_0$以及后续所有组成密钥流</p><h5><span id="lcg解密方式二">LCG解密方式二</span></h5><p>在未知A，B，已知M的情况下，若能捕捉到LCG生成的连续两个输出，可以通过建立方程求解A，B得到递推公式</p><p>联立方程组：<br>$X<em>{n+1} ≡ A X_n + B \ (mod \ M)$<br>$X</em>{n+2} ≡ A X_{n+1} + B \ (mod \ M)$</p><p>解出A，B<br>$A ≡ ( X<em>{n+2} - X</em>{n+1} )( X<em>{n+1} - X_n )^{-1} \ (mod \ M)$<br>$B ≡ X</em>{n+1} - A X_n \ (mod \ M)$</p><p>后续递推密钥流即可</p><h5><span id="lcg例题">LCG例题</span></h5><h6><span id="lcg例题题目">LCG例题题目</span></h6><pre><code class="lang-python">from hashlib import sha256from Crypto.Util.number import *import randomfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padflag = b&#39;xxx&#39;def step(x,y,p):    return (5*y + 7)%p,(11*x + 13)%pp = getPrime(64)x,y = random.randint(0,p),random.randint(0,p)key = sha256(str(x).encode() + str(y).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_ECB)ct = cipher.encrypt(pad(flag,16))ots = [x**2*y**2%p]k = 10for i in range(k):    for j in range(10):        x,y = step(x,y,p)    ots.append(x**2*y**2%p)print(&quot;ct =&quot;,ct.hex())print(&quot;p =&quot;,p)print(&quot;ots =&quot;,ots)# ct = eedac212340c3113ebb6558e7af7dbfd19dff0c181739b530ca54e67fa043df95b5b75610684851ab1762d20b23e9144# p = 13228731723182634049# ots = [10200154875620369687, 2626668191649326298, 2105952975687620620, 8638496921433087800, 5115429832033867188, 9886601621590048254, 2775069525914511588, 9170921266976348023, 9949893827982171480, 7766938295111669653, 12353295988904502064]</code></pre><h6><span id="lcg例题解题代码">LCG例题解题代码</span></h6><pre><code class="lang-python">from hashlib import sha256from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom Crypto.Util.number import inverseimport sympy as spp = 13228731723182634049ots = [10200154875620369687, 2626668191649326298, 2105952975687620620,8638496921433087800, 5115429832033867188, 9886601621590048254,2775069525914511588, 9170921266976348023, 9949893827982171480,7766938295111669653, 12353295988904502064]ct = bytes.fromhex(&quot;eedac212340c3113ebb6558e7af7dbfd19dff0c181739b530ca54e67fa043df95b5b75610684851ab1762d20b23e9144&quot;)# 一步迭代的线性变换矩阵（含常数项）# [x&#39;]   [0  5  7] [x]# [y&#39;] = [11 0 13] [y]# [1 ]   [0  0  1] [1]M = [[0, 5, 7], [11, 0, 13], [0, 0, 1]]def mat_mul(A, B, mod):    return [[sum(A[i][k] * B[k][j] for k in range(3)) % mod for j in range(3)] for i in range(3)]def mat_pow(M, e, mod):    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]    B = [row[:] for row in M]    while e &gt; 0:        if e &amp; 1:            R = mat_mul(R, B, mod)        B = mat_mul(B, B, mod)        e //= 2    return R# 10 步合并成一次变换M10 = mat_pow(M, 10, p)(a1, b1, c1), (a2, b2, c2), _ = M10def tonelli(n, p):    if n == 0:        return 0    if pow(n, (p - 1) // 2, p) != 1:        print(&quot;No square root exists&quot;)        return None    if p % 4 == 3:        return pow(n, (p + 1) // 4, p)    q = p - 1    s = 0    while q % 2 == 0:        s += 1        q //= 2    z = 2    while pow(z, (p - 1) // 2, p) != p - 1:        z += 1    c = pow(z, q, p)    x = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    while t != 1:        i = 1        t2 = pow(t, 2, p)        while t2 != 1:            t2 = pow(t2, 2, p)            i += 1        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        x = (x * b) % p        t = (t * b * b) % p        c = (b * b) % p        m = i    return x# 计算 ots[0] 和 ots[1] 的平方根s0_root = tonelli(ots[0], p)s1_root = tonelli(ots[1], p)# 两个平方根分支s0_candidates = {s0_root, (-s0_root) % p}s1_candidates = {s1_root, (-s1_root) % p}x = sp.Symbol(&#39;x&#39;)solutions = []# 由 s0, s1 构造四次方程，解出 x0for s0 in s0_candidates:    for s1 in s1_candidates:        A1, B1, C1 = a1 % p, c1 % p, (b1 * s0) % p        A2, B2, C2 = a2 % p, c2 % p, (b2 * s0) % p        k4 = (A1 * A2) % p        k3 = (A1 * B2 + A2 * B1) % p        k2 = (A1 * C2 + A2 * C1 + B1 * B2 - s1) % p        k1 = (B1 * C2 + B2 * C1) % p        k0 = (C1 * C2) % p        poly = sp.Poly(k4 * x**4 + k3 * x**3 + k2 * x**2 + k1 * x + k0, x, modulus=p)        coeff, factors = sp.factor_list(poly, modulus=p)        for f, _ in factors:            if f.degree() == 1:                a, b = f.all_coeffs()                r = (-b * sp.invert(a, p)) % p                solutions.append((s0, s1, int(r)))            elif f.degree() == 2:                a, b, c = f.all_coeffs()                a, b, c = int(a), int(b), int(c)                d = (b * b - 4 * a * c) % p                r1 = tonelli(d, p)                if r1 is not None:                    inv2a = inverse(2 * a, p)                    r = ((-b + r1) * inv2a) % p                    solutions.append((s0, s1, int(r)))                    r = ((-b - r1) * inv2a) % p                    solutions.append((s0, s1, int(r)))def step10(x, y):    v = [x, y, 1]    v2 = [        (M10[i][0] * v[0] + M10[i][1] * v[1] + M10[i][2] * v[2]) % p        for i in range(3)    ]    return int(v2[0]), int(v2[1])# 验证所有候选并解密valid = []for s0, s1, x0 in solutions:    if x0 % p == 0:        continue    y0 = (s0 * inverse(x0, p)) % p    x, y = x0, y0    ok = True    if (x * x * y * y) % p != ots[0]:        ok = False    else:        for idx in range(1, len(ots)):            x, y = step10(x, y)            if (x * x * y * y) % p != ots[idx]:                ok = False                break    if ok:        valid.append((x0, y0))for x0, y0 in valid:    key = sha256(str(x0).encode() + str(y0).encode()).digest()[:16]    flag = AES.new(key, AES.MODE_ECB).decrypt(ct)    try:        print(unpad(flag, 16))    except Exception:        pass</code></pre><h4><span id="序列密码-lfsrlinear-feedback-shift-register-线性反馈移位寄存器">序列密码-LFSR(Linear Feedback Shift Register 线性反馈移位寄存器)</span></h4><p>我们将LFSR中的寄存器个数称为LFSR的级数，一个n级的LFSR最多可存储 $2^n$ - 1 种状态<br>在n个寄存器中，依次有状态$S_1$，$S_2$,···，$S_n$，向右移位则$S_n$输出为密钥流的第一项<br>$S_1$空缺由线性反馈函数 $f(S_1, S_2, S_3, S_4)$ 的处理结果补上<br>以此类推不断进行得到密钥流 (一般情况下会有循环周期效果，周期数 k ≤ $2^n$ - 1)<br>由反馈函数决定循环周期</p><h5><span id="lfsr线性反馈函数">LFSR线性反馈函数</span></h5><p>函数由状态$s$以及推头$m$组成，构成函数<br>$f(s_{n+1}) = (s_1 \times m_1)⊕(s_2 \times m_2)⊕···⊕(s_n \times m_n)$<br>推头可以简单理解为0和1组成，决定该位置状态是否参与函数的运算</p><h5><span id="lfsr解密方式一">LFSR解密方式一</span></h5><p>在已知 LFSR 反馈函数的前提下，如果已知连续 n 位明文和 n 位密文，则可以计算得出 n 位密钥，即为 LFSR 的一个状态<br>此时根据反馈函数，即可计算出 LFSR 的全部输出，即全部密钥密钥流，从而破解 LFSR</p><h5><span id="lfsr解密方式二">LFSR解密方式二</span></h5><p>在未知 LFSR 反馈函数前提下，若获取2n位的明文和密文，计算得出2n位的密钥$[k<em>1,k_2,···,k</em>{2n}]$<br>这2n位密钥中有LFSR的n+1种状态，分别为$[k<em>1,k_2,···,k</em>{n}]$，$[k<em>2,k_2,···,k</em>{n+1}]$，··· $[k<em>{n+1},k</em>{n+2},···,k<em>{2n}]$<br>这些状态之间存在着互相递推关系，例如$k</em>{n+1}$就是由$[k<em>1,k_2,···,k</em>{n}]$计算出来的<br>以此类推，$k<em>{n+i}$ 就是由 $[k_i,k</em>{i+1},···,k_{i+n-1}]$ 计算得出，从而得到n个线性方程，进行矩阵运算接口解出反馈函数</p><h4><span id="分组密码-desdata-encryption-standard-数据加密标准">分组密码-DES(Data Encryption Standard 数据加密标准)</span></h4><p>DES块长度为64位，密钥长度为64位(其中8位为校验位，实际有效56位)，明文64位分组加密得到64位密文<br>DES对明文进行16轮加密运算，每一轮都有一个相应的子密钥参与(子密钥由密钥扩展算法计算得出)<br>此外，开头和结尾分别有初始置换和最终置换的操作</p><h5><span id="des加密初始置换和最终置换">DES加密初始置换和最终置换</span></h5><p>就是简单根据置换表，把长度为64比特的block每一个位置进行变换</p><h6><span id="初始置换initial-permutation代码实现">初始置换(Initial Permutation)代码实现</span></h6><pre><code class="lang-python">IP_table=[    58,50,42,34,26,18,10,2,    60,52,44,36,28,20,12,4,    62,54,46,38,30,22,14,6,    64,56,48,40,32,24,16,8,    57,49,41,33,25,17,9,1,    59,51,43,35,27,19,11,3,    61,53,45,37,29,21,13,5,    63,55,47,39,31,23,15,7,]def IP(block):    result=[]    for i in range(len(IP_table)):        result.append(block[IP_table[i]-1])    return result###### 最终置换(Final Permutation)代码实现FP_table=[    40,8,48,16,56,24,64,32,    39,7,47,15,55,23,63,31,    38,6,46,14,54,22,62,30,    37,5,45,13,53,21,61,29,    36,4,44,12,52,20,60,28,    35,3,43,11,51,19,59,27,    34,2,42,10,50,18,58,26,    33,1,41,9,49,17,57,25,]def FP(block):    result = []    for i in range(len(FP_table)):        result.append(block[FP_table[i]-1])    return result</code></pre><h5><span id="des密钥扩展算法">DES密钥扩展算法</span></h5><p>通过PC-1置换去除64比特密钥中的校验位<br>将56比特的密钥分成28比特<br>连续16轮运算，每一轮分别先对左右两半循环移位，再经过PC-2置换生成一个48比特的子密钥<br>最终得到16组48比特的子密钥</p><h6><span id="des密钥扩展算法代码实现">DES密钥扩展算法代码实现</span></h6><pre><code class="lang-python">subkey=[]if len(bkey)== 64:    #PC-1    bkey = PC_1(bkey)eliflen(bkey) = 56:    raise ValueError(&quot;key must be 56-bit or 64-bit in length&quot;) #divide the block into two halvesCi, Di = bkey[:28], bkey[28:]for i in range(16):    #Left Rotation    Ci, Di = LR(Ci, Di, i)    #PC-2    subkey.append(PC_2(Ci + Di))return subkey</code></pre><h5><span id="des加密轮函数feistel-function-费斯妥函数">DES加密轮函数(Feistel Function 费斯妥函数)</span></h5><p>先通过Expansion将32比特输入扩展成48比特<br>再与48比特的子密钥混合作异或运算<br>然后48比特分别分为8组，每组6比特，经过S盒替换，输出8组4比特，即32比特<br>最后对这32比特依据一张固定的置换表进行移位置换P</p><h6><span id="des加密轮函数代码实现">DES加密轮函数代码实现</span></h6><pre><code class="lang-python">def Feistel(HalfBlock, subkey):    eHalfBlock = Expansion(HalfBlock)    xHalfBlock = BlockXor(eHalfBlock, subkey)    sHalfBlock = Substitution(xHalfBlock)    return Permutation(sHalfBlock)</code></pre><h5><span id="des加密过程">DES加密过程</span></h5><p>将分块后的明文(64位)先进行初始置换，再分为左右两块$L<em>0,R_0$(32位)<br>在每一轮中进行下列运算(总共进行16轮)：<br>$L</em>{i+1} = R<em>i$<br>$R</em>{i+1} = L<em>i ⊕ F(R_i,K_i)$ (F为轮函数)<br>将$R</em>{16},L_{16}$进行交换拼接，进行最后置换得到64位密文</p><h6><span id="des加密代码实现">DES加密代码实现</span></h6><pre><code class="lang-python"> #Initial permutationm = IP(m) #divide the block into two 32-bit halvesLi, Ri = m[:32], m[32:] #16 roundsfor i in range(16):    Li, Ri = Ri, BlockXor(Li, Feistel(Ri, subkey[i])) #merge the two divided half block which is 32-bit into one 64-bit blockm = Ri + Li # There is a need to change order of the final two halves #Final permutationm = FP(m)</code></pre><h5><span id="des加解密代码实现">DES加解密代码实现</span></h5><pre><code class="lang-python">from Crypto.Cipher import DESkey = &#39;&#39;des = DES.new(key,DES.MODE_ECB)plaintext = b&#39;&#39;cipher = des.encrypt(plaintext)des.decrypt(cipher)</code></pre><h6><span id="des解密方式一">DES解密方式一</span></h6><p>在已知密文和16个子密钥的情况下，由于轮函数以及置换的可逆性，仅需要在轮函数作用时使用逆序的子密钥即可</p><h4><span id="分组密码-aesadvanced-encryption-standard-高级加密标准">分组密码-AES(Advanced Encryption Standard 高级加密标准)</span></h4><p>AES算法的块长度为128位，不同密钥长度分别有不同加密轮数<br>128位密钥对应10轮，192位密钥对应12轮，256位密钥对应14轮<br>AES每一轮直接对整个128位进行加密，使用算法层进行加密</p><h5><span id="aes算法层加密">AES算法层加密</span></h5><p>AES128位(16字节)首先按照从左向右，从上到下排成一个4\times4的矩阵<br>先对密钥k进行扩展得到子密钥用于密钥加法层处理，其中$k_0$先对明文进行密钥加法层处理，后续$k_n$进行第n轮密钥加法层处理<br>随后直到n-1轮都进行字节代换层➡扩散层(由Shift Rows层和Mix Column层构成)➡密钥加法层<br>最后一轮删去Mix Column层处理，其余不变，得到最后密文</p><h6><span id="aes加密算法框架代码实现">AES加密算法框架代码实现</span></h6><pre><code class="lang-python">#startr=0k_sch=self.subkeys[0] + self.subkeys[1] + self.subkeys[2] + self.subkeys[3]state = list(msg)AES.add_round_key(state,k_sch) #round 1~rounds&#39;-1for r in range(1,self.rounds):    AES.sub_bytes(state)    AES.shift_rows(state)    AES.mix_columns(state)    k_sch=self.subkeys[4*r] + self.subkeys[4*r+1] + self.subkeys[4*r+2] + self.subkeys[4*r+3]    AES.add_round_key(state,k_sch) #the last roundr = self.roundsAES.sub_bytes(state)AES.shift_rows(state)k_sch=self.subkeys[-4] + self.subkeys[-3] +self.siubkeys[-2] + self.subkeys[-1]AES.add_round_key(state,k_sch) #convert &#39;list&#39;stateto&#39;bytes&#39;outputoutput=bytes(state)return output###### AES算法层-字节代换层让输入的每一个字节，通过S盒代换(映射)到另外一个字节此处的S盒是可以经过每种方式计算出来的，也可以直接使用计算好的进行代换@staticmethoddef sub_bytes(s):    for i in range(16):        s[i] = AES.Sbox[s[i]]</code></pre><h6><span id="aes算法层-扩散层">AES算法层-扩散层</span></h6><p>行移位层(Shift Rows层)<br>对于4\times4的矩阵，在做行移位时，第一行保持不变，第二行往左移动一格，第三行左移两格，第四行左移三格</p><p>行混淆层(Mix Column层)<br>将整个字节矩阵乘上一个列混淆矩阵(有限域上的矩阵运算)<br>相当于正常矩阵运算结果取模</p><pre><code class="lang-python">@staticmethoddef shift_rows(s):    s[i] = list(s[0::5] + s[4::5] + s[3:4:5] + s[8::5] + s[2:8:5] +s[12::5] + s[1:12:5])@staticmethoddef mix_columns(s):    def xtime(a):        return((((a &lt;&lt; 1) ^ 0x1B) &amp; 0XFF) if (a &amp; 0x80) else (a &lt;&lt;1))    for i in range(4):        t=s[4*i] s[4*i+1] ^s[4*i+2]^s[4*i+3]        u=s[4*i]        s[4*i] ^=t xtime(s[4*i] ^ s[4*i+1])        s[4*i+1] ^= t xtime(s[4*i+1] ^ s[4*i+2])        s[4*i+2] ^= t xtime(s[4*i+2] ^ s[4*i+3])        s[4*i+3] ~ t xtime(s[4*i+3] ^ u)</code></pre><h6><span id="aes算法层-密钥加法层">AES算法层-密钥加法层</span></h6><p>输入16字节的明文和子密钥，对这两个输入逐字节异或，并将异或结果输出</p><pre><code class="lang-python">@staticmethoddef add_round_key(s, k):    for i in range(16):        s[i] ^= k[i]</code></pre><h6><span id="aes密钥扩展算法">AES密钥扩展算法</span></h6><p>以标准128位密钥，对应共有11组子密钥，反别在一开始盒每一轮(共十轮)中参与轮密钥加法层运算<br>子密钥的生成是以列为单位，一列4字节32比特构成一个字(word)，四个字拼接成一个子密钥</p><p>$k[0]$的生成<br>将密钥同样从左到右，从上到下排列为一个矩阵，第一列$k_1,k_2,k_3,k_4$为$w_0$<br>$w_0,w_1,w_2,w_3$拼接构成$k[0]$</p><p>$k[1],k[2]···k[n]$的生成<br>首先存在G函数接收$w_3$的结果，其输出与$w_0$进行异或得到$w_4$，然后$w_1$与$w_4$异或得到$w_5$<br>以此类推得到$w_4,w_5,w_6,w_7$拼接得到$k[1]$<br>$w_4,w_5,w_6,w_7$重复上述过程即可，以此类推拿到所有子密钥</p><p>G函数<br>将输入的w分成四块(每块1字节)$B_1,B_2,B_3,B_4$<br>将每个字节进行向循环左移一位<br>逐字节经过S盒进行代换<br>用第一个字节盒轮系数进行异或运算(实际上是四个字节整体与轮常量异或，但是常量后续三个字节都是0)</p><pre><code class="lang-python">@staticmethoddefkey_expansion(k,r): #fips-197 Figure 11    k = list(k) # in case k is bytes    Nk = len(k) // 4    subkeys=[k[i:i+4]foriinrange(0,4*Nk,4*Nk,4)]    i = Nk    while i &lt; 4*(r+1):        t=subkeys[i-1]    if i % Nk == 0:        tt=AES.sub_word(AES.rot_word(t))        t=[tt[0] ^AES.Rcon[i // Nk]] + tt[1:]    elif Nk &gt; 6 and i % Nk == 4:        t = AES.sub_word(t)    subkeys.append(AES.word_xor(subkeys[i - Nk], t))    i += 1return subkeys</code></pre><h5><span id="aes加解密代码实现">AES加解密代码实现</span></h5><pre><code class="lang-python">from Crypto.Cipher import AESkey = b&quot;&quot;aes = AES.new(key,mode=AES.MODE_ECB)plaintext = b&quot;&quot;ciphertext = aes.encrypt(plaintext)aes.decrypt(ciphertext)##### AES例题一import timeimport randomfrom Crypto.Cipher import AESfrom Crypto.Util.number import *random.seed(int(time.time())) #抽取当前时间的时间戳转化成int类型作为随机数生成的种子seedkey = long_to_bytes(random.getrandbits(128)) #用函数生成一个128位的整数并转化为字节形式得到一个16字节aes=AES.new(key, mode=AES.MODE_ECB)cipher= aes.encrypt(flag)with open(&quot;cipher&quot;, &quot;wb&quot;) as f:    f.write(cipher) #AES加密是难以爆破的，我们一般只可以取找key #由于random算法的固定，所以直接找到时间戳就可以拿到key</code></pre><h4><span id="分组密码-分组模式">分组密码-分组模式</span></h4><p>分组密码算法只能加密固定长度的分组，当我们加密的明文长度超过块长度时，需要分组密码算法迭代以全部加密<br>而不同的分组密码算法分组就是分组密码的模式(mode)</p><p>常见的分组模式有如下几种:<br>ECB模式:Electronic Code Book mode(电子密码本模式)<br>CBC模式:Cipher Block Chaining mode(密码分组链接模式)<br>CFB模式:Cipher FeedBack mode(密文反馈模式)<br>OFB模式:Output FeedBack mode (输出反馈模式)<br>CTR模式:CounTeR mode (计数器模式)<br>GCM模式:Galois/Counter Mode(伽罗瓦/计数器模式)</p><p>分组密码迭代加密要求每一个明文分组都是块长度(8或16字节)<br>当分组到最后一组时，其长度不足块长度，就需要对其进行填充，将长度扩展为块长度</p><p>常见的填充方式有如下几种:<br>补零:在末尾补上0x00字节<br>… | DD DD DD DD DD DD DD DD DD DD DD DD 00 00 00 00 00 |<br>字节填充:先填充0x00字节,直至最后一字节填充值为填充长度<br>… | DD DD DD DD DD DD DD DD DD DD DD DD 00 00 00 00 04 |<br>PKCS7填充:若需填充N个字节,则每个填充字节值都是N<br>… | DD DD DD DD DD DD DD DD | DD DD DD 04 04 04 04 04 |</p><h5><span id="分组模式-ecbelectronic-code-book-mode-电子密码本模式">分组模式-ECB(Electronic Code Book mode 电子密码本模式)</span></h5><p>最简单的分组方式，直接将明文分成固定的块大小，每个块进行独立且相同的加密，明文和密文一一对应</p><h6><span id="分组模式-ecb加解密代码实现">分组模式-ECB加解密代码实现</span></h6><pre><code class="lang-python">from Crypto.Cipher import AESdef aes_ecb_encrypt(pt, key):    aes=AES.new(key, AES.MODE_ECB)    ct = aes.encrypt(pt)    return ctdef aes_ecb_decrypt(ct, key):    aes=AES.new(key,AES.MODE_ECB)    pt=aes.decrypt(ct)    return pt</code></pre><h5><span id="分组模式-cbccipher-block-chaining-mode-密码分组链接模式">分组模式-CBC(Cipher Block Chaining mode 密码分组链接模式)</span></h5><p>首先一样先对明文进行分块填充，然后使用初始化向量IV对第一个明文块进行异或操作，然后进行加密<br>第一个加密得到密文在与第二块明文进行异或，随后第二块去加密，以此类推</p><h6><span id="分组模式-cbc加解密代码实现">分组模式-CBC加解密代码实现</span></h6><pre><code class="lang-python">def aes_cbc_encrypt(pt, key,iv):    aes=AES.new(key,AES.MODE_CBC, iv=iv=iv=iv)    ct = aes.encrypt(pt)    return ctdef aes_cbc_decrypt(ct, key,iv):    aes=AES.new(key,AES.MODE_CBC, iv=iv=iv=iv)    pt = aes.decrypt(ct)    return pt</code></pre><h5><span id="分组模式-cfbcipher-feedback-mode-密文反馈模式">分组模式-CFB(Cipher FeedBack mode 密文反馈模式)</span></h5><p>首先一样先对明文进行分块填充，然后对IV进行加密得到中间结果，将这个结果与第一块明文进行异或得到第一块密文<br>第一块密文进行加密得到中间结果，中间结果再与第二块明文异或，得到第二块密文，以此类推</p><h6><span id="分组模式-cfb加解密代码实现">分组模式-CFB加解密代码实现</span></h6><pre><code class="lang-python">def aes_cfb_encrypt(pt, key,iv):    aes=AES.new(key,AES.MODE_CFB, iv=iv=iv=iv)    ct = aes.encrypt(pt)    return ctdef aes_cfb_decrypt(ct, key,iv):    aes=AES.new(key,AES.MODE_CFB, iv=iv=iv=iv)    pt = aes.decrypt(ct)    return pt</code></pre><h5><span id="分组模式-ctrcounter-mode-计数器模式">分组模式-CTR(CounTeR mode 计数器模式)</span></h5><p>首先一样先对明文进行分块填充，然后对一个逐次累加的计数器进行加密得到中间结果(密钥流的流密码)<br>将这个结果与块明文进行异或得到块密文</p><h6><span id="分组模式-ctr计数器构造">分组模式-CTR计数器构造</span></h6><p>CTR每一次解密时，都会生成一个nonce(仅用一次的数)来作为计数器的初始值<br>计数器格式：前面字节为固定的nonce，后面字节为分组序号，会逐次累加</p><h6><span id="分组模式-ctr加解密代码实现">分组模式-CTR加解密代码实现</span></h6><pre><code class="lang-python">def aes_ctr_encrypt(pt,key, nonce):    aes = AES.new(key, AES.MODE_CTR, nonce=nonce)    ct = aes.encrypt(pt)    return ctdef aes_ctr_decrypt(ct, key, nonce):    aes = AES.new(key, AES.MODE_CTR, nonce=nonce)    pt = aes.decrypt(ct)    return pt</code></pre><h5><span id="分组模式相关利用手法a">分组模式相关利用手法A</span></h5><p>初始化向量IV(initialization vector)是一个固定长度的输入值，一般会要求它是随机数或者拟随机数<br>ECB模式中，由于没有IV，导致密钥不变的情况下，相同的明文必然会加密生成相同的密文，会泄露明文部分信息</p><h6><span id="初始化向量iv代码生成">初始化向量IV代码生成</span></h6><pre><code class="lang-python">#系统内置的密码学安全生成器import osiv = os.urandom(16)</code></pre><h6><span id="iv复用">IV复用</span></h6><p>CTR模式中，IV/nonce和计数器的组合是用于产生流密钥的关键<br>如果每一次加密的IV/nonce都是一样的，导致生成的流密钥也是一样的<br>如果已知一段明密文，则可以通过明文和密文的异或恢复出密钥流，并用这个密钥流对其他密文解密，这就是IV复用</p><h6><span id="iv复用例题">IV复用例题</span></h6><pre><code class="lang-python">import osfrom Crypto.Cipher import AESFLAG=b&quot;flag{test_flag_}&quot;KEY=os.urandom(16)NONCE = os.urandom(12)def aes_ctr_encrypt(pt):    aes = AES.new(KEY,AES.MODE_CTR, nonce=NONCE)    ct=aes.encrypt(pt)    return ctdef aes_ctr_decrypt(ct):    aes = AES.new(KEY,AES.MODE_CTR, nonce=NONCE)    pt=aes.decrypt(ct)    return ptprint(f&quot;flag:{aes_ctr_encrypt(FLAG)}&quot;)while True:    user_input=bytes.fromhex(input(&quot;Input a hex string tto encrypt:&quot;))    ct=aes_ctr_encrypt(user_input)    print(f&quot;Your ciphertext:{ct}&quot;)</code></pre><p>从题目中我们可以获取以下信息(其中$P<em>{flag}$和$K$均未知)<br>$P</em>{flag} ⊕ K = C<em>{flag}$<br>我们可以任意选取一段明文$P</em>{user}$发送给服务端,并得到$C<em>{user}$满足<br>$P</em>{user}⊕ K = C<em>{user}$<br>从中可以解出$K$<br>$K = P</em>{user} ⊕ C<em>{user}$<br>从而可以求出$P</em>{flag}$<br>$P<em>{flag}=K ⊕ C</em>{flag} = P<em>{user} ⊕ C</em>{user} ⊕ C_{flag}$</p><h5><span id="分组模式相关利用手法b">分组模式相关利用手法B</span></h5><h6><span id="ecb模式剪贴">ECB模式剪贴</span></h6><p>某个网站的用户cookie如下:<br>coukte=session:aa82ef0a;timedl=1;admin=0;guess_cookie_ma=1;gueess_mp_ab=1;guess_cookie_mb=0;hell_pad=233<br>采用128位的AES-ECB模式对cookie进行加密,所得的密文如下:<br>fa38dcf486e5098ad574c1cc5b06aa7dd6e125070668ffc10579d2dcb71a<br>3871a6ffd90507da87a355702ea8d329d01aced9355f1a946843e452f3299b<br>ae84ab736c4f6306a98cef4e0e294b4bd397d1aa696c56b5950fae5c7ce61f<br>e5fc2579<br>仅当”admin=1”时,才能得到flag</p><p>由于ECB模式下密文和明文一一对应，所以可以进行特定的剪贴修改</p><pre><code class="lang-python">plain = &quot;session:aa82ef0a;timedl=1;admin=0;guess_cookie_ma=1;gueess_mp_ab=1;guess_cookie_mb=0;hell_pad=233&quot;for i in range(0,len(plain),16)    print(i//16 + 1,plain[i:i+16])</code></pre><p>输出结果：<br>1 session:aa82ef0a<br>2 ;timedl=1;admin=<br>3 0;guess_cookie_m<br>4 a=1;guess_mp_ab=<br>5 1;guess_cookie_m<br>6 b=0;hell_pad=233<br>可以看见第三行和第五行相似，第五行就是我们想要的第三行效果，进行剪贴</p><p>new_cipher = \<br>cipher_blocks[0] + \<br>cipher_blocks[1] + \<br>cipher_blocks[4] + \ 替换为第5组密文块<br>cipher_blocks[3] + \<br>cipher_blocks[4] + \<br>cipher_blocks[5]</p><h6><span id="cbc模式字节翻转">CBC模式字节翻转</span></h6><p>CBC模式的解密过程可以由如下关系式来表示(其中nb是块的数量):</p><p>$P<em>1=Dec_k(C_1) ⊕ IV$<br>$P_i=Dec_k(C_i) ⊕ C</em>{i-1}, 1&lt;i&lt;nb$</p><p>从中可以看出,若修改某个密文块$C_{i-1}$,<br>则会影响到解密出来的了不一个明文块$P_i$,即我们可以通过篡改密文来任意操纵明文</p><p>假设想要控制某个块的明文,可以通过修改前一块密文相应的字节来达到这个目的<br>若要修改第3个明文块第i个字节的数值,则可以对第2个密文块第i个字节异或上相应的数值<br>(但也会导致解密出来的第2块明文不可预测)</p><h5><span id="分组模式相关利用手法c">分组模式相关利用手法C</span></h5><h6><span id="pkcs7填充">PKCS7填充</span></h6><p>PKCS7是一种常用的填充方式,其具体的填充方式为:填充N个字节,且这N个填充字节的字节值均N</p><p>例如,当块大小为16时,对”aaaabbbcccc”进行填充<br>填充的结果为”aaaabbbcccc\x04\x04\x04\x04\x04”</p><p>注意:即使最后一个块的长度为16,PKCS7填充方式仍然会对其<br>进行填充,会在其后填充一块全为0x10的16字节块。</p><pre><code class="lang-python">def pad(pt):    pad_length = 16 - len(pt)%16    pt += bytes([pad_length]) * pad_length    return ptdef unpad(pt):    pad_length = pt[-1]    if not 1≤ pad_length ≤ 16:        return None    if pad(pt[:-pad_length]) != pt:        return None    return pt[:-pad_length]</code></pre><h6><span id="padding-oracle">Padding Oracle</span></h6><p>服务端在进行AES-CBC解密的时候,会对解密的结果做解除填充(unpad)操作<br>如果解除填充时校验到填充格式不合法,则会直接报错,通常会返回对应的错误消息息”Padding Error!”</p><pre><code class="lang-python">def decrypt(cipher):    #AES-CBC解密    decrypted_res = aes.decrypt(cipher)    #解除填充    plaintext = unpad(decrypted_res)    if not plaintext:#填充格式错误,unpad函数返回None        return &quot;Padding Error!&quot;    #继续执行    return &quot;OK&quot;</code></pre><p>场景目标:对手获取到了一段密文,想要对其进行解密<br>利用思路:可以通过字节翻转的手法来修改解密后的明文,并将其发送给服务端<br>若修改后的明文符合填充格式,服务器返回OK,则对手可以从中获取到一些关于原始密文的一些信息</p><p>如何解密最后一个字节?<br>我们要利用……0x01这个合法的填充格式<br>假设g为最后一字节(共有256种可能性)<br>对上一个密文块的最后一字节异或上g^0x01<br>则解密后的最后一个明文块也会异或上g^0x01<br>若g正确,则最后一块格式为……0x01,服务器返回OK,否则服务器返回Padding Error</p><p>如何解密倒数第i个字节?<br>我们要利用……0x0i这个合法的填充格式<br>先通过已解出来倒数i-1个明文,通过字节翻转的方式将解密后的明文块后i-1修改为0x0i;<br>然后继续使用解密倒数第1个字节的方式,尝试256种可能的g,直至服务器返回OK,说明g即为倒数第i个字节</p><p>通过上述方法,可以解密出最后一个明文块的16个字节<br>解密完之后,即可将最后16字节的密文抛弃,继续对倒数第二块密文块进行解密<br>依此方法,可以对所有密文进行解密,恢复出整个明文信息</p><pre><code class="lang-python">#padding_oracle recovers the last 16 plaintext bytesof the given ciphertextdef padding_oracle(cipher):    plaintext=b&quot;&quot;    for indexinrange(1,17):        print f&quot;[*] index:{index}&quot;        for byte in range(0,256):            bytes_xor=b&quot;\x00&quot;*(16-index)+bytes [byte index]+xor plaintext,bytes([index]*(index-1))            new_cipher = cipher[:-32] + xor cipher[-32:-16], bytes_xor + cipher -16:            if oracle(new_cipher)== &quot;Padding Error!&quot;:                print(f&quot;[{byte:&gt;3d}], Padding Error!&quot;)            else:                plaintext=bytes([byte])+plaintext                print(f&quot;[{byte:&gt;3d}] OK&quot;)                print(f&quot;plaintext:{plaintext}&quot;)                breakreturn plaintext</code></pre><h3><span id="非对称密码">非对称密码</span></h3><p>公钥密码一般都是基于一些数学难题设计的<br>如RSA算法就是基于大整数因数的分解问题<br>DH密钥交换算法是基于离散对数问题<br>ECC算法是基于椭圆曲线离散对数问题</p><h4><span id="公钥密码-rsa">公钥密码-RSA</span></h4><p>RSA算法的安全性取决于其底层的数学难题—大整数因数分解问题的难度<br>对于一些不安全/位数比较小的素数,以当前的算法和算力很容容易将其分解<br>通常300bit以下的模数均可在较短时间内被分解,一些不安全的素数也会很快被特定算法所分解<br>RSA过程分为密钥生成、加密、解密三部分</p><h5><span id="公钥密码-rsa密钥生成">公钥密码-RSA密钥生成</span></h5><p>选两个大素数：随机选两个不同的大素数p和q<br>计算 n：n = p \times q(n是公钥 / 私钥的 “模数”，会公开)<br>计算欧拉函数 φ(n)：φ(n) = (p-1) \times (q-1)(φ(n) 是小于 n 且与 n 互质的数的数量)<br>选公钥指数 e：选一个整数e，满足1 &lt; e &lt; φ(n)且e与φ(n)互质<br>算私钥指数 d：求d，满足(e \times d) mod φ(n) ≡ 1（即d是e在模φ(n)下的逆元<br>最终密钥：<br>公钥：(e, n)(公开给其他人)<br>私钥：(d, n)(自己保管，绝对保密)</p><h5><span id="公钥密码-rsa加解密">公钥密码-RSA加解密</span></h5><p>假设要加密的明文是M(需满足0 &lt; M &lt; n，若 M 太大则分段加密)<br>加密公式：密文C ≡ M ^ e (mod n)</p><p>用私钥解密密文C<br>解密公式：明文M ≡ C ^ d (mod n)</p><h5><span id="公钥密码-rsa模数分解">公钥密码-RSA模数分解</span></h5><h6><span id="公钥密码-rsa模数分解方式一直接分解">公钥密码-RSA模数分解方式一(直接分解)</span></h6><p>sagemath中直接使用函数 factor(n)即可</p><h6><span id="公钥密码-rsa模数分解方式二pq相近">公钥密码-RSA模数分解方式二(p,q相近)</span></h6><pre><code class="lang-python">from Crypto.Util.number import getPrime, isPrimedef nextPrime(p):    p = (p+2)|1    while not isPrime(p):        p += 2    return pdef genkey(bits):    p = getPrime(bits)    q = nextPrime(p)    e = 65537    n = p*q    return np = getPrime(512)q = nextPrime(p)</code></pre><p>一般来说，这样生成的两个p，q相差不过几百或者几千<br>有关系：$p^2&lt;n&lt;q^2$<br>则近似平方根必然落在pq之间且距离近，可以通过穷举的方式找到</p><h6><span id="公钥密码-rsa模数分解方式三模不互素">公钥密码-RSA模数分解方式三(模不互素)</span></h6><p>当两个模数共有一个素数时，有下面关系：<br>$n_1 = p·q_1$<br>$n_2 = p·q_2$<br>可以对两个模数求最大公约数gcd，这个数就是素因子p，从而分解两个模数</p><p>from Crypto.Util.number import GCD</p><p>p = GCD(n1, n2)<br>q1 = n1 // p<br>q2 = n2 // p</p><h6><span id="公钥密码-rsa模数分解方式四共模攻击">公钥密码-RSA模数分解方式四(共模攻击)</span></h6><p>当n难以分解时，使用相同的模数、不同的私钥,加密同一明文消息时即存在”共模”，绕过分解n<br>$已知密文c_1,c_2，公钥e_1,e_2以及模数n$时<br>现在有下面关系：<br>$m ^ {e_1} ≡ c_1 \ (mod \ n)$<br>$m ^ {e_2} ≡ c_2 \ (mod \ n)$</p><p>扩展欧几里得算法计算：<br>$ax + by = gcd(a,b)$</p><p>根据此算法计算出<br>$re<em>1 + se_2 = 1$<br>从而有<br>$c</em>{1}^{r} c_{2}^{s} ≡ m^{re_1 + se_2} ≡ m^1 \ (mod \ n)$<br>使得右上角的指数变成1</p><pre><code class="lang-python">from Crypto.Util.number import *from math import gcdimport gmpy2 as gpn = &#39;&#39;e1 = &#39;&#39;e2 = &#39;&#39;c1 = &#39;&#39;c2 = &#39;&#39;g, r, s = gp.gcdext(e1,e2)m = pow(m,r,n) * pow(m,s,n) % nprint(long_to_bytes(gp.iroot(m,g) [0]))</code></pre><h5><span id="公钥密码-rsa指数利用方法">公钥密码-RSA指数利用方法</span></h5><h6><span id="小公钥e指数利用">小公钥e指数利用</span></h6><p>RSA通过模幂运算对明文加密,当指数逐渐增大时,模运算发挥作用将整数幂运算的结果截断至有限范围内<br>但是当指数太小时,模运算还未发挥作用,幂运算就已经结束<br>此时的加密结果并没有被截断,即是原本的幂运算,此时就不存在”加密”效果<br>$c ≡ m^e \ (mod \ n) ➡ c = m^e$</p><p>当$m$较小时,即$m^e&lt;n$时,就会存在这种利用<br>另外,即使$m^e$稍比$n$大一点点,也可以通过穷举的方式对其尝试开根<br>$c ≡ m^e \ (mod \ n) ➡ c = m^e - k·n$<br>可以从0开始穷举$k$,并对$k·n + c$尝试开$e$次方根,若可以开出来根,则说明成功解密<br>(对于正常的RSA加密,$k$一般很大,无法被穷举)</p><pre><code class="lang-python">for k in range(0,100000000000):    tmp=k*n+c    root, ok = tmp.nth_root(e,truncate_mode=True)    if ok:        print(root)        break</code></pre><h6><span id="已知e和d分解n">已知e和d分解n</span></h6><p>RSA算法若能够知道加密指数e和解密指数d,则可以完成对n的的分解。<br>根据e和d的关系有<br>$e·d ≡ 1 \ (mod \ \phi(n))$<br>同样可以化为<br>$➡e·d = 1 + k·\phi(n)$<br>其中$d &lt; \phi(n)$,因此必有$k&lt;e=65537$,k可以穷举,从而可以得到中<br>$\phi(n)=(p-1)·(q-1)$</p><p>得到$\phi(n)$后，根据n的表达式我们可以得到二元二次方程<br>$\phi(n)=(p-1)·(q-1)$<br>$n = p·q$<br>解出这个方程从而分解n</p><pre><code class="lang-python">for k in range(1,e):    if (e*d - 1) % k == 0: #k可以整除e·d-1        phi=(e*d - 1) // k        if pow(123,phi,n) == 1: #满足欧拉定理            var(&#39;p q&#39;)            print(solve([(p-1)*(q-1)== phi,p*q=n, p*q = n], [p,q]))</code></pre><h6><span id="wiener利用">Wiener利用</span></h6><p>当d比较小($d&lt;\frac{1}{3}N^\frac{1}{4}$)时,可以使用Wiener利用来获取私钥d<br>特征:通常出题人为了要使得生成的私钥d比较小,通常会先生成一个比较小的d,<br>然后再去求e,从而使得e的取值范围位于(1,$\phi$)之间,会导致e看起来很大</p><p>从两条关系出发<br>$\phi(n) = (p-1)·(q-1) = n - (p + q) +1$<br>$e·d = 1 + k·\phi(n)$<br>带入有<br>$e·d = 1 + k·[ n - (p + q) +1]$<br>两边同时除以nd，得到<br>$\frac{e}{n} = \frac{k}{d}(1 - \delta)$<br>式子左边均已知,右边均未知,右边和左边非常接近<br>这种情况可以使用连分数来将左边的比值展开,在连分数的展开式中,很大概率存在k和d<br>从而可以求出私钥d,进行解密</p><pre><code class="lang-python">def recover(e, N):    e = Integer(e)    N = Integer(N)    cf = continued_fraction(e / N).convergents()    G.&lt;x&gt; = ZZ[&#39;x&#39;]    for k_frac in cf[1:]:        d0 = k_frac.denominator()        k = k_frac.numerator()        if k == 0 or d0 == 0:            continue        if (e * d0 - 1) % k != 0:            continue        phi = (e * d0 - 1) // k        s = N - phi + 1        f = x^2 - s*x + N        discriminant = f.discriminant()        if discriminant &lt;= 0 or not discriminant.is_square():            continue        roots = f.roots(multiplicities=False)        roots = [Integer(root) for root in roots if root.is_integer()]        if len(roots) == 2 and roots[0] * roots[1] == N:            p, q = roots            true_phi = (p - 1) * (q - 1)            if (e * d0) % true_phi == 1:                print(f&quot;[x] 恢复成功！&quot;)                print(f&quot;d = {d0}&quot;)                print(f&quot;d (十六进制) = {hex(d0)}&quot;)                print(f&quot;p = {p}&quot;)                print(f&quot;q = {q}&quot;)                print(f&quot;phi(N) = {true_phi}&quot;)                print(f&quot;验证：e*d mod phi(N) = {(e*d0) % true_phi}（应为1）&quot;)                return d0  # 返回正确的d    print(&quot;[-] 恢复失败&quot;)    return None</code></pre><h5><span id="公钥密码-rsa-lsb利用方法">公钥密码-RSA-LSB利用方法</span></h5><h6><span id="最低位预言机攻击lsb-oracle-attack">最低位预言机攻击(LSB Oracle Attack)</span></h6><p>假设现在有一个oracle(预言机),它会对一个给定的密文进行解密<br>但并不会直接返回解密结果,而是检验解密的明文的奇偶性<br>根据奇偶性返回相应的值,比如1表示奇数,0表示偶数,即最低位( LSB, least significant bit )<br>那么给定任意一个消息被加密后的密文,只需要$log_2(N)$次oracle询问,就可以解密出明文消息<br>(例如当N是1024位时,只需要大约1024次左右的oracle询问,就可以解密出明文)</p><pre><code class="lang-python">cc = int(raw_input(&#39;Your encrypted message:&#39;).strip())mm = k.decrypt(cc)if mm &amp; 1 == 1:    print &#39;The plain of your decrypted message is odd!&quot;else:    print &#39;The plain of your decrypted message is even!</code></pre><h6><span id="rsa的积性乘法同态">RSA的积性(乘法同态)</span></h6><p>由RSA加密关系<br>$(P<em>1·P_2)^e = P</em>{1}^e · P_{2}^e \ (mod \ n)$<br>可证明得到<br>$Enc(P_1,P_2) = Enc(P_1) · Enc(P_2)$<br>利用这个性质，可以选择一个s，计算$c’ ≡ c·s^e \ (mod \ n)<br>将$c’$发送给服务器，服务器就会返回加密结果$m·s$的奇偶性<br>通过巧妙地继续选取s，就可以恢复出m</p><h6><span id="公钥密码-rsa-lsb解密代码实现">公钥密码-RSA-LSB解密代码实现</span></h6><pre><code class="lang-python">L, H = 0, nt = pow(2,e, e, n)cc = cfor i in range(n.bit_length()):    cc = (t * cc) % n    if oracle(cc)== 0:        H = (L + H) // 2    else:        L = (L + H) // 2    print(L,H) #结果并不一定精确,需要再附近找一下正确的for x in range(-1000,1000):    if pow(x+m,e,n) == c:        print(x+m)</code></pre><h5><span id="公钥密码-rsa-coppersmith利用方法">公钥密码-RSA-Coppersmith利用方法</span></h5><h6><span id="coppersmith定理">Coppersmith定理</span></h6><p>假设N为一个未知分解情况的合数，并定义<br>$p(x) = x^k + a_{k-1} x^{k-1} +···+ a_2 x^2 + a_1 x + a \ (mod \ N)$<br>为一个最高次数为k的整数系多项式</p><p>假设这个多项式存在一个根$x_0$，即<br>$p(x_0) = 0 \ (mod \ N)$ 且满足$|x_0| &lt; N^\frac{1}{k}$<br>Coppersmith给出了一个算法可以很快求出这个小根</p><p>Coppersmith定理<br>令$p(x)$为一个最高次位数为k的首一多项式，N为一个未知分解情况的正合数,$\epsilon&gt;0$为一个极小的量<br>那么在多项式时间(算法复杂度较低)内,我们可以找到$p(x)$的整数解$x_0$,满足<br>$|x_0| &lt; \frac{1}{2}N^{(\frac{1}{k}-\epsilon)}$<br>(证明过于复杂,涉及到格构造、LLL算法等知识点)</p><h6><span id="已知m高位">已知m高位</span></h6><p>题目场景:假设模数n为1024bit,e=3,现在已知m的高位m0,<br>只有低72位未知,未知量符合小根的条件(小于341bit)<br>设未知量为x,构造如下modn的多项式:<br>$f= (m_0 + x)^3 - c \ (mod \ n)$<br>使用Coppersmith定理即可求解出x</p><pre><code class="lang-python">K = Zmod(n)P.&lt;x&gt; = PolynomialRing(K)f = (m0 + x)^e - cf.small_roots()</code></pre><h4><span id="公钥密码-dh密钥交换">公钥密码-DH密钥交换</span></h4><h5><span id="公钥密码-dh密钥交换前置知识">公钥密码-DH密钥交换前置知识</span></h5><h6><span id="群基础基础定义">群基础基础定义</span></h6><p>集合简单来讲就是把一堆东西(元素)放在一起<br>群是一个集合,并且在这个集合上定义了一个运算(比如加法、乘法)<br>简而言之群，就是集合+运算</p><p>简单来说，群的作用就是描述对称性<br>系统从一个状态通过某种运算变换到另一个状态<br>如果这两个状态等价，则说系统对这一变换时对称的</p><p>群通过数学化的方式定义对称性<br>群只关心对称最本质，最抽象的性质，所以只关心操作，将操作放到集合里面</p><p>举例对一个正方体进行操作，有操作{保持不变，旋转90°，旋转180°，旋转270°}</p><p>类比加法<br>保持不变 ➡ 0<br>旋转90° ➡ r<br>旋转180° ➡ 2r<br>旋转270° ➡ 3r</p><p>类比乘法<br>保持不变 ➡ 0<br>旋转90° ➡ r<br>旋转180° ➡ r^2<br>旋转270° ➡ r^3</p><p>这里的加法乘法都是模运算，每四次运算就是一个周期<br>3r + r = 0 (mod 4)<br>r^3 · r = 0 (mod 4)<br>这样我们就得到了两个群<br>$(G,+) = ({0,r,2r,3r},+)$<br>$(G,\times) = ({0,r,r^2,r^3},\times)$</p><p>所以群就是一个集合G，加上一个运算“·”，满足以下四个条件:<br>封闭性：$对于所有a,b∈G，有a·b∈G$<br>结合性：$对于所有a,b,c∈G，有(a·b)·c=a·(b·c)$<br>单位元：$存在一个e∈G，使得对于所有a∈G，有e·a=a·e=a$<br>逆元：$对于每个a∈G，存在一个b∈G，使得a·b=b·a=e，即b就是a的逆元，记作a^{-1}$</p><p>以$(G,+) = ({0,r,2r,3r},+)$为例：<br>集合元素：所有保证对称的操作{0,r,2r,3r}<br>二元运算：加法“+”<br>封闭性：旋转组合的结果还是在集合里面<br>结合性：旋转的顺序不影响最终结果<br>单位元：保持不变0<br>逆元：每个操作都有一个对应的逆操作，比如r的逆操作是3r</p><p>模p乘法运算也可以组成一个群，定义为：<br>$(Z_p^*, \times) = ({1,2,3,···，p-1}, \times)$<br>集合元素：所有小于p的正整数<br>二元运算：模p乘法<br>封闭性：两个小于p的数相乘模p结果还是小于p的数<br>结合性：乘法满足结合律<br>单位元：1<br>逆元：根据扩展欧几里得定理，对于每一个元素a，都存在整数x和y<br>使得$ax + py = 1$，则x就是a的逆元</p><h6><span id="群的特性">群的特性</span></h6><p>群的阶数：群中所有元素的个数，记作|G|<br>元素的阶数：对于群G中的元素a，存在最小的正整数k，使$a^k = e$，则称k为a的阶数，记作ord(a)</p><p>有些元素的阶数等于群的阶数，这样的元素称为生成元或者原根，一般记作g</p><p>对于乘法群$(Z<em>p^*, \times)$，其阶数为p-1<br>通过g的幂次运算，可以生成群中的所有元素<br>例如$(Z</em>{11}^*, \times)$的原根g=2来说</p><div class="table-container"><table><thead><tr><th>(i)</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>(a^i)</td><td>2</td><td>4</td><td>8</td><td>5</td><td>10</td><td>9</td><td>7</td><td>3</td><td>6</td><td>1</td></tr></tbody></table></div><p>对于加法群$(Z<em>n, +)$来说，生成元是所有和n互素的数<br>例如$(Z</em>{10}, +)$的生成元g=3来说</p><div class="table-container"><table><thead><tr><th>(i)</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>(a^i)</td><td>0</td><td>3</td><td>6</td><td>9</td><td>2</td><td>5</td><td>8</td><td>1</td><td>4</td><td>7</td></tr></tbody></table></div><h6><span id="离散对数难题">离散对数难题</span></h6><p>在群$(Z_p^*, \times)$中，若有一个原根g，很容易算出所有元素<br>$a ≡ g^k \ (mod \ p)$<br>但是反过来，已知a和g，要算出k就非常困难<br>$k = log_g a \ (mod \ p)$<br>这就是离散对数难题(DLP, Discrete Logarithm Problem)</p><p>在密码学的实际应用中，一般会选择大素数p(至少2048bit)和对应的原根g<br>现有的最好的通用型解决离散对数问题的算法，其算法的时间复杂度也非常高<br>Baby Step Giant Step算法的时间复杂度为$O(\sqrt{p})$<br>Pollard’s Rho算法的时间复杂度为$O(\sqrt{p}·log(p))$<br>Pohlig-Hellman算法的时间复杂度为$O(\sum_{i=1}^{k} e_i (log p + \sqrt{p_i}))$<br>(其中$p_i^{e_i}$为p的质因数分解)<br>Index Calculus算法的时间复杂度为$L_p[1/2, c] = exp(c (log p)^{1/2} (log log p)^{1/2})$</p><p>SageMath中可以直接使用discrete_log函数来计算离散对数<br>默认调用Baby Step Giant Step算法和Pollard’s Rho算法<br>在数据量比较小的时候可以快速解决(100bit以下)</p><pre><code class="lang-python">g = Mod(2, 37)discrete_log(Mod(15, 37), g)</code></pre><h5><span id="公钥密码-dh密钥交换协议">公钥密码-DH密钥交换协议</span></h5><p>首先通信双方先共享两个公共参数，模数p和生成元g<br>Alice本地随机生成一个私钥a，并计算$A ≡ g^a \ (mod \ p)$，将A发送给Bob<br>Bob收到A后，本地随机生成一个私钥b，并计算$B ≡ g^b \ (mod \ p)$，将B发送给Alice<br>同时Bob计算共享密钥$K ≡ A^b ≡ g^{ab} \ (mod \ p)$<br>Alice计算共享密钥$K ≡ B^a ≡ g^{ab} \ (mod \ p)$<br>最终Alice和Bob都得到了相同的共享密钥K<br>以这个key作为对称加密算法的密钥，进行后续的通信加密</p><h5><span id="公钥密码-dh密钥交换中间人攻击">公钥密码-DH密钥交换中间人攻击</span></h5><p>假设有一个攻击者Eve,她可以监听Alice和Bob之间的通信<br>当Alice发送A给Bob时,Eve截获了A,并生成自己的私钥c,计算$E ≡ g^c \ (mod \ p)$,将E发送给Bob<br>当Bob发送B给Alice时,Eve截获了B,并将E发送给Alice<br>此时Alice计算共享密钥$K<em>{AE} ≡ E^a ≡ g^{ac} \ (mod \ p)$<br>Eve计算共享密钥$K</em>{AE} ≡ A^c ≡ g^{ac} \ (mod \ p)$<br>Bob计算共享密钥$K<em>{BE} ≡ E^b ≡ g^{bc} \ (mod \ p)$<br>Eve计算共享密钥$K</em>{BE} ≡ B^c ≡ g^{bc} \ (mod \ p)$<br>最终Eve成功地和Alice、Bob分别建立了两个共享密钥，可以伪装进行通信<br>拿到双方的通信原始数据</p><h4><span id="公钥密码-elgamal加密算法">公钥密码-ElGamal加密算法</span></h4><p>ElGamal加密算法基于离散对数难题设计<br>首先通信双方先共享两个公共参数，模数p和生成元g<br>Alice本地随机生成一个私钥x，并计算$y ≡ g^x \ (mod \ p)$，将y作为公钥发送给Bob<br>Bob收到y后，选择一个随机数k(1 &lt; k &lt; p-2且k与p-1互素)<br>Bob计算临时公钥$C_1 ≡ g^k \ (mod \ p)$<br>Bob计算共享密钥$K ≡ y^k ≡ g^{xk} \ (mod \ p)$<br>对m进行处理使得$m &lt; p$(如果m过大，可以分段加密)<br>Bob使用共享密钥K对消息m进行加密，计算$C_2 ≡ m·K \ (mod \ p)$<br>Bob将密文对$(C_1, C_2)$发送给Alice<br>Alice收到密文对$(C_1, C_2)$后，计算共享密钥$K ≡ C_1^x ≡ g^{kx} \ (mod \ p)$<br>Alice使用共享密钥K对$C_2$进行解密，计算$m ≡ C_2 · K^{-1} \ (mod \ p)$</p><p>加密侧（B）：$K = y_A^k = (g^x)^k = g^{xk}$  → $C_2 = M \times K \mod p$<br>解密侧（A）：$K = C_1^x = (g^k)^x = g^{xk}$  → $M = C_2 \times K^{-1} \mod p$</p><h4><span id="公钥密码-dsa数字签名算法">公钥密码-DSA数字签名算法</span></h4><p>数字签名用于验证消息的完整性和真实性<br>数字签名一般是基于非对称密码加密算法实现的，非对称算法的解密运算即为签名，加密运算即位验签<br>假设Bob想要对一份文档m进行签名，Bob会使用他的私钥对文档进行签名运算，并得到签名sig<br>随后Bob将文档m和签名sig发送给Alice，Alice使用Bob的公钥对签名sig进行验签运算</p><p>数字签名的要点：<br>签名的消息m不一定要加密，可以明文的形式传输<br>只有签名者有私钥，能够对消息进行签名，任何其他人没有私钥无法签名<br>任何人都可以使用签名者的公钥对签名进行验证<br>消息完整性：如果消息在传输过程中被篡改，验签会失败<br>不可抵赖性：因为只有Bob有私钥，只有他能生成有效签名，所以Bob不能否认他签署过该消息</p><h5><span id="哈希函数">哈希函数</span></h5><p>在数字签名中，一般不会直接对消息m进行签名<br>而是先对消息m进行哈希运算，得到消息摘要H(m)<br>然后对消息摘要H(m)进行签名</p><p>哈希函数能够将任意长度的输入映射为固定长度的输出值(散列值或摘要)<br>特征：<br>接受任意长度输入：SHA1最高可接受2^64-1位的输入<br>固定长度输出：SHA1输出160位(20字节)的摘要<br>高效性：哈希函数计算时间短<br>单向性：已知哈希函数的输出$y = H(m)$，很难反推出输入m<br>抗碰撞性：很难找到两个不同的输入m1和m2，使得$H(m1) = H(m2)$<br>雪崩效应：输入的微小变化会导致输出的显著变化</p><p>常见的哈希函数：<br>MD2：输出128位摘要，设计用于8位处理器<br>MD5：输出128位摘要，已被证明存在碰撞漏洞，不推荐用于安全<br>SHA1：输出160位摘要，已被证明存在碰撞漏洞，不推荐用于安全<br>SHA256：输出256位摘要，当前被广泛使用，安全性较高<br>SHA512：输出512位摘要，安全性更高，但计算速度较慢<br>CRC32：输出32位摘要，主要用于数据完整性校验，不适合安全应用<br>Tiger：输出192位摘要，设计用于高安全性应用<br>Adler32：输出32位摘要，速度快，适用于数据完整性校验<br>RipeMD160：输出160位摘要，设计用于数字签名和加密应用</p><p>哈希函数除了数字签名，还有很多其他用途：<br>散列表：方便数据的查询，搜索，可以达到O(1)的时间复杂度<br>错误矫正：可以通过检查散列值，判断传输的信息是否在中途被篡改<br>区块链：可被用作工作量证明，使用散列值来链接区块</p><h6><span id="哈希函数-sha1算法secure-hash-algorithm-1-安全散列算法1">哈希函数-SHA1算法(Secure Hash Algorithm 1 安全散列算法1)</span></h6><p>SHA1算法的输入是几乎任意长度的消息(最大2^64bit)，输出是160位(20字节)的消息摘要<br>SHA1算法采用Merkle-Damgård结构，分块处理输入消息，每块512位(64字节)<br>SHA1算法的主要步骤：<br>填充消息：在消息末尾添加一个’1’位，然后添加足够的’0’位，使消息长度对512取模后等于448<br>添加长度：在消息末尾添加一个64位的整数l，l表示原始消息的长度<br>初始化哈希值：使用五个32位的常数IV作为初始哈希值<br>处理消息块：压缩函数将消息处理<br>输出摘要：将最终的哈希值连接起来，得到160位的消息摘要</p><p>压缩函数：<br>初始化链接状态为固定的初始值IV<br>将512位消息块扩散为80个字<br>每20个字会经过一个20轮的运算，每一轮都会更新链接状态<br>80轮运算后，链接状态经过变换输出，作为下一次压缩函数的输入</p><h6><span id="哈希函数长度扩展攻击">哈希函数长度扩展攻击</span></h6><p>在某些登录场景中，服务器会通过哈希函数来进行全校认证<br>合法用户应当知道$secret的具体值，从而可以计算出正确的散列值以此校验登录</p><pre><code class="lang-php">&lt;?phpinclude &quot;secret.php&quot;; // secret.php中定义了$secret变量@$username = (string)$_POST[&#39;username&#39;];function enc($text){    global $secret;    return md5($secret . $text);}if(enc($username) === $_COOKIE[&#39;verify&#39;]){    if(is_numeric(strpos($username, &quot;admin&quot;))){        echo ($flag);    } else {        die(&quot;you are not admin!&quot;);    }}else{kie(&quot;verify&quot;, enc($guest), time() + 60*60*24*7);}?&gt;</code></pre><p>哈希长度扩展利用：当已知Hash(m)，但未知m，能够计算Hash(secret || m || padding || m’)<br>当我们初次登陆时，服务器会设置cookie为Hash(secret || “guest”)，并将摘要以cookie的形式发送给客户端<br>借助哈希长度扩展攻击，我们可以计算出Hash(secret || “guest” || padding || “admin”)<br>设置username为”guest” || padding || “admin”，其中带有admin字样，就可以登陆拿flag</p><h5><span id="公钥密码-数字签名-rsa签名">公钥密码-数字签名-RSA签名</span></h5><p>RSA加密算法不仅可以对数据进行加密，也可以用来数字签名<br>不同的是，签名使用私钥进行“加密”，验签使用公钥进行“解密”</p><h5><span id="公钥密码-数字签名-elgamal签名">公钥密码-数字签名-ElGamal签名</span></h5><p>p：一个大素数<br>g：p的一个原根(生成元)<br>x：签名者的私钥，随机选择，1 &lt; x &lt; p-2<br>y：签名者的公钥，计算$y ≡ g^x \ (mod \ p)$得到</p><h6><span id="公钥密码-数字签名-elgamal签名过程">公钥密码-数字签名-ElGamal签名过程</span></h6><p>随机生成一个整数k，满足1 &lt; k &lt; p-2且k与p-1互素<br>计算$r ≡ g^k \ (mod \ p)$<br>计算$s ≡ (H(m) - x*r) k^{-1} \ (mod \ p-1)$<br>签名结果为签名对$(r, s)$</p><h6><span id="公钥密码-数字签名-elgamal验签过程">公钥密码-数字签名-ElGamal验签过程</span></h6><p>计算$v = y^r \times r^s \ (mod \ p)$<br>计算解密后的消息相关量$H(m)$<br>如果$v ≡ g^{H(m)} \ (mod \ p)$，则验签通过，否则验签失败</p><p>$v = y^r <em> r^s (mod \ p)$<br>$  = (g^x)^r </em> (g^k)^s (mod \ p)$<br>$  = g^{xr} * g^{ks} (mod \ p)$<br>$  = g^{xr + ks} (mod \ p)$<br>$  = g^{H(m)} (mod \ p)$  # 根据签名计算公式可知$xr + ks ≡ H(m) \ mod \ (p)$</p><h6><span id="公钥密码-数字签名-elgamal签名k重用攻击">公钥密码-数字签名-ElGamal签名k重用攻击</span></h6><p>假设签名者在对两个不同的消息$H(m_1)$和$H(m_2)$进行签名时，不小心重用了同一个随机数k<br>得到签名对$(r, s_1)$和$(r, s_2)$<br>根据签名公式，有下面两条关系：<br>$s_1 ≡ (H(m_1) - x<em>r) k^{-1} \ (mod \ p-1)$<br>$s_2 ≡ (H(m_2) - x</em>r) k^{-1} \ (mod \ p-1)$<br>将上面两条关系式相减，得到：<br>$k ≡ (H(m_1) - H(m_2))(s_1 - s_2)^{-1} \ (mod \ p-1)$<br>恢复出k后，带入任意一条关系式，即可求出私钥x：<br>$x ≡ (H(m_1) - s_1*k) r^{-1} \ (mod \ p-1)$</p><pre><code class="lang-python">from Crypto.Util.number import inverse(p,g) = ( , )(m1,r1,s1) = ( , , )(m2,r2,s2) = ( , , )k = (m1 - m2) * inverse(s1 - s2, p-1) % (p-1)x = (m1 - s1 * k) * inverse(r1, p-1) % (p-1)print(f&quot;私钥x: {x}&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 现代密码 </tag>
            
            <tag> 密码学 </tag>
            
            <tag> 加密 </tag>
            
            <tag> 解密 </tag>
            
            <tag> 古典密码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/myblog.github.io/about/index.html"/>
      <url>/myblog.github.io/about/index.html</url>
      
        <content type="html"><![CDATA[<p>Hi！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/myblog.github.io/tags/index.html"/>
      <url>/myblog.github.io/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/myblog.github.io/manifest.json"/>
      <url>/myblog.github.io/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"Alice and Bodの神秘小屋","short_name":"密码博客","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/256.png","sizes":"256x256","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/myblog.github.io/categories/index.html"/>
      <url>/myblog.github.io/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/myblog.github.io/css/custom.css"/>
      <url>/myblog.github.io/css/custom.css</url>
      
        <content type="html"><![CDATA[@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://cdn.cbd.int/anzhiyu-blog@latest/fonts/ZhuZiAYuanJWD.woff2);    font-display: swap;    font-weight: lighter;}@import url(https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap);/* 字体样式 */div#menu {    font-family: 'ZCOOL KuaiLe', cursive;}h1#site-title {    font-family: 'ZCOOL KuaiLe', cursive;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title{    font-family: 'ZCOOL KuaiLe', cursive;}/* 图标样式 */.iconfont{    font-family: 'iconfont' !important;    font-size: 3em;    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}svg.icon{    width: 1em;    height: 1em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before{    color:#f7c768;}/* bilibli番剧插件 */.bangumi-active{    background:#dbecfe !important;    border-radius:10px !important;}a.bangumi-tab:hover{    text-decoration:none !important;}.bangumi-button:hover{    background:#dbecfe !important;    border-radius:10px !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration:none !important;}.bangumi-button{    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size:1.1em;}/* 解决artitalk的图标问题 */#uploadSource > svg {    width:1.19em;    height:1.5em;}   /* 移除头图黑色透明玻璃效果 */#page-header:not(.not-top-img):before{    background-color: transparent !important;}/* 核心：透明化配置（修复rgba语法错误） *//* 首页文章卡片 */#recent-posts >.recent-post-item {    background:rgba(255,255,255,0.1) !important;}/* 首页侧栏卡片 */#aside-content .card-widget {    background:rgba(255, 255, 255,0.1) !important;}/* 文章页面正文背景 */div#post {    background:rgba(255,255,255,0.1) !important;}/* 分页页面 */div#page {    background:rgba(255, 255, 255,0.1) !important;}/* 归档页面 */div#archive {    background:rgba(255, 255, 255,0.1) !important;}/* 标签页面 */div#tag {    background:rgba(255, 255, 255,0.1) !important;}/* 分类页面 */div#category {    background:rgba(255, 255, 255,0.1) !important;}/* 夜间模式伪类遮罩层透明 */[data-theme='dark'] #recent-posts >.recent-post-item {    background: #121212 !important;}[data-theme='dark'] .card-widget {    background: #121212 !important;}[data-theme='dark'] div#post {    background: #121212 !important;}[data-theme='dark'] div#tag {    background:#121212 !important;}[data-theme='dark'] div#archive {    background:#121212 !important;}   [data-theme='dark'] div#page {    background: #121212 !important;}[data-theme='dark'] div#category {    background: transparent !important;}/* 核心：头部+尾部完全透明（提升选择器优先级） */#footer {    background: transparent !important;}#page-header,#page-header #site-banner {    background: transparent !important;    background-color: transparent !important;}#rightside > div > button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width:10px;    height:10px;}::-webkit-scrollbar-thumb {    background-color:#49b1f5;    border-radius:20px;}::-webkit-scrollbar-corner { /* 修复选择器拼写错误 */    background-color: transparent;}::selection{ /* 修复火狐/Chrome兼容 */    color:#fff;    background-color:#49b1f5;}/* 音乐播放器 */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body { /* 修复拼写错误 aplayer-bodyy */    left:-66px !important;    transition: all 0.3s;}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{    left:0 !important;    transition: all 0.3s;}.aplayer.aplayer-fixed {    z-index: 9999999 !important;}/* 评论框 */.vwrap{    box-shadow: 2px 2px 5px#bbb;    background: rgba(255, 255, 255,0.3) !important;    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}.vcard{    box-shadow:2px 2px 2px 5px#bbb;    background: rgba(255,255, 255,0.3) !important;    border-radius:8px;    padding: 30px;    margin: 30px 0px 0px 0px;   }/* md网站下划线 */#article-container a:hover {    text-decoration:none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin:0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0,-50%);}#error-wrap .error-content {        display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius:8px;    border-bottom-left-radius: 8px;    background-color: #49b1f5;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family:Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei',sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break:break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background:var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom:0px;    position: absolute;    padding: 1rem;    width:100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group{    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width:1200px;    margin:0 auto;}#body-wrap.error .aside-list .aside-list-item { padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width:100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow:hidden;    width: 230px;    height: 143px;    background: var(--heo-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;     padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
  
</search>
