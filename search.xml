<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>密码学数学基础 - 扩展二次剩余</title>
      <link href="/myblog.github.io/post/1004.html"/>
      <url>/myblog.github.io/post/1004.html</url>
      
        <content type="html"><![CDATA[<p>前一章中，我们主要聚焦于单一素数模数下的二次剩余问题，这为我们理解二次剩余奠定了坚实的基础。然而，在实际应用中，我们经常会遇到更复杂的情况，比如模数是合数或者有多个素因数的情况。在本章中，我们将扩展我们的视野，探讨这些更一般的二次剩余问题。</p><p>这章比较难，跟进我的步伐，Go~~~🚀</p><h2><span id="扩展模数与雅可比符号">扩展模数与雅可比符号 😵‍💫</span></h2><p>当模数为 $p^k$，其中 $p$ 是奇素数，$k \geq 1$ 时，我们可以通过扩展勒让德符号来判断一个数是否是模 $p^k$ 的二次剩余。对于一个整数 $a$ 和一个奇素数 $p$，我们定义：</p><script type="math/tex; mode=display">\left( \frac{a}{p^k} \right) = \left( \frac{a}{p} \right)^{k}</script><p>其中 $\left( \frac{a}{p} \right)$ 是勒让德符号。</p><p>雅可比符号可以看作是勒让德符号的推广。对于一个整数 $a$ 和一个正整数 $n = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m}$，雅可比符号定义如下：</p><script type="math/tex; mode=display">\left( \frac{a}{n} \right) = \prod_{i=1}^{m} \left( \frac{a}{p_i} \right)^{k_i}</script><p>雅可比符号具有以下性质：</p><ol><li>$\left( \frac{a}{n} \right) = \left( \frac{a}{p_1} \right) \left( \frac{a}{p_2} \right) \cdots \left( \frac{a}{p_m} \right)$</li><li>$\left( \frac{ab}{n} \right) = \left( \frac{a}{n} \right) \left( \frac{b}{n} \right)$</li><li>二次互反律推广：对于两个正整数 $m$ 和 $n$，如果 $\gcd(m, n) = 1$，则 $\left( \frac{m}{n} \right) = (-1)^{\frac{(m-1)}{2} \cdot \frac{(n-1)}{2}} \left( \frac{n}{m} \right)$。</li></ol><p>注意，雅可比符号的值为 $-1$ 并不一定意味着 $a$ 是模 $n$ 的二次非剩余，因为 $n$ 可能不是素数。因此，雅可比符号只能提供一个必要条件，而不是充分条件。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学数学基础 - 二次剩余</title>
      <link href="/myblog.github.io/post/1003.html"/>
      <url>/myblog.github.io/post/1003.html</url>
      
        <content type="html"><![CDATA[<p>在前两章中，我们已经掌握了整数关系和同余关系的基本概念，这些工具为我们理解数字之间的关系奠定了基础。而在本章中，我们将进入一个更深层次的领域：二次剩余。</p><p>本章存在大量定理和证明，虽然有些定理的证明可能比较复杂，但我们会尽量用通俗易懂的语言来解释这些概念。😎</p><h2><span id="剩余类与欧拉函数">剩余类与欧拉函数 🧐</span></h2><p>剩余类是指在模运算下具有相同余数的整数集合，我们用$Z_n$表示这个集合。<br>对于一个模数 $n$，剩余类可以表示为 ${[0], [1], [2], \ldots, [n-1]}$，每个整数都属于其中一个剩余类。<br>定义$Z^*_n = {a \in Z_n | \gcd(a,n) = 1}$，即在模 $n$ 下与 $n$ 互质的剩余类集合。</p><p>欧拉函数 $\phi(n)$ 是指在模 $n$ 下与 $n$ 互质的整数的数量，即$Z^*_n$的元素个数。<br>对于一个正整数 $n$，如果 $n$ 的质因数分解为 $n = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m} = n_1 n_2 \cdots n_m$，其中 $p_i$ 是 $n$ 的不同质因数，$k_i$ 是对应的正整数（实际上这里对应算数基本定理，但是这证明比较复杂且没必要，所以略😝）</p><p>欧拉函数 $\phi(n)$ 有三个性质：</p><ol><li><p>$ \phi(n) = \prod_{i=1}^{m} \phi(n_i) $</p></li><li><p>$ \phi(p^k) = p^{k-1}(p-1) $</p></li><li><p>$ \phi(p) = p - 1 $</p></li></ol><p>那么欧拉函数可以通过以下公式①计算：</p><script type="math/tex; mode=display">\phi(n) = p_1^{k_1 - 1} (p_1 - 1) \cdot p_2^{k_2 - 1} (p_2 - 1) \cdots p_m^{k_m - 1} (p_m - 1)</script><h2><span id="欧拉定理与费马小定理">欧拉定理与费马小定理 😜</span></h2><p>乘法阶是指在模 $n$ 下，一个整数 $a \in Z^*_n$ 的最小的正整数 $k$，使得 $a^k \equiv 1 \mod n$ ,那么在模 $n$ 下，${a^0, a^1, a^2, \ldots\, a^{k-1}}$ 是一个循环序列且每个元素都不相同，直到 $a^k \equiv 1 \mod n$ 时才会回到起点。</p><p>所以，对于 $i$, $j$, 如果 $i \equiv j \mod k$，则 $a^i \equiv a^j \mod n$。反之，如果 $a^i \equiv a^j \mod n$，则 $i \equiv j \mod k$。</p><p>欧拉定理②是设 $a \in Z^*_n$，则 <script type="math/tex">a^{\phi(n)} \equiv 1 \mod n</script> 且 $k \mid \phi(n)$, 其中 $k$ 是 $a$ 的乘法阶。</p><p>小费马定理和欧拉定理的关系强相关，当 $n$ 是质数 $p$ 时，$Z^*_p$ 中的每个元素都是与 $p$ 互质的，因此 $\phi(p) = p - 1$。<br>所以欧拉定理在 $n$ 是质数时就变成了小费马定理，即对于任何整数 $a$，如果 $p \nmid a$，则 <script type="math/tex">a^{p-1} \equiv 1 \mod p</script></p><h2><span id="二次剩余与勒让德符号">二次剩余与勒让德符号 😵‍💫</span></h2><p>二次剩余是指在模 $p$ 下，存在一个整数 $x$ 使得 $x^2 \equiv a \mod p$，则称 $a$ 是模 $p$ 的二次剩余。否则，称 $a$ 是模 $p$ 的二次非剩余。</p><p>如何判断一个数是否是模 $p$ 的二次剩余呢？如果恰好是完全平方数，那么它就是二次剩余。比如，$2^2 \equiv 4 \mod 7$。但是不是所有都恰好是完全平方数，但这并不代表这不是二次剩余，比如，$3^2 \equiv 2 \mod 7$，所以 $2$ 是模 $7$ 的二次剩余。所以有时候我们需要更一般的方法来判断一个数是否是二次剩余。</p><p>欧拉准则提供了一个判断二次剩余的工具：设 $p$ 是一个奇素数，$a$ 是一个整数，如果 $p \nmid a$，则</p><script type="math/tex; mode=display">a^{\frac{p-1}{2}} \equiv \begin{cases}1 \mod p & a \text{ 是模 } p \text{ 的二次剩余} \\-1 \mod p & a \text{ 是模 } p \text{ 的二次非剩余}\end{cases}</script><p>注：欧拉准则的证明比较麻烦（尤其是-1的证明），这里不展开讲解了，不要试图挑战数学百年的积累😝</p><p>为了更方便地表示一个数是否是模 $p$ 的二次剩余，我们引入了勒让德符号（Legendre symbol）。对于一个整数 $a$ 和一个奇素数 $p$，勒让德符号定义如下：</p><script type="math/tex; mode=display">\left( \frac{a}{p} \right) = \begin{cases}0 & \text{如果 } p \mid a \\1 & \text{如果 } a \text{ 是模 } p \text{ 的二次剩余} \\-1 & \text{如果 } a \text{ 是模 } p \text{ 的二次非剩余}\end{cases}</script><p>其本质就可以理解为 $a^{\frac{p-1}{2}}$，勒让德符号具有以下性质：</p><ol><li>$\left( \frac{ab}{p} \right) = \left( \frac{a}{p} \right) \left( \frac{b}{p} \right)$</li><li>$\left( \frac{a^2}{p} \right) = 1$，对于任何整数 $a$。</li><li>$\left( \frac{-1}{p} \right) = (-1)^{\frac{p-1}{2}}$，这意味着当 $p \equiv 1 \mod 4$ 时，$-1$ 是模 $p$ 的二次剩余；当 $p \equiv 3 \mod 4$ 时，$-1$ 是模 $p$ 的二次非剩余。</li><li>二次互反律：对于两个奇素数 $p$ 和 $q$，有 $\left( \frac{p}{q} \right) = (-1)^{\frac{(p-1)}{2} \cdot \frac{(q-1)}{2}} \left( \frac{q}{p} \right)$<br>（二次互反律的证明比较复杂，这里不展开讲解了，学会与自己和解😏）</li></ol><p>我们发现 $-1$ 的二次剩余性与 $p$ 的模 $4$ 的结果有关，这也是一个非常有趣的现象。<br>判断 $-1$ 是否是模 $p$ 的二次剩余，可以通过计算 $p \mod 4$ 来确定：</p><ul><li>如果 $p \equiv 1 \mod 4$，则 $-1$ 是模 $p$ 的二次剩余。</li><li>如果 $p \equiv 3 \mod 4$，则 $-1$ 是模 $p$ 的二次非剩余。</li></ul><p>由此，当 $p$ 是形如 $4k+1$ 的素数时，我们有简单的方法构造平方根<br>设 $p \equiv 1 \mod 4$，$ b^2 \equiv -1 \mod p$，$ c$是一个二次非剩余，则</p><script type="math/tex; mode=display">b^2 \equiv (c^{\frac{p-1}{4}})^2 \equiv c^{\frac{p-1}{2}} \equiv -1 \mod p</script><p>所以 $b \equiv c^{\frac{p-1}{4}} \mod p$ 就是 $-1$ 的一个平方根，另一个为 $-b \mod p$。</p><p>如何求解一个数 $a$ 的平方根呢？<br>如果 $p \equiv 3 \mod 4$，则 $a^{\frac{p+1}{4}}$ 就是 $a$ 的一个平方根③。<br>如果 $p \equiv 1 \mod 4$，则可以使用 Tonelli-Shanks 算法来求解 $a$ 的平方根，这个算法比较复杂，这里不展开讲解了。</p><p>最后，补充一个费马平方和定理：一个素数 $p$ 可以表示为两个整数的平方和（即 $p = x^2 + y^2$）当且仅当 $p \equiv 1 \mod 4$。<br>关于这个定理的证明，费马当年没能证明，后来欧拉花了几年才一点点完成，放过自己吧。👻</p><h2><span id="结论123证明">结论①②③证明 😡</span></h2><h3><span id="结论1证明">结论①证明 😭</span></h3><p>我们看 $p^k$ 的情况，设 $p$ 是一个奇素数，$k \geq 1$，则 $Z_{p^k} = {0, 1, 2, \ldots, p^k - 1}$ 共有 $p^k$ 个元素。</p><p>其中与 $p^k$ 不互质的元素有 ${0, p, 2p, \ldots, (p^{k-1} - 1)p}$，共 $p^{k-1}$ 个。</p><p>因此，与 $p^k$ 互质的元素数量为：$p^k - p^{k-1} = p^{k-1}(p - 1)$。<br>则 $\phi(p^k) = p^{k-1}(p - 1)$。</p><p>设 $n = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m}$，其中 $p_i$ 是 $n$ 的不同质因数，$k_i$ 是对应的正整数。<br>根据欧拉函数的定义，我们有：</p><script type="math/tex; mode=display">\phi(n) = \#\{a \in Z_n | \gcd(a, n) = 1\}</script><p>即欧拉函数等于在模 $n$ 下与 $n$ 互质的整数的数量。</p><p>由于 $n$ 的质因数分解，我们可以将 $Z<em>n$ 分解为 $Z</em>{p<em>1^{k_1}} \times Z</em>{p<em>2^{k_2}} \times \cdots \times Z</em>{p_m^{k_m}}$。</p><p>根据中国剩余定理，$Z<em>n$ 中与 $n$ 互质的元素数量等于 $Z</em>{p<em>1^{k_1}}$ 中与 $p_1^{k_1}$ 互质的元素数量乘以 $Z</em>{p_2^{k_2}}$ 中与 $p_2^{k_2}$ 互质的元素数量，依此类推。</p><p>因此，我们有：</p><script type="math/tex; mode=display">\phi(n) = \prod_{i=1}^{m} \phi(p_i^{k_i})</script><h3><span id="结论2证明">结论②证明 🥱</span></h3><p>$Z^<em>_n$ 中的整数彼此不同，每个整数乘以 $a$ 后得到的结果也彼此不同而且在 $Z^</em>_n$ 中。所以，乘以 $a$ 后所得的集合不变，都是 $Z^<em>_n$。<br>例如：<br>| $\mathbb{Z}_7^</em>$ | 1 | 2 | 3 | 4 | 5 | 6 |<br>|—————————|—-|—-|—-|—-|—-|—-|<br>| $a=2$            | 2 | 4 | 6 | 1 | 3 | 5 |</p><p>现在我们把 $Z^*_n$ 中的整数乘起来，再把乘以 $a$ 后的整数也乘起来，得到：</p><script type="math/tex; mode=display">\prod_{b \in Z^*_n} b = \prod_{b \in Z^*_n} ab \mod n</script><p>因为 $Z^*_n$ 中有 $\phi(n)$ 个元素，所以我们可以把 $a$ 提出来，得到：</p><script type="math/tex; mode=display">\prod_{b \in Z^*_n} b = a^{\phi(n)} \prod_{b \in Z^*_n} b \mod n</script><p>由于 $\prod<em>{b \in Z^*_n} b$ 在模 $n$ 下是可逆的，我们可以两边同时除以 $\prod</em>{b \in Z^*_n} b$，得到：</p><script type="math/tex; mode=display">a^{\phi(n)} \equiv 1 \mod n</script><h3><span id="结论3证明">结论③证明 🥶</span></h3><p>设 $p \equiv 3 \mod 4$，则 $p = 4k + 3$，其中 $k$ 是一个非负整数， $a$ 是模 $p$ 下的二次剩余。</p><p>根据费马小定理，我们有：</p><script type="math/tex; mode=display">a^{\phi(p)} \equiv a^{p-1} \equiv 1 \mod p</script><p>因为 $p \equiv 3 \mod 4$，所以 $p-1 = 4k + 2$，因此：</p><script type="math/tex; mode=display">a^{4k + 2} \equiv 1 \mod p</script><p>将上式两边同时乘以 $a$，得到：</p><script type="math/tex; mode=display">a^{4k + 3} \equiv a \mod p</script><p>注意到 $\frac{p+1}{4} = \frac{4k + 3 + 1}{4} = k + 1$，所以</p><script type="math/tex; mode=display">{a^{\frac{p+1}{4}}}^2 = {a^{k + 1}}^2 = a^{2k + 2} \mod p</script><p>由欧拉准则，$a^{2k + 1} \equiv 1 \mod p$，所以 $a^{2k + 2} \equiv a \mod p$。因此，$a^{\frac{p+1}{4}}$ 是 $a$ 的一个平方根。</p><p>上一章：<a href="https://lr2006-robot.github.io/myblog.github.io/post/1002.html">密码学数学基础 - 同余关系与模运算</a> 👈<br>下一章：<a href="https://lr2006-robot.github.io/myblog.github.io/post/1004.html">密码学数学基础 - 扩展二次剩余</a> 👈</p><script type="math/tex; mode=display">Shouldve \ said \ I \ do \ believe \ it \ was \ cool \ to \ be \ the \ one \ that \ got \ a \ chance \ to \ show.</script>]]></content>
      
      
      <categories>
          
          <category> 密码学数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学数学基础 - 同余关系与模运算</title>
      <link href="/myblog.github.io/post/1002.html"/>
      <url>/myblog.github.io/post/1002.html</url>
      
        <content type="html"><![CDATA[<p>在上一章中，我们探讨了整数关系的基本概念，这些工具为我们理解数字之间的关系奠定了基础。而在本章中，我们将进入一个更深层次的领域：同余关系与模运算。这些概念不仅是数论中的重要内容，也是密码学中不可或缺的工具。</p><p>同余关系和模运算为我们提供了一种新的视角来看待整数之间的关系。它们让我们能够在一个有限的范围内进行计算，这对于设计和分析加密算法来说至关重要。无论是经典的凯撒密码，还是现代的 RSA 加密算法，同余关系和模运算都在其中扮演着重要的角色。</p><p>这个章节初步认识模这个重要概念，一定要跟上哦~~~🚀</p><h2><span id="模运算与同余关系">模运算与同余关系 🥰</span></h2><p>模运算是一种数学运算，它将一个数除以另一个数，并返回余数。我们用符号 $mod$ 来表示模运算。设$a=bq+r$，其中 $r$ 是余数，那么我们说 $a \equiv r \mod b$。例如，$7 \mod 3$ 的结果是 $1$，因为 $7$ 除以 $3$ 的商是 $2$，余数是 $1$。</p><p>可以看出，模和整除是密切相关的。模运算可以看作是整除的一种扩展，它不仅告诉我们一个数是否能被另一个数整除，还告诉我们在不能整除的情况下，余数是什么。因此，模运算将整数映射到一个有限的范围内，这个范围由模数决定。模为数 $n$ 定义了一个整数集合 ${0, 1, 2, \ldots, n-1}$，在这个集合中进行的运算称为模运算。</p><p>特殊的，负数的模运算结果也可以通过添加模数来得到。例如，$-1 \mod 3$ 的结果是 $2$，因为 $-1 + 3 = 2$。</p><p>同余关系是指两个整数在模运算下具有相同的余数。我们用符号 $\equiv$ 来表示同余关系。例如，$7 \equiv 1 \mod 3$，因为 $7$ 和 $1$ 在模 $3$ 下具有相同的余数。</p><p>同余关系具有一些重要的性质：</p><ol><li>反身性：对于任何整数 $a$，都有 $a \equiv a \mod n$</li><li>对称性：如果 $a \equiv b \mod n$，则 $b \equiv a \mod n$。</li><li>传递性：如果 $a \equiv b \mod n$ 且 $b \equiv c \mod n$，则 $a \equiv c \mod n$</li><li>加法：如果 $a \equiv b \mod n$ 和 $c \equiv d \mod n$，则 $a \pm c \equiv b \pm d \mod n$</li><li>乘法：如果 $a \equiv b \mod n$ 和 $c \equiv d \mod n$，则 $ac \equiv bd \mod n$</li><li>指数：如果 $a \equiv b \mod n$，则对于任何非负整数 $k$，都有 $a^k \equiv b^k \mod n$</li></ol><h2><span id="逆元模反元素">逆元（模反元素） 😗</span></h2><p>在模运算中，逆元（也称为模反元素）是指对于一个整数 $a$ 和一个模数 $n$，如果存在一个整数 $x$ 使得 $ax \equiv 1 \mod n$，那么我们称 $x$ 是 $a$ 的逆元，记作 $a^{-1} \mod n$。换句话说，逆元是一个数，使得它与原数的乘积在模运算下等于 1，在范围 $0$ 到 $n-1$ 之间是唯一的。</p><p>我们可以使用扩展欧几里得算法计算逆元$x$。$ax \equiv 1 \mod n$ 可以写作 ax = 1 + kn ，其中k是某个整数。根据裴蜀定理，存在整数x和y使得 ax + ny = 1 。因此，x就是a的逆元。</p><p>需要注意的是，并不是所有的整数都存在逆元。只有当 $a$ 和 $n$ 互质时，$a$ 才有逆元。这是因为如果 $a$ 和 $n$ 有公共因数，那么 $ax$ 将无法等于 1。</p><h2><span id="消去律与一次同余方程">消去律与一次同余方程 🙃</span></h2><p>消去律①是指在模运算中，如果 $ac \equiv bc \mod n$ 且 $\gcd(c,n) = g$，那么可以消去 $c$，得到 $a \equiv b \mod \frac{n}{g}$。这个性质在解一次同余方程时非常有用。</p><p>一次同余方程的形式是 $ax \equiv b \mod n$。如果 $\gcd(a,b) = 1$，那么该方程有唯一解。解法是先求出 $a$ 的逆元 $a^{-1}$，然后将方程两边同时乘以 $a^{-1}$，得到 $x \equiv a^{-1}b \mod n$。</p><p>如果 $\gcd(a,b) = c &gt; 1$, $\gcd(c,n) = g &gt; 1$, 我们使用消去律将方程简化为 $a’x \equiv b’ \mod n’$，其中 $a’ = \frac{a}{c}$, $b’ = \frac{b}{c}$, $n’ = \frac{n}{g}$。然后求出 $a’$ 的逆元 $a’^{-1}$，最后得到 $x \equiv a’^{-1}b’ \mod n’$。</p><p>总而言之，先用消去律将方程简化为 $a’x \equiv b’ \mod n’$，然后求出 $a’$ 的逆元 $a’^{-1}$，最后得到 $x \equiv a’^{-1}b’ \mod n’$。</p><h2><span id="一次同余方程组与中国剩余定理">一次同余方程组与中国剩余定理 🥳</span></h2><p>如果我们有多个同余方程需要同时满足，那么我们就需要使用中国剩余定理（Chinese Remainder Theorem）②来求解。一次同余方程组的形式是：<br>$\begin{cases}<br>x \equiv a_1 \mod n_1 \<br>x \equiv a_2 \mod n_2 \<br>\vdots \<br>x \equiv a_m \mod n_m<br>\end{cases}$</p><p>中国剩余定理告诉我们，如果 $n_1, n_2, \ldots, n_m$ 互质，那么这个同余方程组有唯一解，并且可以通过以下步骤来求解：</p><ol><li>计算 $N = \prod_{i=1}^{m} n_i$。</li><li>对于每个 $i$，计算 $M_i = \frac{N}{n_i}$。</li><li>对于每个 $i$，计算 $M^{-1}_i$，使得 $M_i M^{-1}_i \equiv 1 \mod n_i$。</li><li>最后，解 $x$ 可以通过以下公式计算：<br>$ x = \sum_{i=1}^{m} a_i M_i M^{-1}_i \mod N $</li></ol><p>实际上，求解一次同余方程也可以用CRT（中国剩余定理）来解决，以达到当模数较大时简化计算的目的。只需要将模数n分解成互质的因数，然后将原方程转化为多个同余方程，最后使用CRT来求解即可。</p><h2><span id="结论12证明">结论①②证明 😨</span></h2><p>本章节的定理和算法虽然比较基础，但我们来简单证明一下吧。（一定不是因为CRT比较重要和常用🤪）</p><h3><span id="结论1证明">结论①证明 🤐</span></h3><p>设 $g = \gcd(c, n)$，则 $c = g c’$ 和 $n = g n’$，其中 $\gcd(c’, n’) = 1$。</p><p>因为 $ac \equiv bc \mod n$，所以 $g(ac’ - bc’) \equiv 0 \mod gn’$，即 $ac’ - bc’ \equiv 0 \mod n’$。</p><p>由于 $\gcd(c’, n’) = 1$，所以可以消去 $c’$，得到 $a \equiv b \mod n’$。</p><h3><span id="结论2证明">结论②证明 💀</span></h3><p>设 $N = \prod_{i=1}^{m} n_i$。</p><p>构造</p><script type="math/tex; mode=display">n^*_1 = \frac{N}{n_1}, \ n^*_2 = \frac{N}{n_2}, \ \ldots, \ n^*_m = \frac{N}{n_m}</script><p>模数 $n_i$ 与 $n^*_i$ 互质，因此存在逆元 $t_i$ 使得</p><script type="math/tex; mode=display">t_1 n^*_1 \equiv 1 \mod n_1, \ t_2 n^*_2 \equiv 1 \mod n_2, \ \ldots, \ t_m n^*_m \equiv 1 \mod n_m</script><p>我们发现</p><script type="math/tex; mode=display">e_i = t_i n_i^* \equiv\begin{cases}1 \pmod{n_i} \\0 \pmod{n_j}, & j \neq i\end{cases}</script><p>用 $e_i$ 乘以 $a_i$，然后将它们相加，我们得到方程的一个解</p><script type="math/tex; mode=display">x = \sum_{i=1}^{m} a_i e_i \equiv \sum_{i=1}^{m} a_i t_i n^*_i \mod N</script><p>因为 $x$ 里所包含的那些下标不等于 $i$ 的单项式因为 $e$ 的性质而在模 $n_i$ 下为 $0$，只留下下标等于 $i$ 的单项式 $a_i t_i n^<em>_i$，而 $t_i n^</em>_i \equiv 1 \mod n_i$，所以 $x \equiv a_i \mod n_i$。</p><p>上一章：<a href="https://lr2006-robot.github.io/myblog.github.io/post/1001.html">密码学数学基础 - 整数关系</a> 👈<br>下一章：<a href="https://lr2006-robot.github.io/myblog.github.io/post/1003.html">密码学数学基础 - 二次剩余</a> 👈</p><script type="math/tex; mode=display">Bout \ to \ say \ goobye, \ bout \ to \ give \ up, \ until \ I \ met \ you, \ Mari, \ I \ can't \ control.</script>]]></content>
      
      
      <categories>
          
          <category> 密码学数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学数学基础 - 整数关系</title>
      <link href="/myblog.github.io/post/1001.html"/>
      <url>/myblog.github.io/post/1001.html</url>
      
        <content type="html"><![CDATA[<p>在我们踏上密码学数学基础的冒险之旅后，第一站就是整数关系的世界。这个领域虽然看似简单，但却是构建整个密码学大厦的基石。无论是最基本的整除关系，还是更复杂的同余关系，它们都在为我们揭示数字之间的神秘联系。</p><p>本章将带你深入了解整数关系的核心概念，包括整除、素数、最大公约数和最小公倍数等。我们将通过生动的例子和直观的解释，帮助你掌握这些基本工具，为后续的密码学学习打下坚实的基础。</p><p>别看我说的很高大上，放轻松，这一章真的非常简单口牙。😁</p><h2><span id="整除关系与素数">整除关系与素数 😋</span></h2><p>在整数的世界里，整除关系是最基本的关系之一。我们说一个整数 $ a $ 整除另一个整数 $ b $，记作 $ a \mid b $，如果存在一个整数 $ k $ 使得 $ b = ak $。换句话说，$ b $ 可以被 $ a $ 整除，没有余数。例如，$ 3 \mid 12 $ 因为 $ 12 = 3 \times 4 $，但 $ 5 \nmid 12 $ 因为 $ 12 $ 不能被 $ 5 $ 整除。</p><p>素数是大于 1 的整数，除了 1 和它本身之外没有其他正整数因数。素数在密码学中扮演着重要的角色，因为许多加密算法都依赖于大素数的性质。例如，RSA 加密算法就是基于两个大素数的乘积来实现安全性的。</p><h2><span id="最大公约数与最小公倍数">最大公约数与最小公倍数 😛</span></h2><p>最大公约数（GCD）是指两个或多个整数的公共约数中最大的一个。比如，$ \text{gcd}(12, 15) = 3 $，因为 3 是 12 和 15 的最大公共约数。</p><p>最小公倍数（LCM）则是指两个或多个整数的公共倍数中最小的一个。例如，$ \text{lcm}(4, 6) = 12 $，因为 12 是 4 和 6 的最小公共倍数。</p><h3><span id="如何求解最大公约数与最小公倍数">如何求解最大公约数与最小公倍数 🤨</span></h3><p>计算最大公约数的一种高效方法是辗转相除法（Euclidean Algorithm）。<br>这个算法基于一个重要的性质①：对于两个整数 $ a $ 和 $ b $，如果 $ a &gt; b $，那么</p><script type="math/tex; mode=display">\text{gcd}(a, b) = \text{gcd}(b, a \mod b)</script><p>通过不断地将较大的数替换为较小的数和它们的余数，我们可以快速找到最大公约数。</p><p>再根据最大公约数和最小公倍数的性质②：</p><script type="math/tex; mode=display">\text{lcm}(a, b) = \frac{|a \times b|}{\text{gcd}(a, b)}</script><p>求出最小公倍数。</p><h2><span id="裴蜀定理与扩展欧几里得算法">裴蜀定理与扩展欧几里得算法 🥰</span></h2><p>裴蜀定理（Bézout’s Identity）是整数关系中的一个重要定理，它告诉我们对于任意两个整数 $ a $ 和 $ b $，存在整数 $ x $ 和 $ y $，使得性质③：</p><script type="math/tex; mode=display">ax + by = \text{gcd}(a, b)</script><p>扩展欧几里得算法（Extended Euclidean Algorithm）就是基于裴蜀定理的一种算法，它不仅可以计算最大公约数，还可以找到满足裴蜀定理的整数 $ x $ 和 $ y $。</p><h2><span id="结论123证明">结论①②③证明 🤓👆</span></h2><p>由于本章节的定理和算法都比较基础，我们来简单证明一下吧。</p><h3><span id="结论1证明">结论①证明 😑</span></h3><h4><span id="带余除法分解">带余除法分解</span></h4><p>假设 $ a = bq + r $，其中 $ q $ 是商，$ r $ 是余数，且 $ 0 \leq r &lt; b $。我们记$ r $为 $ a \mod b $。</p><h4><span id="证明gcdab是b和r的公约数">证明$gcd(a,b)$是$b$和$r$的公约数</span></h4><p>设 $ d = \text{gcd}(a, b) $，则 $ d \mid a $ 和 $ d \mid b $。<br>因为 $ d $ 整除 $ a $ 和 $ bq $，$ d $ 也必须整除 $ r = a - bq $，即 $ d \mid r $。<br>所以，$ d $ 是 $ b $ 和 $ r $ 的公因数，那么一定小于等于最大公因数$ \text{gcd}(b, r) $，故 $ \text{gcd}(a, b) \leq \text{gcd}(b, r) $。</p><h4><span id="证明gcdbr是a和b的公约数">证明$gcd(b,r)$是$a$和$b$的公约数</span></h4><p>设 $ d’ = \text{gcd}(b, r) $，则 $ d’ \mid b $ 和 $ d’ \mid r $。<br>因为 $ d’ $ 整除 $ b $ 和 $ r $，$ d’ $ 也必须整除 $ a = bq + r $，即 $ d’ \mid a $。<br>所以，$ d’ $ 是 $ a $ 和 $ b $ 的公因数，那么一定小于等于最大公因数$ \text{gcd}(a, b) $，故 $ \text{gcd}(b, r) \leq \text{gcd}(a, b) $。</p><h4><span id="总结">总结</span></h4><p>综上所述，$ \text{gcd}(a, b) = \text{gcd}(b, r) $，证明完毕。</p><h3><span id="结论2证明">结论②证明 😪</span></h3><p>设 $ d = \text{gcd}(a, b) $，则 $ a = da’ $ 和 $ b = db’ $，其中 $ a’ $ 和 $ b’ $ 是互质的整数。</p><p>因此，$ \text{lcm}(a, b) = d \times a’ \times b’ = \frac{|da’ \times db’|}{d} = \frac{|a \times b|}{\text{gcd}(a, b)} $，证明完毕。</p><h3><span id="结论3证明">结论③证明 😨</span></h3><h4><span id="欧几里得算法辗转相除法">欧几里得算法（辗转相除法）</span></h4><p>设 $ d = \text{gcd}(a, b) $。<br>用辗转相除法：</p><script type="math/tex; mode=display">a = bq_1 + r_1 ， 0 < r_1 < b</script><script type="math/tex; mode=display">b = r_1q_2 + r_2 ， 0 < r_2 < r_1</script><p>不断进行下去，直到余数为 0：</p><script type="math/tex; mode=display">r_{n-2} = r_{n-1}q_n + r_n ， 0 < r_n < r_{n-1}</script><script type="math/tex; mode=display">r_{n-1} = r_nq_{n+1} + 0 ， r_n = d</script><p>最后余数为 0，说明 $ r_n = d = \text{gcd}(a, b) $。</p><h4><span id="反向替换求解-x-和-y">反向替换求解 $ x $ 和 $ y $</span></h4><p>倒数第二步：</p><script type="math/tex; mode=display">d = r_n = r_{n-2} - r_{n-1}q_n</script><p>再把$r_{n-1}$用上一行表示：</p><script type="math/tex; mode=display">r_{n-1} = r_{n-3} - r_{n-2}q_{n-1}</script><p>带入：</p><script type="math/tex; mode=display">d = A·r_{n-2} + B·r_{n-3},   A ,B  \in \mathbb{Z}</script><p>一直往上带入，最终可以表示为：<br>$d = x·a + y·b$，其中 $ x, y \in \mathbb{Z} $，证明完毕。</p><p>上一章：<a href="http://lr2006-robot.github.io/myblog.github.io/post/1000.html">密码学数学基础 - 前言</a> 👈<br>下一章：<a href="http://lr2006-robot.github.io/myblog.github.io/post/1002.html">密码学数学基础 - 同余关系与模运算</a> 👈</p><script type="math/tex; mode=display">When \ I \ thought \ my \ fault \ that \ caused \ all \ the \ title \ to \ go</script><script type="math/tex; mode=display">is \ only \ cuz \ I \ always \ move \ way \ to \ slow.</script>]]></content>
      
      
      <categories>
          
          <category> 密码学数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学数学基础 - 前言</title>
      <link href="/myblog.github.io/post/1000.html"/>
      <url>/myblog.github.io/post/1000.html</url>
      
        <content type="html"><![CDATA[<p>你有没有想过，当你在深夜网购🛒、和朋友发私密消息💬、或是登录银行账户🏦时，那些看似 “坚不可摧” 的安全屏障🔒，背后其实是一群数学精灵🧚在默默守护？✨<br>欢迎来到《密码学数学基础》的奇妙世界！这里没有枯燥的公式堆砌（真的假的😋），只有一把把打开信息安全大门的钥匙🗝️。<br>在信息安全的宇宙🌌里，密码学就像是一位神秘的魔法师🧙，而数学则是它手中的魔法棒🪄。本系列文章将带你解锁密码学中最核心的数学知识，特别是数论和代数这两大 “护法”🛡️。从最基础的整除、同余，到高深莫测的群论、环论和域论，我们会一步步揭开这些数学工具的神秘面纱🎭。<br>别担心，我会用轻松有趣的方式（🤣👉🤡），让你发现这些看似高冷的数学概念，其实是设计和分析加密算法与协议的基石🧱。它们不仅是密码学的 “幕后英雄”🦸，还在编码理论、计算复杂性等领域大放异彩🌟。<br>想象一下：<br>当你用 HTTPS 浏览网页时🌐，大素数的乘积正在帮你抵御窃听👂；<br>当你用数字签名确认身份时✍️，椭圆曲线的点运算正在为你保驾护航🚢；<br>当区块链上的交易被永久记录时⛓️，哈希函数的单向性正在守护数据的不可篡改性📜。<br>这些听起来高大上的技术，本质上都是数学规律的巧妙应用🎯。<br>在这个系列里，我们会像侦探🕵️一样，拆解每一个加密算法背后的数学逻辑；像探险家🗺️一样，从最基础的数论概念出发，逐步深入到更复杂的数学工具。你会发现，原来那些让你头疼的抽象概念，其实是构建安全世界的砖瓦🧱；那些看似枯燥的定理，其实是守护数字生活的盾牌🛡️。<br>当然，我们主要用于密码学学习，故而我会将重点放在结论和应用上，而不是过多地纠结于太难的证明和特殊情况（毕竟我们不是数学家😎）。但如果你对某些定理的证明感兴趣，我也会提供一些参考资料，供你深入探索🔍。<br>准备好了吗？让我们一起踏上这场充满挑战与惊喜的数学冒险🚀，解锁信息安全的终极奥义吧！💡</p><p>注：本系列文章编号从 1000 开始，后续章节将依次递增。每篇文章都会在结尾提供下一章的链接，敬请期待！😉<br>回到开始：<a href="http://lr2006-robot.github.io/myblog.github.io/about/">关于我</a> 👈<br>下一章：<a href="http://lr2006-robot.github.io/myblog.github.io/post/1001.html">密码学数学基础 - 整数关系</a> 👈</p>]]></content>
      
      
      <categories>
          
          <category> 密码学数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/myblog.github.io/manifest.json"/>
      <url>/myblog.github.io/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"Alice and Bodの神秘小屋","short_name":"密码博客","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/256.png","sizes":"256x256","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/myblog.github.io/tags/index.html"/>
      <url>/myblog.github.io/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/myblog.github.io/css/custom.css"/>
      <url>/myblog.github.io/css/custom.css</url>
      
        <content type="html"><![CDATA[@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://cdn.cbd.int/anzhiyu-blog@latest/fonts/ZhuZiAYuanJWD.woff2);    font-display: swap;    font-weight: lighter;}@import url(https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap);/* 字体样式 */div#menu {    font-family: 'ZCOOL KuaiLe', cursive;}h1#site-title {    font-family: 'ZCOOL KuaiLe', cursive;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title{    font-family: 'ZCOOL KuaiLe', cursive;}/* 图标样式 */.iconfont{    font-family: 'iconfont' !important;    font-size: 3em;    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}svg.icon{    width: 1em;    height: 1em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before{    color:#f7c768;}/* bilibli番剧插件 */.bangumi-active{    background:#dbecfe !important;    border-radius:10px !important;}a.bangumi-tab:hover{    text-decoration:none !important;}.bangumi-button:hover{    background:#dbecfe !important;    border-radius:10px !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration:none !important;}.bangumi-button{    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size:1.1em;}/* 解决artitalk的图标问题 */#uploadSource > svg {    width:1.19em;    height:1.5em;}   /* 移除头图黑色透明玻璃效果 */#page-header:not(.not-top-img):before{    background-color: transparent !important;}/* 核心：透明化配置（修复rgba语法错误） *//* 首页文章卡片 */#recent-posts >.recent-post-item {    background:rgba(255,255,255,0.1) !important;}/* 首页侧栏卡片 */#aside-content .card-widget {    background:rgba(255, 255, 255,0.1) !important;}/* 文章页面正文背景 */div#post {    background:rgba(255,255,255,0.1) !important;}/* 分页页面 */div#page {    background:rgba(255, 255, 255,0.1) !important;}/* 归档页面 */div#archive {    background:rgba(255, 255, 255,0.1) !important;}/* 标签页面 */div#tag {    background:rgba(255, 255, 255,0.1) !important;}/* 分类页面 */div#category {    background:rgba(255, 255, 255,0.1) !important;}/* 夜间模式伪类遮罩层透明 */[data-theme='dark'] #recent-posts >.recent-post-item {    background: #121212 !important;}[data-theme='dark'] .card-widget {    background: #121212 !important;}[data-theme='dark'] div#post {    background: #121212 !important;}[data-theme='dark'] div#tag {    background:#121212 !important;}[data-theme='dark'] div#archive {    background:#121212 !important;}   [data-theme='dark'] div#page {    background: #121212 !important;}[data-theme='dark'] div#category {    background: transparent !important;}/* 核心：头部+尾部完全透明（提升选择器优先级） */#footer {    background: transparent !important;}#page-header,#page-header #site-banner {    background: transparent !important;    background-color: transparent !important;}#rightside > div > button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width:10px;    height:10px;}::-webkit-scrollbar-thumb {    background-color:#49b1f5;    border-radius:20px;}::-webkit-scrollbar-corner { /* 修复选择器拼写错误 */    background-color: transparent;}::selection{ /* 修复火狐/Chrome兼容 */    color:#fff;    background-color:#49b1f5;}/* 音乐播放器 */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body { /* 修复拼写错误 aplayer-bodyy */    left:-66px !important;    transition: all 0.3s;}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{    left:0 !important;    transition: all 0.3s;}.aplayer.aplayer-fixed {    z-index: 9999999 !important;}/* 评论框 */.vwrap{    box-shadow: 2px 2px 5px#bbb;    background: rgba(255, 255, 255,0.3) !important;    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}.vcard{    box-shadow:2px 2px 2px 5px#bbb;    background: rgba(255,255, 255,0.3) !important;    border-radius:8px;    padding: 30px;    margin: 30px 0px 0px 0px;   }/* md网站下划线 */#article-container a:hover {    text-decoration:none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin:0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0,-50%);}#error-wrap .error-content {        display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius:8px;    border-bottom-left-radius: 8px;    background-color: #49b1f5;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family:Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei',sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break:break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background:var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom:0px;    position: absolute;    padding: 1rem;    width:100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group{    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width:1200px;    margin:0 auto;}#body-wrap.error .aside-list .aside-list-item { padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width:100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow:hidden;    width: 230px;    height: 143px;    background: var(--heo-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;     padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/myblog.github.io/categories/index.html"/>
      <url>/myblog.github.io/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/myblog.github.io/about/index.html"/>
      <url>/myblog.github.io/about/index.html</url>
      
        <content type="html"><![CDATA[<p>🔐✨ 欢迎来到我的密码学学习小站！​</p><p>如果你对密码学感兴趣，Alice和Bob的故事一定会让你眼前一亮！😉</p><p>这里是一个专注于密码学知识分享与学习记录的角落📝—— 没有晦涩难懂的学术堆砌，也没有刻意迎合的趣味过度，只希望以平实的语言、清晰的脉络，和同样对 “数字安全”🛡️充满好奇的你，一起探索密码学的奇妙世界🌍～​</p><p>密码学的故事，远比我们想象中更悠久。它并非诞生于冰冷的计算机机房💻，而是源于人类对 “秘密” 的守护欲🔒：早在公元前 400 年，斯巴达士兵用缠绕的 “密码棒”🪢传递军事指令，文字随着布条的缠绕呈现，解开才能读懂信息📜；古罗马时期，凯撒大帝👑用 “字母移位 3 位” 的简单规则加密公文（也就是著名的凯撒密码🔤），成为最早的实用加密方案；中世纪的欧洲，外交官们用 “维吉尼亚密码”📑构建多层加密，让信息在复杂的政治博弈♟️中不被截获 —— 这些古代加密方式虽简陋，却奠定了 “隐藏信息、验证身份” 的核心逻辑✅。​</p><p>而密码学真正从 “经验技巧” 升级为 “科学体系”📚，离不开一位关键人物：克劳德・香农 👨‍🔬🎓（没错，我们不是图0派，也不是冯诺1曼派，我们是香农派😋）。1949 年，这位 “信息论之父” 发表了划时代的论文《保密系统的通信理论》📖，第一次用数学语言🧮定义了密码学的核心概念：他提出的 “完善保密性”（即攻击者无法通过密文获取任何明文信息✅）、“唯一解距离”（破解密码所需的最小密文长度📏）等理论，为加密方案的设计与安全性分析提供了严格的数学基础，让密码学彻底脱离 “玄学”，成为一门可证明、可量化的严谨学科。香农的贡献，就像为密码学搭建了坚实的地基🏗️，后续所有现代加密算法（无论是对称加密的 AES🔑，还是非对称加密的 RSA🔐），都建立在他的理论框架之上。​</p><p>进入数字时代后，密码学更是成为了我们生活的 “隐形守护者”👤！微信聊天的端到端加密💬、网上银行的支付验证🏦、区块链的签名机制⛓️、甚至是手机解锁的指纹识别👆，背后都藏着密码学的智慧。它不再是军事、外交专属的 “高端技术”⚙️，而是渗透到数字生活的每一个角落，默默守护着我们的隐私与安全🛡️。​</p><p>在这个博客里，我会记录自己的密码学学习轨迹🗺️：从基础的古典密码算法拆解🧩，到现代加密技术的原理分析💻；从香农理论的深度解读📖，到实际应用中的安全案例⚠️；从入门级的概念科普🌱，到进阶的算法实现🚀—— 每一篇内容都力求 “易懂、实用、有逻辑”。​</p><p>如果你也对 “如何给信息上锁”🔒、“如何抵御破解攻击”🛡️、“数字世界的信任如何建立”🤝等问题感兴趣，不妨和我一起启程！这里没有绝对的权威，只有持续的学习与探索🔍；欢迎在评论区交流疑问❓、分享见解💡，让我们在密码学的海洋🌊里，慢慢积累、共同进步📈～​<br>✨ 愿我们都能在学习中读懂密码学的魅力，成为数字时代的 “安全守护者”🦸‍♂️！</p><p>系列文章目录：</p><p><a href="http://lr2006-robot.github.io/myblog.github.io/post/1000.html">密码学数学基础 - 前言</a> 👈</p><p><a href="http://lr2006-robot.github.io/myblog.github.io/post/2000.html">加解密算法分析 - 前言</a> 👈</p><p><a href="http://lr2006-robot.github.io/myblog.github.io/post/3000.html">RSA算法经典考法解析 - 前言</a> 👈</p>]]></content>
      
    </entry>
    
    
  
</search>
