<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <author>
    <name>Dorange</name>
  </author>
  <generator uri="https://hexo.io/">Hexo</generator>
  <id>https://lr2006-robot.github.io/myblog.github.io/</id>
  <link href="https://lr2006-robot.github.io/myblog.github.io/" rel="alternate"/>
  <link href="https://lr2006-robot.github.io/myblog.github.io/atom.xml" rel="self"/>
  <rights>All rights reserved 2026, Dorange</rights>
  <title>Alice and Bobの神秘小屋</title>
  <updated>2026-02-20T14:42:28.303Z</updated>
  <entry>
    <author>
      <name>Dorange</name>
    </author>
    <category term="密码学数学基础" scheme="https://lr2006-robot.github.io/myblog.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <category term="密码学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <category term="数学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    <category term="数论" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    <content>
      <![CDATA[<p>在前两章中，我们已经掌握了整数关系和同余关系的基本概念，这些工具为我们理解数字之间的关系奠定了基础。而在本章中，我们将进入一个更深层次的领域：二次剩余。</p><p>本章存在大量定理和证明，虽然有些定理的证明可能比较复杂，但我们会尽量用通俗易懂的语言来解释这些概念。😎</p><p>Shouldve said I do believe it was cool to be the one that got a chance to show.</p><h2><span id="剩余类与欧拉函数">剩余类与欧拉函数</span></h2><p>剩余类是指在模运算下具有相同余数的整数集合，我们用$Z_n$表示这个集合。<br>对于一个模数 $n$，剩余类可以表示为 ${[0], [1], [2], \ldots, [n-1]}$，每个整数都属于其中一个剩余类。<br>定义$Z^*_n = {a \in Z_n | \gcd(a,n) = 1}$，即在模 $n$ 下与 $n$ 互质的剩余类集合。</p><p>欧拉函数 $\phi(n)$ 是指在模 $n$ 下与 $n$ 互质的整数的数量，即$Z^*_n$的元素个数。<br>对于一个正整数 $n$，如果 $n$ 的质因数分解为 $n = p_1^{k_1} p_2^{k_2} \cdots p_m^{k_m} = n_1 n_2 \cdots n_m$，其中 $p_i$ 是 $n$ 的不同质因数，$k_i$ 是对应的正整数（实际上这里对应算数基本定理，但是这证明比较复杂且没必要，所以略😝）</p><p>欧拉函数 $\phi(n)$ 有三个性质：</p><ol><li>$ \phi(n) = \prod_{i=1}^{m} \phi(n_i) $</li><li>$ \phi(p^k) = p^{k-1}(p-1) $</li><li>$ \phi(p) = p - 1 $</li></ol><p>那么欧拉函数可以通过以下公式①计算：</p><script type="math/tex; mode=display">\phi(n) = p_1^{k_1 - 1} (p_1 - 1) \cdot p_2^{k_2 - 1} (p_2 - 1) \cdots p_m^{k_m - 1} (p_m - 1)</script>]]>
    </content>
    <id>https://lr2006-robot.github.io/myblog.github.io/post/1003.html</id>
    <link href="https://lr2006-robot.github.io/myblog.github.io/post/1003.html"/>
    <published>2026-02-20T13:49:00.000Z</published>
    <summary>
      <![CDATA[<p>在前两章中，我们已经掌握了整数关系和同余关系的基本概念，这些工具为我们理解数字之间的关系奠定了基础。而在本章中，我们将进入一个更深层次的领域：二次剩余。</p>
<p>本章存在大量定理和证明，虽然有些定理的证明可能比较复杂，但我们会尽量用通俗易懂的语言来解释这些概念。😎<]]>
    </summary>
    <title>密码学数学基础 - 二次剩余</title>
    <updated>2026-02-20T14:42:28.303Z</updated>
  </entry>
  <entry>
    <author>
      <name>Dorange</name>
    </author>
    <category term="密码学数学基础" scheme="https://lr2006-robot.github.io/myblog.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <category term="密码学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <category term="数学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    <category term="数论" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    <content>
      <![CDATA[<p>在上一章中，我们探讨了整数关系的基本概念，这些工具为我们理解数字之间的关系奠定了基础。而在本章中，我们将进入一个更深层次的领域：同余关系与模运算。这些概念不仅是数论中的重要内容，也是密码学中不可或缺的工具。</p><p>同余关系和模运算为我们提供了一种新的视角来看待整数之间的关系。它们让我们能够在一个有限的范围内进行计算，这对于设计和分析加密算法来说至关重要。无论是经典的凯撒密码，还是现代的 RSA 加密算法，同余关系和模运算都在其中扮演着重要的角色。</p><p>这个章节初步认识模这个重要概念，一定要跟上哦~~~🚀</p><p>Bout to say goobye, bout to give up, until I met you, Mari, I can’t control.</p><h2><span id="模运算与同余关系">模运算与同余关系 🥰</span></h2><p>模运算是一种数学运算，它将一个数除以另一个数，并返回余数。我们用符号 $mod$ 来表示模运算。设$a=bq+r$，其中 $r$ 是余数，那么我们说 $a \equiv r \mod b$。例如，$7 \mod 3$ 的结果是 $1$，因为 $7$ 除以 $3$ 的商是 $2$，余数是 $1$。</p><p>可以看出，模和整除是密切相关的。模运算可以看作是整除的一种扩展，它不仅告诉我们一个数是否能被另一个数整除，还告诉我们在不能整除的情况下，余数是什么。因此，模运算将整数映射到一个有限的范围内，这个范围由模数决定。模为数 $n$ 定义了一个整数集合 ${0, 1, 2, \ldots, n-1}$，在这个集合中进行的运算称为模运算。</p><p>特殊的，负数的模运算结果也可以通过添加模数来得到。例如，$-1 \mod 3$ 的结果是 $2$，因为 $-1 + 3 = 2$。</p><p>同余关系是指两个整数在模运算下具有相同的余数。我们用符号 $\equiv$ 来表示同余关系。例如，$7 \equiv 1 \mod 3$，因为 $7$ 和 $1$ 在模 $3$ 下具有相同的余数。</p><p>同余关系具有一些重要的性质：</p><ol><li>反身性：对于任何整数 $a$，都有 $a \equiv a \mod n$</li><li>对称性：如果 $a \equiv b \mod n$，则 $b \equiv a \mod n$。</li><li>传递性：如果 $a \equiv b \mod n$ 且 $b \equiv c \mod n$，则 $a \equiv c \mod n$</li><li>加法：如果 $a \equiv b \mod n$ 和 $c \equiv d \mod n$，则 $a \pm c \equiv b \pm d \mod n$</li><li>乘法：如果 $a \equiv b \mod n$ 和 $c \equiv d \mod n$，则 $ac \equiv bd \mod n$</li><li>指数：如果 $a \equiv b \mod n$，则对于任何非负整数 $k$，都有 $a^k \equiv b^k \mod n$</li></ol><h2><span id="逆元模反元素">逆元（模反元素） 😗</span></h2><p>在模运算中，逆元（也称为模反元素）是指对于一个整数 $a$ 和一个模数 $n$，如果存在一个整数 $x$ 使得 $ax \equiv 1 \mod n$，那么我们称 $x$ 是 $a$ 的逆元，记作 $a^{-1} \mod n$。换句话说，逆元是一个数，使得它与原数的乘积在模运算下等于 1，在范围 $0$ 到 $n-1$ 之间是唯一的。</p><p>我们可以使用扩展欧几里得算法计算逆元$x$。$ax \equiv 1 \mod n$ 可以写作 ax = 1 + kn ，其中k是某个整数。根据裴蜀定理，存在整数x和y使得 ax + ny = 1 。因此，x就是a的逆元。</p><p>需要注意的是，并不是所有的整数都存在逆元。只有当 $a$ 和 $n$ 互质时，$a$ 才有逆元。这是因为如果 $a$ 和 $n$ 有公共因数，那么 $ax$ 将无法等于 1。</p><h2><span id="消去律与一次同余方程">消去律与一次同余方程 🙃</span></h2><p>消去律①是指在模运算中，如果 $ac \equiv bc \mod n$ 且 $\gcd(c,n) = g$，那么可以消去 $c$，得到 $a \equiv b \mod \frac{n}{g}$。这个性质在解一次同余方程时非常有用。</p><p>一次同余方程的形式是 $ax \equiv b \mod n$。如果 $\gcd(a,n) = 1$，那么该方程有唯一解。解法是先求出 $a$ 的逆元 $a^{-1}$，然后将方程两边同时乘以 $a^{-1}$，得到 $x \equiv a^{-1}b \mod n$。</p><p>如果 $\gcd(a,n) = d &gt; 1$，那么该方程可以使用消去律来简化。首先检查 $d$ 是否整除 $b$，如果不整除，则方程无解。如果整除，则可以将方程两边同时除以 $d$，得到一个新的同余方程 $a’x \equiv b’ \mod n’$，其中 $a’ = \frac{a}{d}$，$b’ = \frac{b}{d}$，$n’ = \frac{n}{d}$。这个新的方程就可以使用前面的方法来求解了。</p><h2><span id="一次同余方程与中国剩余定理">一次同余方程与中国剩余定理 🥳</span></h2><p>求解一次同余方程$ax \equiv b \mod n$ 的方法实际上前面已经介绍了，先用消去律将方程简化为 $a’x \equiv b’ \mod n’$，然后求出 $a’$ 的逆元 $a’^{-1}$，最后得到 $x \equiv a’^{-1}b’ \mod n’$。</p><p>如果我们有多个同余方程需要同时满足，那么我们就需要使用中国剩余定理（Chinese Remainder Theorem）②来求解。一次同余方程组的形式是：</p><script type="math/tex; mode=display">\begin{cases}x \equiv a_1 \mod n_1 \\x \equiv a_2 \mod n_2 \\\vdots \\x \equiv a_m \mod n_m\end{cases}</script><p>中国剩余定理告诉我们，如果 $n_1, n_2, \ldots, n_m$ 互质，那么这个同余方程组有唯一解，并且可以通过以下步骤来求解：</p><ol><li>计算 $N = n_1 n_2 \cdots n_m$。</li><li>对于每个 $i$，计算 $M_i = \frac{N}{n_i}$。</li><li>对于每个 $i$，计算 $M^{-1}_i$，使得 $M_i M^{-1}_i \equiv 1 \mod n_i$。</li><li>最后，解 $x$ 可以通过以下公式计算：<script type="math/tex; mode=display">x = \sum_{i=1}^{m} a_i M_i M^{-1}_i \mod N</script></li></ol><p>实际上，求解一次同余方程也可以用CRT（中国剩余定理）来解决，以达到当模数较大时简化计算的目的。只需要将模数n分解成互质的因数，然后将原方程转化为多个同余方程，最后使用CRT来求解即可。</p><h2><span id="结论12证明">结论①②证明 😨</span></h2><p>本章节的定理和算法虽然比较基础，但我们来简单证明一下吧。（一定不是因为CRT比较重要和常用🤪）</p><h3><span id="结论1证明">结论①证明 🤐</span></h3><p>设 $g = \gcd(c, n)$，则 $c = g c’$ 和 $n = g n’$，其中 $\gcd(c’, n’) = 1$。<br>因为 $ac \equiv bc \mod n$，所以 $g(ac’ - bc’) \equiv 0 \mod gn’$，即 $ac’ - bc’ \equiv 0 \mod n’$。<br>由于 $\gcd(c’, n’) = 1$，所以可以消去 $c’$，得到 $a \equiv b \mod n’$。</p><h3><span id="结论2证明">结论②证明 💀</span></h3><p>设 $N = n<em>1 n_2 \cdots n_m$，则对于每个 $i$，$M_i = \frac{N}{n_i}$。<br>因为 $n_i$ 和 $M_i$ 互质，所以存在 $M^{-1}_i$ 使得 $M_i M^{-1}_i \equiv 1 \mod n_i$。<br>因此，$a_i M_i M^{-1}_i \equiv a_i \mod n_i$，对于 $j \neq i$，$a_j M_j M^{-1}_j \equiv 0 \mod n_i$。<br>所以，$x = \sum</em>{i=1}^{m} a_i M_i M^{-1}_i \equiv a_i \mod n_i$ 对于每个 $i$ 都成立。<br>因此，$x$ 是同余方程组的解，并且由于 $n_1, n_2, \ldots, n_m$ 互质，解是唯一的。证明完毕。</p><p>上一章：<a href="https://luoca.net/posts/1001.html">密码学数学基础 - 整数关系</a> 👈<br>下一章：<a href="https://luoca.net/posts/1003.html">密码学数学基础 - 二次剩余</a> 👈</p>]]>
    </content>
    <id>https://lr2006-robot.github.io/myblog.github.io/post/1002.html</id>
    <link href="https://lr2006-robot.github.io/myblog.github.io/post/1002.html"/>
    <published>2026-02-19T15:12:00.000Z</published>
    <summary>
      <![CDATA[<p>在上一章中，我们探讨了整数关系的基本概念，这些工具为我们理解数字之间的关系奠定了基础。而在本章中，我们将进入一个更深层次的领域：同余关系与模运算。这些概念不仅是数论中的重要内容，也是密码学中不可或缺的工具。</p>
<p>同余关系和模运算为我们提供了一种新的视角来看待整数之]]>
    </summary>
    <title>密码学数学基础 - 同余关系与模运算</title>
    <updated>2026-02-20T14:31:36.393Z</updated>
  </entry>
  <entry>
    <author>
      <name>Dorange</name>
    </author>
    <category term="密码学数学基础" scheme="https://lr2006-robot.github.io/myblog.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <category term="密码学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <category term="数学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    <category term="数论" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    <content>
      <![CDATA[<p>在我们踏上密码学数学基础的冒险之旅后，第一站就是整数关系的世界。这个领域虽然看似简单，但却是构建整个密码学大厦的基石。无论是最基本的整除关系，还是更复杂的同余关系，它们都在为我们揭示数字之间的神秘联系。</p><p>本章将带你深入了解整数关系的核心概念，包括整除、素数、最大公约数和最小公倍数等。我们将通过生动的例子和直观的解释，帮助你掌握这些基本工具，为后续的密码学学习打下坚实的基础。</p><p>别看我说的很高大上，放轻松，这一章真的非常简单口牙。😁</p><p>When I thought my fault that caused all the title to go is only cuz I always move way to slow.</p><h2><span id="整除关系与素数">整除关系与素数 😋</span></h2><p>在整数的世界里，整除关系是最基本的关系之一。我们说一个整数 $ a $ 整除另一个整数 $ b $，记作 $ a \mid b $，如果存在一个整数 $ k $ 使得 $ b = ak $。换句话说，$ b $ 可以被 $ a $ 整除，没有余数。例如，$ 3 \mid 12 $ 因为 $ 12 = 3 \times 4 $，但 $ 5 \nmid 12 $ 因为 $ 12 $ 不能被 $ 5 $ 整除。</p><p>素数是大于 1 的整数，除了 1 和它本身之外没有其他正整数因数。素数在密码学中扮演着重要的角色，因为许多加密算法都依赖于大素数的性质。例如，RSA 加密算法就是基于两个大素数的乘积来实现安全性的。</p><h2><span id="最大公约数与最小公倍数">最大公约数与最小公倍数 😛</span></h2><p>最大公约数（GCD）是指两个或多个整数的公共约数中最大的一个。比如，$ \text{gcd}(12, 15) = 3 $，因为 3 是 12 和 15 的最大公共约数。</p><p>最小公倍数（LCM）则是指两个或多个整数的公共倍数中最小的一个。例如，$ \text{lcm}(4, 6) = 12 $，因为 12 是 4 和 6 的最小公共倍数。</p><h3><span id="如何求解最大公约数与最小公倍数">如何求解最大公约数与最小公倍数 🤨</span></h3><p>计算最大公约数的一种高效方法是辗转相除法（Euclidean Algorithm）。<br>这个算法基于一个重要的性质①：对于两个整数 $ a $ 和 $ b $，如果 $ a &gt; b $，那么</p><script type="math/tex; mode=display">\text{gcd}(a, b) = \text{gcd}(b, a \mod b)</script><p>通过不断地将较大的数替换为较小的数和它们的余数，我们可以快速找到最大公约数。</p><p>再根据最大公约数和最小公倍数的性质②：</p><script type="math/tex; mode=display">\text{lcm}(a, b) = \frac{|a \times b|}{\text{gcd}(a, b)}</script><p>求出最小公倍数。</p><h2><span id="裴蜀定理与扩展欧几里得算法">裴蜀定理与扩展欧几里得算法 🥰</span></h2><p>裴蜀定理（Bézout’s Identity）是整数关系中的一个重要定理，它告诉我们对于任意两个整数 $ a $ 和 $ b $，存在整数 $ x $ 和 $ y $，使得性质③：</p><script type="math/tex; mode=display">ax + by = \text{gcd}(a, b)</script><p>扩展欧几里得算法（Extended Euclidean Algorithm）就是基于裴蜀定理的一种算法，它不仅可以计算最大公约数，还可以找到满足裴蜀定理的整数 $ x $ 和 $ y $。</p><h2><span id="结论123证明">结论①②③证明 🤓👆</span></h2><p>由于本章节的定理和算法都比较基础，我们来简单证明一下吧。</p><h3><span id="结论1证明">结论①证明 😑</span></h3><h4><span id="带余除法分解">带余除法分解</span></h4><p>假设 $ a = bq + r $，其中 $ q $ 是商，$ r $ 是余数，且 $ 0 \leq r &lt; b $。我们记$ r $为 $ a \mod b $。</p><h4><span id="证明gcdab是b和r的公约数">证明$gcd(a,b)$是$b$和$r$的公约数</span></h4><p>设 $ d = \text{gcd}(a, b) $，则 $ d \mid a $ 和 $ d \mid b $。<br>因为 $ d $ 整除 $ a $ 和 $ bq $，$ d $ 也必须整除 $ r = a - bq $，即 $ d \mid r $。<br>所以，$ d $ 是 $ b $ 和 $ r $ 的公因数，那么一定小于等于最大公因数$ \text{gcd}(b, r) $，故 $ \text{gcd}(a, b) \leq \text{gcd}(b, r) $。</p><h4><span id="证明gcdbr是a和b的公约数">证明$gcd(b,r)$是$a$和$b$的公约数</span></h4><p>设 $ d’ = \text{gcd}(b, r) $，则 $ d’ \mid b $ 和 $ d’ \mid r $。<br>因为 $ d’ $ 整除 $ b $ 和 $ r $，$ d’ $ 也必须整除 $ a = bq + r $，即 $ d’ \mid a $。<br>所以，$ d’ $ 是 $ a $ 和 $ b $ 的公因数，那么一定小于等于最大公因数$ \text{gcd}(a, b) $，故 $ \text{gcd}(b, r) \leq \text{gcd}(a, b) $。</p><h4><span id="总结">总结</span></h4><p>综上所述，$ \text{gcd}(a, b) = \text{gcd}(b, r) $，证明完毕。</p><h3><span id="结论2证明">结论②证明 😪</span></h3><p>设 $ d = \text{gcd}(a, b) $，则 $ a = da’ $ 和 $ b = db’ $，其中 $ a’ $ 和 $ b’ $ 是互质的整数。<br>因此，$ \text{lcm}(a, b) = d \times a’ \times b’ = \frac{|da’ \times db’|}{d} = \frac{|a \times b|}{\text{gcd}(a, b)} $，证明完毕。</p><h3><span id="结论3证明">结论③证明 😨</span></h3><h4><span id="欧几里得算法辗转相除法">欧几里得算法（辗转相除法）</span></h4><p>设 $ d = \text{gcd}(a, b) $。<br>用辗转相除法：</p><script type="math/tex; mode=display">a = bq_1 + r_1 ， 0 < r_1 < b</script><script type="math/tex; mode=display">b = r_1q_2 + r_2 ， 0 < r_2 < r_1</script><p>不断进行下去，直到余数为 0：</p><script type="math/tex; mode=display">r_{n-2} = r_{n-1}q_n + r_n ， 0 < r_n < r_{n-1}</script><script type="math/tex; mode=display">r_{n-1} = r_nq_{n+1} + 0 ， r_n = d</script><p>最后余数为 0，说明 $ r_n = d = \text{gcd}(a, b) $。</p><h4><span id="反向替换求解-x-和-y">反向替换求解 $ x $ 和 $ y $</span></h4><p>倒数第二步：</p><script type="math/tex; mode=display">d = r_n = r_{n-2} - r_{n-1}q_n</script><p>再把$r_{n-1}$用上一行表示：</p><script type="math/tex; mode=display">r_{n-1} = r_{n-3} - r_{n-2}q_{n-1}</script><p>带入：</p><script type="math/tex; mode=display">d = A·r_{n-2} + B·r_{n-3},   A ,B  \in \mathbb{Z}</script><p>一直往上带入，最终可以表示为：<br>$d = x·a + y·b$，其中 $ x, y \in \mathbb{Z} $，证明完毕。</p><p>上一章：<a href="http://lr2006-robot.github.io/myblog.github.io/post/1000.html">密码学数学基础 - 前言</a> 👈<br>下一章：<a href="http://lr2006-robot.github.io/myblog.github.io/post/1002.html">密码学数学基础 - 同余关系与模运算</a> 👈</p>]]>
    </content>
    <id>https://lr2006-robot.github.io/myblog.github.io/post/1001.html</id>
    <link href="https://lr2006-robot.github.io/myblog.github.io/post/1001.html"/>
    <published>2026-02-19T09:18:00.000Z</published>
    <summary>
      <![CDATA[<p>在我们踏上密码学数学基础的冒险之旅后，第一站就是整数关系的世界。这个领域虽然看似简单，但却是构建整个密码学大厦的基石。无论是最基本的整除关系，还是更复杂的同余关系，它们都在为我们揭示数字之间的神秘联系。</p>
<p>本章将带你深入了解整数关系的核心概念，包括整除、素数、最]]>
    </summary>
    <title>密码学数学基础 - 整数关系</title>
    <updated>2026-02-20T14:29:25.872Z</updated>
  </entry>
  <entry>
    <author>
      <name>Dorange</name>
    </author>
    <category term="密码学数学基础" scheme="https://lr2006-robot.github.io/myblog.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <category term="密码学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <category term="数学" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    <category term="数论" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    <category term="前言" scheme="https://lr2006-robot.github.io/myblog.github.io/tags/%E5%89%8D%E8%A8%80/"/>
    <content>
      <![CDATA[<p>你有没有想过，当你在深夜网购🛒、和朋友发私密消息💬、或是登录银行账户🏦时，那些看似 “坚不可摧” 的安全屏障🔒，背后其实是一群数学精灵🧚在默默守护？✨<br>欢迎来到《密码学数学基础》的奇妙世界！这里没有枯燥的公式堆砌（真的假的😋），只有一把把打开信息安全大门的钥匙🗝️。<br>在信息安全的宇宙🌌里，密码学就像是一位神秘的魔法师🧙，而数学则是它手中的魔法棒🪄。本系列文章将带你解锁密码学中最核心的数学知识，特别是数论和代数这两大 “护法”🛡️。从最基础的整除、同余，到高深莫测的群论、环论和域论，我们会一步步揭开这些数学工具的神秘面纱🎭。<br>别担心，我会用轻松有趣的方式（🤣👉🤡），让你发现这些看似高冷的数学概念，其实是设计和分析加密算法与协议的基石🧱。它们不仅是密码学的 “幕后英雄”🦸，还在编码理论、计算复杂性等领域大放异彩🌟。<br>想象一下：<br>当你用 HTTPS 浏览网页时🌐，大素数的乘积正在帮你抵御窃听👂；<br>当你用数字签名确认身份时✍️，椭圆曲线的点运算正在为你保驾护航🚢；<br>当区块链上的交易被永久记录时⛓️，哈希函数的单向性正在守护数据的不可篡改性📜。<br>这些听起来高大上的技术，本质上都是数学规律的巧妙应用🎯。<br>在这个系列里，我们会像侦探🕵️一样，拆解每一个加密算法背后的数学逻辑；像探险家🗺️一样，从最基础的数论概念出发，逐步深入到更复杂的数学工具。你会发现，原来那些让你头疼的抽象概念，其实是构建安全世界的砖瓦🧱；那些看似枯燥的定理，其实是守护数字生活的盾牌🛡️。<br>当然，我们主要用于密码学学习，故而我会将重点放在结论和应用上，而不是过多地纠结于太难的证明和特殊情况（毕竟我们不是数学家😎）。但如果你对某些定理的证明感兴趣，我也会提供一些参考资料，供你深入探索🔍。<br>准备好了吗？让我们一起踏上这场充满挑战与惊喜的数学冒险🚀，解锁信息安全的终极奥义吧！💡</p><p>注：本系列文章编号从 1000 开始，后续章节将依次递增。每篇文章都会在结尾提供下一章的链接，敬请期待！😉<br>回到开始：<a href="http://lr2006-robot.github.io/myblog.github.io/about/">关于我</a> 👈<br>下一章：<a href="http://lr2006-robot.github.io/myblog.github.io/post/1001.html">密码学数学基础 - 整数关系</a> 👈</p>]]>
    </content>
    <id>https://lr2006-robot.github.io/myblog.github.io/post/1000.html</id>
    <link href="https://lr2006-robot.github.io/myblog.github.io/post/1000.html"/>
    <published>2026-02-19T08:00:00.000Z</published>
    <summary>
      <![CDATA[<p>你有没有想过，当你在深夜网购🛒、和朋友发私密消息💬、或是登录银行账户🏦时，那些看似 “坚不可摧” 的安全屏障🔒，背后其实是一群数学精灵🧚在默默守护？✨<br>欢迎来到《密码学数学基础》的奇妙世界！这里没有枯燥的公式堆砌（真的假的😋），只有一把把打开信息安全大门的]]>
    </summary>
    <title>密码学数学基础 - 前言</title>
    <updated>2026-02-20T01:20:47.085Z</updated>
  </entry>
</feed>
